// Class: src/core/lang/Exception.js
class Exception extends Error{
    // message = null
    constructor(message){
        super(message);
        this.message = message;
    }

    toString(){
        return this.message;
    }
};
// Class: src/core/lang/Runnable.js
class Runnable {
    constructor(methodRun) {
        this.run = methodRun;
    }

    async run(){
        
    }
}
// Class: src/core/lang/Thread.js
class Thread {
    constructor(runnableObject) {
        this.runnableObject = runnableObject;
        this.promise = null;
    }

    start(){
        var this_ = this;
        (async () => {
            this_.promise = this_.runnableObject.run();
            console.log("PROMOO",this_.promise);
        })();
    }

    interrupt(){
        if(this.promise)
            this.promise.reject("Hilo interrumpido");
    }

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static async sleep(miliseconds) {
        return new Promise(resolve => {
            setTimeout(resolve, miliseconds);
        });
    }
}
// Class: src/core/lang/Timer.js
class Timer {
    constructor(runnableObject,period) {
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
    }

    schedule(runnableObject,period){
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
        this.start();
    }

    start(){
        if(this.intervalId)
            throw new Error(`El Timer ya se encuentra en ejecución.`);
        var this_ = this;
        this.intervalId = setInterval(function(){
            this_.runnableObject.run();
        }, this.period);
    }

    stop(){
        if(this.intervalId)
            clearInterval(this.intervalId);
        this.intervalId = null;
    }
}
// Class: src/core/lang/Store.js
class Store {
    static get(keyName,defaultValue){
        if(!Store.containsKey(keyName))
            Store.set(keyName,defaultValue);
        Store.checkIfExists(keyName);
        let data = JSON.parse(sessionStorage.getItem(keyName));
        if(data.type)
            return data.value;
        return data;
    }

    static set(key,value){
        sessionStorage.setItem(key,JSON.stringify({
            type: typeof value,
            value
        }));
    }

    static checkIfExists(keyName){
        if(!Store.containsKey(keyName))
            throw new Exception(`No existe el atributo [${keyName}]`);
    }

    static containsKey(keyName){
        return (sessionStorage.getItem(keyName))?true:false;
    }
}
// Class: src/util/FileChooser.js
class FileChooser{
    static async showSelectFile(type) {
        return await new Promise(function (resolve, reject) {
            var domoInput = document.getElementById("files");
            domoInput.click();
            domoInput.onchange = function () {
                var reader = new FileReader();
                reader.onload = function (evt) {
                    //                    var parser = new DOMParser();
                    var contents = evt.target.result;
                    // El contenido se encuentra en Base64
                    // application/octet-stream;base64,UEsDBBQAAAgIAEe8.....
                    let posBase = contents.indexOf(',');
                    contents = posBase === -1 ? contents : contents.substr(posBase + 1);
                    //                    var doc = parser.parseFromString(contents, "application/xml");
                    resolve({
                        fileName: domoInput.files[0].name,
                        data: contents,
                        size: domoInput.files[0].size,
                        lastModified: domoInput.files[0].lastModified
                    });
                    //                    cbSelected(doc.documentElement);
                };
                reader.onerror = function (error) {
                    reject(error);
                },
                    //                reader.readAsBinaryString(domoInput.files[0],"UTF-8");
                reader.readAsDataURL(domoInput.files[0]);
            };
        });
    }

    static async showSaveFile(fileName,urlFile){
        console.log("Descargando archivo",urlFile);
        let a = document.createElement("a");
        a.style = "display: none";
        document.body.appendChild(a);
        a.href = urlFile;
        a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(urlFile);
        a.remove();
    }
};
// Class: src/core/net/DefaultHttpClient.js
class DefaultHttpClient {
    constructor() {
    }

    async execute(httpRequest){
        return await httpRequest.send();
    }
}
// Class: src/core/net/HttpRequest.js
class HttpRequest {
    // this.url
    // params
    // data
    // xmlhttp
    constructor(url) {
        this.url = url;
        this.params = new Array();
        if (window.XMLHttpRequest)
            this.xmlhttp = new XMLHttpRequest();
        else
            this.xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }

    setEntity(d) {
        this.data = d;
    }

    getMethod() {
        return null;
    }
    // setUrl(url) {
    //     this.url = url;
    // }
    addParam(name, value) {
        this.params[name] = value;
    }
    async send() {
        let result = await new Promise((resolve, reject) => {
            console.log("HTTP METODO", this.getMethod());
            console.log("URL", this.url);
            var url = this.url;
            if (this.params.length > 0) {
                if(url.indexOf('?')===-1)
                    url = url + '?';
                for (let elem in this.params) {
                    url = (url + (elem + '=' + this.params[elem]) + "&&");
                }
                url = url.substring(0, url.length - 2);
            }

            this.xmlhttp.open(this.getMethod(), url, true);
            this.xmlhttp.setRequestHeader('Access-Control-Allow-Origin', '*');
            this.xmlhttp.setRequestHeader('Content-Type', 'application/json');
            let this_ = this;
            this.xmlhttp.onreadystatechange = function(){
                if (this_.xmlhttp.readyState === XMLHttpRequest.DONE && this_.xmlhttp.status === 200) {
                    let httpResonse = new HttpResponse(this_.xmlhttp);
                    resolve(httpResonse);
                }
                else
                    reject();
            };
            //        this.xmlhttp.onloadend = function()
            //        {
            //            var httpResonse = new HttpResponse(this_.xmlhttp);
            //            callback(httpResonse);
            //        };
            if(this.data)
                this.xmlhttp.send(JSON.stringify(this.data));
            else
                this.xmlhttp.send();
        });
        return result;
    }
    abort() {
        this.xmlhttp.abort();
        this.xmlhttp = null;
    }
}
// Class: src/core/net/HttpResponse.js
class HttpResponse {
    constructor(xmlhttp) {
        this.xmlhttp = xmlhttp;
    }

    getJson() {
        return JSON.parse(this.xmlhttp.responseText);
    }

    getRootElementXml() {
        return this.xmlhttp.responseXML.documentElement;
    }

    getText() {
        return this.xmlhttp.responseText;
    }
}
// Class: src/core/net/HttpGet.js
class HttpGet extends HttpRequest{
    // @Override
    getMethod(){
        return "GET"; 
    }
}
// Class: src/core/net/HttpPost.js
class HttpPost extends HttpRequest{
    // @Override
    getMethod(){
        return "POST"; 
    }
}
// Class: src/core/net/HttpPut.js
class HttpPut extends HttpRequest{
    // @Override
    getMethod(){
        return "PUT"; 
    }
};
// Class: src/core/net/HttpDelete.js
class HttpDelete extends HttpRequest{
    // @Override
    getMethod(){
        return "DELETE"; 
    }
}
// Class: src/core/Context.js
class Context{
    getLayoutInflater() {
        return new LayoutInflater();
    }
};
// Class: src/core/Resource.js
class Resource{
    static listThemes = new Array();

    static async loadTheme(urlTheme) {
        let rootXml = await this.loadLayoutSync(urlTheme);
        for (let index = 0; index < rootXml.children.length; index++){
            // <style name="PageTheme" parent="Page"></style>
            let styleChildNode = rootXml.children[index];
            let name = styleChildNode.getAttribute("name");
            let parent = styleChildNode.getAttribute("parent");
            let styleObject = {
                name,parent,attributes:{}
            };
            for (let indexJ = 0; indexJ < styleChildNode.children.length; indexJ++){
                //<item name="textColor">#808080</item>
                let attributeChildNode = styleChildNode.children[indexJ];
                let name = attributeChildNode.getAttribute("name");
                let value = attributeChildNode.textContent;
                styleObject.attributes[name] = value;
            }
            this.listThemes.push(styleObject);
        }
    }

    static async loadThemeAttributes(view,nodeXml) {
        // Buscamos si existe el componente
        let wantedView = this.listThemes.find(styleItem => styleItem.parent===view.constructor.name);
        if(wantedView){
            let attributes = wantedView.attributes;
            for (let [key, value] of Object.entries(attributes)) {
                if(nodeXml.getAttribute(key)===null)
                    nodeXml.setAttribute(key,value);
            }
            // console.log(view.constructor.name);
        }
    }

    static async importJs(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].src && scripts[i].src.lastIndexOf(url)!==-1){
                    resolve(scripts[i]);
                    return;
                }
            }
            
            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async importCss(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("link");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].href && scripts[i].href.lastIndexOf(url) !== -1){
                    resolve(scripts[i]);
                    return;
                }
            }

            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('link');
            script.type = 'text/css';
            script.href = url;
            script.rel='stylesheet';
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async import(url){
        if(url.lastIndexOf(".js")!==-1)
            return await this.importJs(url);
        else if(url.lastIndexOf(".css")!==-1)
            return await this.importCss(url);
        else
            throw new Error(`Tipo de archivo [${url}] no soportado. utilice unicamente .js o .css`);
    }
    
    static async importAll(urls) {
        if (Array.isArray(urls) === false)
            throw "Lista de urls vacio para [loadAllScripts]";
        for(let url of urls){
            await Resource.importJs(url);
        }
    };
    
    static async loadLayoutSync(urlXmlLayout){
        let rootXml = await new Promise(function(resolve,reject){
            var xmlhttp;
            if (window.XMLHttpRequest)
                xmlhttp = new XMLHttpRequest();
            else
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4) {
                    if (xmlhttp.status === 200 ||xmlhttp.status === 0) { // Habilitado para archivos en local host (||xmlhttp.status === 0)
                        resolve(xmlhttp.responseXML.documentElement);
                    } else {
                        reject(xmlhttp.statusText);
                    }
                }
            };
            xmlhttp.open("GET", urlXmlLayout, true);
            xmlhttp.send(null);
        });
        return rootXml;
    }

    static async loadImage(urlOrTextBase64){
        if(!urlOrTextBase64)
            throw "No se envió la imagen para la carga";
        if(typeof urlOrTextBase64 !== 'string')
            throw "El parámetro para cargar la imagen no es de tipo texto";
        let imageProm = await new Promise(function(resolve,reject){
            var image = new Image();
            image.onload = function(){
                resolve(image);
            }
            if(Resource.isBase64Resource(urlOrTextBase64)){
                image.src = `data:image/png;base64,${urlOrTextBase64}`;
            }
            else{
                image.src =urlOrTextBase64;
            }
        });
        return imageProm;
    }

    static isBase64Resource(urlOrTextBase64){
        return /data:image\/([a-zA-Z]*);base64,([^\"]*)/g.test(urlOrTextBase64);
    }

    static isImageNinePathResource(urlOrTextBase64){
        return /\.9\.(png|gif)/i.test(urlOrTextBase64);
    }

    static isImageResource(urlOrTextBase64){
        return /.(png|gif|jpg)/i.test(urlOrTextBase64);
    }

    static isColorResource(hexColorText){
        return /^#[0-9A-F]{6}$/i.test(hexColorText);
    }

    static async waitToLoadAllResources(){
        await new Promise(function(resolve){
            let callback = function(){
                resolve();
            };

            if (window.attachEvent){
                window.attachEvent('onload', callback);
            }
            else if (window.addEventListener){
                window.addEventListener('load', callback, false);
            }
            else{
                document.addEventListener('load', callback, false);
            }
        });
    }
}
// Class: src/core/PageManager.js
class PageManager {
    static async getUrlBrouser(){
        let urlBrouser = window.location.href;
        return urlBrouser;
    }

    static async getTreeNavigation(){
        let tree = Store.get('TREE',{
            ROOT: {
                extras:{},
                navigation: {},
                pageName: null
            }
        });
        return tree;
    }

    static async getArrayNavegation(){
        let urlBrouser = await PageManager.getUrlBrouser();

        if(urlBrouser.lastIndexOf('#/') !== -1) {
            let listPages = urlBrouser.substring(urlBrouser.lastIndexOf('#/')+2);
            let posQuery = listPages.indexOf('?');
            if(posQuery != -1)
                listPages = listPages.substring(0,posQuery);
            return {
                pageNames: listPages.split('/'),
                queryParams: {}
            };
        }
        return {
            pageNames: new Array(),
            queryParams: {}
        };
    }

    static async startApp(manifestConfig){
        // Cargando tema
        await Resource.loadTheme(manifestConfig.theme);

        // Establecemos los valores correspondientes para los componentes HTML, BODY
        await PageManager.configApp();

        // Guardamos en sesion la configuración del objeto Manifesto
        Store.set('MANIFEST',manifestConfig);

        let navigationList = await PageManager.getArrayNavegation();

        if(navigationList.pageNames.length > 0){ // Actualizar pagina establecida
            if(navigationList.pageNames.length > 1){ // Existe una navegacion previa con varias paginas
                let tree = await Store.get('TREE');
                let currentPageConfig = tree.ROOT;
                let index = 0;
                // let pageName = navigationList.listPages[index];
                while(index < navigationList.pageNames.length){
                    if(currentPageConfig.pageName === navigationList.pageNames[index]){
                        if(index + 1 < navigationList.pageNames.length ){
                            // Obtenemos el nombre de la pagina siguiente
                            let pageNameNext = navigationList.pageNames[index+1];
                            // Verificamos si la siguiente pagina existe en arbol de navegacion
                            if(currentPageConfig.navigation[pageNameNext]){ // Existe la pagina en el arbol?
                                currentPageConfig = currentPageConfig.navigation[pageNameNext];
                                index++;
                                continue;
                            }
                            else{
                                alert("No se pudo encontrar la pagina: "+pageNameNext);
                                return;
                            }
                        }
                        else // Se encontro la ultima raiz del arbol que corresponde a la pagina actual
                            break;
                    }
                    else{
                        alert(`La pagina no es igual [${currentPageConfig.pageName}] que [${navigationList.pageNames[index]}], INDEX = [${index}]`);
                        return;
                    }
                }
    
                // Iniciamos la pagina con los datos guardados en la session
                let intent = new Intent(currentPageConfig.extras, currentPageConfig.pageName);
                let pageInstance = await PageManager.startPageFromIntent(intent);
                return;
            }else{ // Se desea cargar una pagina configurada en el manifest
                let mainPageName = navigationList.pageNames[0];
                let pageConfig = PageManager.findPageConfig(manifestConfig,mainPageName);

                // Agregamos como pagina raiz
                let treeNavigation = {
                    ROOT: {
                        extras: {},
                        navigation: {},
                        pageName: mainPageName,
                        query: {}
                    }
                }

                // Guardamos el nodo raiz en el arbol de navegación
                Store.set('TREE',treeNavigation);

                // Iniciamos la actividad principal
                let intent = new Intent(null, mainPageName);
                await PageManager.startPageFromIntent(intent);
                return;
            }
        }
        
        // Validando manifest
        let mainPageName = PageManager.findRootPageName(manifestConfig);

        // Colocando la pagina en la URL
        window.location.href = `#/${mainPageName}`;

        // Agregamos como pagina raiz
        let treeNavigation = {
            ROOT: {
                extras: {},
                navigation: {},
                pageName: mainPageName,
                query: {}
            }
        }

        // Guardamos el nodo raiz en el arbol de navegación
        Store.set('TREE',treeNavigation);

        // Iniciamos la actividad principal
        let intent = new Intent(null, mainPageName);
        await PageManager.startPageFromIntent(intent);
    }

    static findRootPageName(manifestConfig){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.category=='ROOT');
        if(!pageConfig){
            throw new Exception(`No se encontro nin una pagina principal. Categorice la pagina agregando el atributo [category=='ROOT'] en el Manifest`);
        }
        let posBarra = pageConfig.name.lastIndexOf('/');
        let pageName = pageConfig.name.substring(posBarra+1,pageConfig.name.lastIndexOf('.js'));
        return pageName;
    }

    static findPageConfig(manifestConfig,pageName){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.name.lastIndexOf(`/${pageName}.js`) !== -1);
        if(!pageConfig){
            throw new Exception(`No se encontro la página [${pageName}] en la configuración del Manifest`);
        }
        return pageConfig;
    }

    static async configApp() {
        // Eliminamos margenes y padding del contenedor principal (body,html)
        document.body.style.paddingBottom = '0px';
        document.body.style.paddingTop = '0px';
        document.body.style.paddingLeft = '0px';
        document.body.style.paddingRight = '0px';
        document.body.style.margin = '0px';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
        document.body.style.position = 'absolute';

        // DESABILITAR ELEMENTOS NO SELECCIONABLES
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        //padding: 4px 20px;
        sheet.innerHTML = `html,body,div,span,img{
                                                    -webkit-user-select: none;
                                                    -khtml-user-select: none;
                                                    -moz-user-select: none;
                                                    -o-user-select: none;
                                                    -ms-user-select: none;
                                                    user-select: none;
                                                }`;
        document.body.appendChild(sheet);
        
        // MULTIDIMENSION
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        sheet.innerHTML = `@keyframes rotate{from {rotate:360deg;} to {rotate:0deg;}}
                           @-moz-keyframes rotate-record {0%   {-moz-transform: rotate(360deg);}100% {-moz-transform: rotate(0deg);}}
                           .rotate {-webkit-animation:rotate-record .8s infinite linear;-moz-animation:rotate-record .8s infinite linear;}`;

        document.body.appendChild(sheet);
    }

    static async startPageFromIntent(intent) {
        // Buscamos y verificamos si la pagina este presente en el Manifest
        let manifestConfig = Store.get('MANIFEST');
        // let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.className === intent.pageName);
        let pageConfig = PageManager.findPageConfig(manifestConfig,intent.pageName);

        // Importamos el script
        await Resource.import(pageConfig.name);

        // Instanciamos la Pagina
        var page = null;
        try {
            page = eval(`new ${intent.pageName}()`);
        }
        catch (o) {
            throw new Exception("No existe la pagina [" + intent.pageName + "]");
        }
        await PageManager.loadPage(intent.context, page, intent);
        return page;
    }

    // proProgress:{left:?,top:?,width,height,showBackground:true}
    static async loadPage(previusPage, page, intent) {
        page.previusPage = previusPage;
        // LLamamos el on create de la pagina
        await page.onCreate(intent);
        let pageAnimation = new SpinnerAnimation();
        pageAnimation.show();

        if (previusPage !== null) {
            // VER QUE SE REALIZARA PARA ESTE CASO
            
            // if (previusPage.history === false)
            //     this.removeContext(previusPage);
            // previusPage.onDestroy();
        }
        // Verificamos si tiene contenido la pagina
        if(!page.viewRoot && !page.urlView)
            throw new Exception(`La pagina [${page.constructor.name}] no tiene contenido definido. Asigne un contenido con page.setContentView`);
        if(page.urlView){ // La pagina cargara los elementos a partir de una URL
            let rootXml = await Resource.loadLayoutSync(page.urlView);
            page.viewRoot = LayoutInflater.inflate(page,rootXml);
        }

        document.body.appendChild(page.viewRoot.createDomElement());
        // page.startLoaded(); // Iniciando carga

        var navigator = this.getWindowsDimension();
        await page.viewRoot.loadResources();
        await page.viewRoot.onMeasureSync(navigator.width,navigator.height);
        page.loadedFinized(); // Carga finalizada
        pageAnimation.hide();

        // Guardamos la pagina actual en la URL
        document.title = page.constructor.name;

        // history.pushState({}, null, newUrlIS);

        await page.onStart(intent);
    }

    static removeContext(context) {
        var element = context.viewRoot.elemDom;
        element.parentNode.removeChild(element);
        context.onDestroy();
    }

    static finishPage(context) {
        this.removeContext(context);
    }

    static getWindowsDimension() {
        //        return {
        //                    width:document.body.clientWidth,
        //                    height:document.body.clientHeight
        //               };
        var dim = {
            width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
            height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
        };
        return dim;
    }
}
// Class: src/core/Intent.js
class Intent{
    // context
    // pageName
    constructor(context, pageName){
        this.extras = {};
        this.context= context;
        this.pageName = pageName;
    }

    putExtra(name, value) {
        this.extras[name] = value;
    }
    getExtra(name) {
        return this.extras[name];
    };
}
// Class: src/core/LayoutInflater.js
class LayoutInflater{
    // Atributos generales para los layouts
    static ATTR_LAYOUT_WIDTH = "layout_width";
    static ATTR_LAYOUT_HEIGHT= "layout_height";
    static ATTR_ID= "id";
    static ATTR_LAYOUT_GRAVITY= "layout_gravity";

    static ATTR_LAYOUT_GRAVITY_LEFT = "left";
    static ATTR_LAYOUT_GRAVITY_RIGHT = "right";
    static ATTR_LAYOUT_GRAVITY_TOP = "top";
    static ATTR_LAYOUT_GRAVITY_BOTTOM = "bottom";
    static ATTR_LAYOUT_GRAVITY_CENTER = "center";
    static ATTR_LAYOUT_GRAVITY_CENTER_H = "center_horizontal";
    static ATTR_LAYOUT_GRAVITY_CENTER_V = "center_vertical";

    static ATTR_LAYOUT_MARGIN= "layout_margin";
    static ATTR_LAYOUT_MARGIN_TOP= "layout_marginTop";
    static ATTR_LAYOUT_MARGIN_LEFT= "layout_marginLeft";
    static ATTR_LAYOUT_MARGIN_RIGHT= "layout_marginRight";
    static ATTR_LAYOUT_MARGIN_BOTTOM= "layout_marginBottom";

    static ATTR_PADDING= "padding";
    static ATTR_PADDING_TOP= "paddingTop";
    static ATTR_PADDING_LEFT= "paddingLeft";
    static ATTR_PADDING_RIGHT= "paddingRight";
    static ATTR_PADDING_BOTTOM= "paddingBottom";

    static ATTR_ON_CLICK= "onClick";
    static ATTR_BACKGROUND= "background";
    static ATTR_ORIENTATION= "orientation";
    // Utilizado solo en LinearLayout
    static ATTR_LAYOUT_WEIGHT= "layout_weight";

    // Atributos de RelativeLayout
    static ATTR_LAYOUT_ALIGNPARENTLEFT= "layout_alignParentLeft";// true;false
    static ATTR_LAYOUT_ALIGNPARENTTOP= "layout_alignParentTop";//true;false
    static ATTR_LAYOUT_ALIGNPARENTRIGHT= "layout_alignParentRight";//true;false
    static ATTR_LAYOUT_ALIGNPARENTBOTTOM= "layout_alignParentBottom";//true;false

    static ATTR_LAYOUT_CENTERHORIZONTAL= "layout_centerHorizontal";//true;false
    static ATTR_LAYOUT_CENTERVERTICAL= "layout_centerVertical";//true;false
    static ATTR_LAYOUT_CENTERINPARENT= "layout_centerInParent";//true;false

    static ATTR_LAYOUT_ABOVE= "layout_above";//id
    static ATTR_LAYOUT_BELOW= "layout_below";//id

    static ATTR_LAYOUT_TORIGHTOF= "layout_toRightOf";//id
    static ATTR_LAYOUT_TOLEFTOF= "layout_toLeftOf";//id

    static ATTR_MIN_WIDTH= "minWidth";
    static ATTR_MIN_HEIGHT= "minHeight";

    // TextView
    static ATTR_LAYOUT_TEXT= "text";
    static ATTR_DRAWABLE_LEFT= "drawableLeft";
    static ATTR_DRAWABLE_TOP= "drawableTop";
    static ATTR_DRAWABLE_BOTTOM= "drawableBottom";
    static ATTR_DRAWABLE_RIGHT= "drawableRight";

    // ImageVIew
    static ATTR_SRC= "src";
    static ATTR_SCALE_TYPE= "scaleType";

    static FIT_XY= "fitXY";
    static FIT_START= "fitStart";
    static FIT_CENTER= "fitCenter";
    static FIT_CENTER_CROP= "fitCenterCrop";
    static FIT_CENTER_INSIDE= "fitCenterInside";
    static FIT_END= "fitEnd";
    //CENTER = "center"

    // LinearLayout
    static LIN_ORIENTATION_HORIZONTAL= "horizontal";
    static LIN_ORIENTATION_VERTICAL= "vertical";

    // vista
    static ATTR_VISIBILITY= "visibility";

    // Valores que pueden tomar los atributos
    static MATCH_PARENT= "match_parent";
    static WRAP_CONTENT= "wrap_content";
    static LEFT= "left";
    static RIGHT= "right";
    static BOTTOM= "bottom";
    static CENTER_HORIZONTAL= "center_horizontal";
    static CENTER_VERTICAL= "center_vertical";
    static CENTER= "center";
    static TOP= "top";

    static VISIBLE= "visible";
    static INVISIBLE= "invisible";
    static GONE= "gone";

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static parse(context, firstElement) {
        var view = null;
        try {
            var view = eval("new " + firstElement.tagName + "(context)");
        }
        catch (o) {
            console.log(o);
            throw new Exception("No existe la vista [" + firstElement.tagName + "]");
        }
        view.parse(firstElement);
        return view;
    }

    static inflate(context,xmlRoot) {
        var view = this.parse(context, xmlRoot);
        return view;
    }
}
// Class: src/view/background/BaseBackground.js
class BaseBackground{
    constructor(view,domElement){
        this.view = view;
        this.domElement = domElement;
    }
    async load(){}
    async paint(){}
}
// Class: src/view/background/ColorBackground.js
class ColorBackground extends BaseBackground{
    constructor(view,domElement,color){
        super(view,domElement);
        this.color= color;
    }
    async load(){
        this.domElement.style.background = this.color;
    }
    async paint(){}
}
// Class: src/view/background/EmplyBackground.js
class EmplyBackground extends BaseBackground{
    constructor(view,domElement){
        super(view,domElement);
    }
    async load(){
        this.domElement.style.background='none';
    }
    async paint(){}
}
// Class: src/view/background/ImageBackground.js
class ImageBackground extends BaseBackground{
    constructor(view,domElement,urlOrBase64Image){
        super(view,domElement);
        this.urlOrBase64Image = urlOrBase64Image;
    }

    async load(){
        if(Resource.isImageResource(this.urlOrBase64Image))
            this.domElement.style.background = `url('${this.urlOrBase64Image}')`;
        else
            this.domElement.style.background = `data:image/png;base64,${urlOrBase64Image}`;
        // auto|length|cover|contain|intial|inherit
        this.domElement.style.backgroundRepeat = 'no-repeat';
        this.domElement.style.backgroundOrigin = "content-box";
    }

    async paint(){
        this.domElement.style.backgroundSize = `${this.domElement.clientWidth}px ${this.domElement.clientHeight}px`;
    }
}
// Class: src/view/background/NinepathBackground.js
class NinepathBackground extends BaseBackground{
    constructor(view,domElement,imageNinePathBase64){
        super(view,domElement);
        // Padding
        this.padding = null;
        // Stores the pieces used to generate the horizontal layout
        this.horizontalPieces = null;
        // Stores the pieces used to generate the vertical layout
        this.verticalPieces = null;
        this.imageNinePathBase64 = imageNinePathBase64;
        // Stores the 9patch image
        this.bgImage = null;
    }

    getPieces(data, staticColor, repeatColor){
        let tempDS, tempPosition, tempWidth, tempColor, tempType;
        let tempArray = new Array();

        tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7];
        tempDS = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
        tempPosition = 1;

        for (var i = 4, n = data.length - 4; i < n; i += 4) {
            tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3];
            tempType = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
            if (tempDS !== tempType) {
                // box changed colors
                tempWidth = (i / 4) - tempPosition;
                tempArray.push(new Array(tempDS, tempPosition, tempWidth));

                tempDS = tempType;
                tempPosition = i / 4;
                tempWidth = 1;
            }
        }
        
        // push end
        tempWidth = (i / 4) - tempPosition;
        tempArray.push(new Array(tempDS, tempPosition, tempWidth));

        return tempArray;
    }

    getPadBorder(dataPad, width, height){
        var staticRight = dataPad[0] + ',' + dataPad[1] + ',' + dataPad[2] + ',' + dataPad[3];
        var pad = { top: 0, bottom: 0 };
    
        // Padding para la parte superior
        for (var i = 0; i < dataPad.length; i += 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.top++;
        }
        // padding inferior
        for (var i = dataPad.length - 4; i >= 0; i -= 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.bottom++;
        }
        return pad;
    }

    draw(){
        var dCtx, dCanvas, dWidth, dHeight;

        if (this.horizontalPieces === null)
            return;
    
        dWidth = this.domElement.clientWidth;
        dHeight = this.domElement.clientHeight;
        if(dWidth=== 0 && dHeight===0){
            console.warn("Dimensiones boton ",dWidth,dHeight);
            return;
        }
    
        if (dWidth === 0 || dHeight === 0)
            return;
    
        dCanvas = document.createElement('canvas');
        dCtx = dCanvas.getContext('2d');
    
        dCanvas.width = dWidth;
        dCanvas.height = dHeight;
    
        var fillWidth, fillHeight;
        // Determine the width for the static and dynamic pieces
        var tempStaticWidth = 0;
        var tempDynamicCount = 0;
    
        for (var i = 0, n = this.horizontalPieces.length; i < n; i++) {
            if (this.horizontalPieces[i][0] === 's')
                tempStaticWidth += this.horizontalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount;
    
        // Determine the height for the static and dynamic pieces
        var tempStaticHeight = 0;
        tempDynamicCount = 0;
        for (var i = 0, n = this.verticalPieces.length; i < n; i++) {
            if (this.verticalPieces[i][0] === 's')
                tempStaticHeight += this.verticalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillHeight = (dHeight - tempStaticHeight) / tempDynamicCount;
    
        // Loop through each of the vertical/horizontal pieces and draw on
        // the canvas
        for (var i = 0, m = this.verticalPieces.length; i < m; i++) {
            for (var j = 0, n = this.horizontalPieces.length; j < n; j++) {
                var tempFillWidth, tempFillHeight;
    
                tempFillWidth = (this.horizontalPieces[j][0] === 'd') ?
                    fillWidth : this.horizontalPieces[j][2];
                tempFillHeight = (this.verticalPieces[i][0] === 'd') ?
                    fillHeight : this.verticalPieces[i][2];
    
                // Stretching :
                if (this.verticalPieces[i][0] !== 'r') {
                    // Stretching is the same function for the static squares
                    // the only difference is the widths/heights are the same.
                    if (tempFillWidth >= 0 && tempFillHeight >= 0) {
                        dCtx.drawImage(
                            this.bgImage,
                            this.horizontalPieces[j][1], this.verticalPieces[i][1],
                            this.horizontalPieces[j][2], this.verticalPieces[i][2],
                            0, 0,
                            tempFillWidth, tempFillHeight);
                    }
                    else
                        break;
                }
                else {
                    var tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.horizontalPieces[j][2];
                    tempCanvas.height = this.verticalPieces[i][2];
    
                    var tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(
                        this.bgImage,
                        this.horizontalPieces[j][1], this.verticalPieces[i][1],
                        this.horizontalPieces[j][2], this.verticalPieces[i][2],
                        0, 0,
                        this.horizontalPieces[j][2], this.verticalPieces[i][2]);
    
                    var tempPattern = dCtx.createPattern(tempCanvas, 'repeat');
                    dCtx.fillStyle = tempPattern;
                    dCtx.fillRect(
                        0, 0,
                        tempFillWidth, tempFillHeight);
                }
    
                // Shift to next x position
                dCtx.translate(tempFillWidth, 0);
            }
    
            // shift back to 0 x and down to the next line
            dCtx.translate(-dWidth, (this.verticalPieces[i][0] === 's' ? this.verticalPieces[i][2] : fillHeight));
        }
    
        // store the canvas as the div's background
        var url = dCanvas.toDataURL("image/png");
        var tempIMG = new Image();
    
        var _this = this;
        tempIMG.onload = ()=>{
            this.domElement.style.background = `url(${url}) no-repeat`;
        };
        tempIMG.src = url;
    }

    // @Override
    async load(){
        // Limpiando fondo de boton
        this.view.elemDom.style.border = "none"

        // Obteniendo datos de la imagen ninepath.9
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // Cargamos la imagen 
        this.bgImage = await Resource.loadImage(this.imageNinePathBase64);
        this.domElement.style.background = 'none';
        this.domElement.style.backgroundRepeat = "no-repeat";

        // this.view.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        
        // Obteniendo padding
        // var tempCtx, tempCanvas;
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.bgImage.width;
        tempCanvas.height = this.bgImage.height;
        this.tempCtx = tempCanvas.getContext('2d');
        this.tempCtx.drawImage(this.bgImage, 0, 0);

        var dataPad = this.tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        this.padding.top = padRight.top;
        this.padding.bottom = padRight.bottom;
        dataPad = this.tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        this.padding.left = padBottom.top;
        this.padding.right = padBottom.bottom;

        this.view.padding= this.padding;
    }
    
    // @Override
    async paint(){
        // Create a temporary canvas to get the 9Patch index data.
        // var tempCtx, tempCanvas;
        // tempCanvas = document.createElement('canvas');
        // tempCanvas.width = this.bgImage.width;
        // tempCanvas.height = this.bgImage.height;
        // tempCtx = tempCanvas.getContext('2d');
        // tempCtx.drawImage(this.bgImage, 0, 0);

        // // Obteniendo el padding lateral derecho
        // var dataPad = tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        // var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        // this.padding.top = padRight.top;
        // this.padding.bottom = padRight.bottom;
        // dataPad = tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        // var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        // this.padding.left = padBottom.top;
        // this.padding.right = padBottom.bottom;

        // Loop over each  horizontal pixel and get piece
        var data = this.tempCtx.getImageData(0, 0, this.bgImage.width, 1).data;

        // Use the upper-left corner to get staticColor, use the upper-right corner
        // to get the repeatColor.
        var tempLength = data.length - 4;
        var staticColor = data[0] + ',' + data[1] + ',' + data[2] + ',' + data[3];
        var repeatColor = data[tempLength] + ',' + data[tempLength + 1] + ',' +
            data[tempLength + 2] + ',' + data[tempLength + 3];
        this.horizontalPieces = this.getPieces(data, staticColor, repeatColor);

        // Loop over each  horizontal pixel and get piece
        data = this.tempCtx.getImageData(0, 0, 1, this.bgImage.height).data;
        this.verticalPieces = this.getPieces(data, staticColor, repeatColor);

        // use this.horizontalPieces and this.verticalPieces to generate image
        this.draw();
    }
}
// Class: src/view/View.js
class View {
    static INVISIBLE = "INVISIBLE";
    static VISIBLE = "VISIBLE";
    static GONE = "GONE";

    constructor(context) {
        if (!context)
            throw new Exception("El contexto no esta en los parametros o es nulo");
        this.context = context;
        this.visibility = View.VISIBLE;
        this.margin = { top: 0, left: 0, right: 0, bottom: 0 };
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // this.elemDom = this.createDomElement();
        this.parentView = null;
        this.maxWidth = 0;
        this.maxHeigth = 0;
        this.minHeigth = 0;
        this.minHeigth = 0;
        this.width = LayoutInflater.WRAP_CONTENT;
        this.height = LayoutInflater.WRAP_CONTENT;
        this.id = null;
        this.background = null;
        this.cssClassList=this.constructor.name;
        this.onClick = null;
        this.onClickDefinition = null;
        this.tooltip = null;
        this.layoutGravity = (LayoutInflater.LEFT + '|' + LayoutInflater.TOP);
        this.audioClick = null;
        this.audioAdove = null;
    }

    setVisibility(v) {
        this.visibility = v;
    }
    setToolTip(text) {
        this.tooltip = text;
    }
    setMinWidth(w) {
        this.minWidth = w;
    }
    getContext() {
        return this.context;
    }
    setMinHeight(h) {
        this.minHeigth = h;
    }
    createDomElement() {
        var elem = document.createElement(this.getTypeElement());
        // Margenes por defector
        elem.style.marginTop = '0px';
        elem.style.marginLeft = '0px';
        elem.style.marginBottom = '0px';
        elem.style.marginRight = '0px';

        // Padding por defecto
        elem.style.paddingTop = '0px';
        elem.style.paddingLeft = '0px';
        elem.style.paddingBottom = '0px';
        elem.style.paddingRight = '0px';

        elem.style.position = 'absolute';
        this.elemDom = elem;
        if(this.id)
            this.elemDom.id = this.id;
        return elem;
    }

    getTypeElement() {
        return this.constructor.name;
    }

    setId(id) {
        this.id = id;
    }

    clone() {
        var copy = Object.assign({}, this);
        copy.elemDom = this.elemDom.cloneNode(true);
    }
    // checkMinSize: function () {
    //     var sw = false;
    //     if (this.getWidth() <= this.minWidth) {
    //         this.elemDom.style.width = this.minWidth + 'px';
    //         sw = true;
    //     }
    //     if (this.getHeight() <= this.minHeigth) {
    //         this.elemDom.style.height = this.minHeigth + 'px';
    //         sw = true;
    //     }
    //     if (sw === true)
    //         this.invalidate();
    // },
    getWidth() {
        // return this.width;
        return this.elemDom? this.elemDom.clientWidth: 0;
    }

    getHeight() {
        return this.elemDom? this.elemDom.clientHeight: 0;
    }
    
    setMargin(margin) {
        if (!margin) return;
        let mg = parseInt(margin);
        this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = mg;
    }
    setMarginTop(margin) {
        if (!margin) return;
        this.margin.top = parseInt(margin);
    }
    setMarginLeft(margin) {
        if (!margin) return;
        this.margin.left = parseInt(margin);
    }
    setMarginRight(margin) {
        if (!margin) return;
        this.margin.right = parseInt(margin);
    }
    setMarginBottom(margin) {
        if (!margin) return;
        this.margin.bottom = parseInt(margin);
    }
    getBackground() {
        return this.background;
    }
    setBackground(background) {
        this.background = background;
    }
    setWidth(width) {
        this.width = width;
    }
    setHeight(height){
        this.height = height;
    }
    setLayoutGravity(gravity) {
        this.layoutGravity = gravity;
    }
    setOnClickListener(onCLick) {
        if (onCLick === null){
            this.onClick = null;
            return;
        }

        if (typeof onCLick === 'string') {
            // Buscamos el nombre de metodo en el contexto
            var propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this.context));
            if(propertyNames.find(property=>property===onCLick)){
                this.onClick = async function(){
                        // Object.getPrototypeOf(this.context)[onCLick];
                    Reflect.apply(Reflect.get(this.context,onCLick), this.context,this);
                }
            }else
                throw new Exception(`No se pudo encontrar la funcion [${onCLick}] dentro del contexto [${this.context.constructor.name}]`);
        }else if (typeof onCLick === 'function') {
            this.onClick = onCLick;
        }
    }
    setMP(dr, ic, txt, tc) {
        var popupError = new PopupWindow(this.getContext());
        var message = new TextView(popupError);
        message.setText(txt);
        if (ic !== null)
            message.setDrawableLeft(ic);
        message.setBackground(dr);
        message.setSingleLine(true);
        message.setTextColor(tc);

        popupError.setView(this);
        popupError.setContentView(message);
        popupError.show(function () {
            setTimeout(function () {
                popupError.cancel();
            }, 3000);
        });
    }
    showAlertMsg(msg) {
        this.setMP("res/drawable/util/bg_alerta.9.png", "res/drawable/util/ic_alert.png", msg, "#653400");
    }
    showConfirmMsg(msg) {
        this.setMP("res/drawable/util/bg_confirm.9.png", "res/drawable/util/ic_confirm.png", msg, "#346700");
    }
    showErrorMsg(msg) {
        this.setMP("res/drawable/util/bg_error.9.png", "res/drawable/util/ic_error.png", msg, "#A90400");
    }
    showInfoMsg(msg) {
        this.setMP("res/drawable/util/bg_info.9.png", "res/drawable/util/ic_info.png", msg, "#4C95E7");
    }
    parse(nodeXml) {
        // CARGANDO ATRIBUTOS DEFINIDOS POR EL TEMA SI LO EXISTE
        Resource.loadThemeAttributes(this,nodeXml);

        // VISIBILITY DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_VISIBILITY) !== null) 
            this.visibility = nodeXml.getAttribute(LayoutInflater.ATTR_VISIBILITY);

        // PADDING DEL VIEW
        var padding = nodeXml.getAttribute(LayoutInflater.ATTR_PADDING);
        if (padding !== null) {
            let pad = parseInt(padding);
            this.padding.top = this.padding.left = this.padding.right = this.padding.bottom = pad;
        }
        // MARGEN DEL COMPONENTE
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN)!=null)
            this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_BOTTOM)!=null)
            this.margin.bottom = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_BOTTOM));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_LEFT)!=null)
            this.margin.left = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_LEFT));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_RIGHT)!=null)
            this.margin.right = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_RIGHT));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_TOP)!=null)
            this.margin.top = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_TOP));
        if(nodeXml.getAttribute("paddingLeft"))
            this.padding.left = parseInt(nodeXml.getAttribute("paddingLeft"));
        if(nodeXml.getAttribute("paddingRight"))
            this.padding.right = parseInt(nodeXml.getAttribute("paddingRight"));

        // ID DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_ID) !== null)
            this.id = nodeXml.getAttribute(LayoutInflater.ATTR_ID);

        // LAYOUT GRAVITY DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY) !== null)
            this.layoutGravity = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY);
        // WIDTH DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WIDTH) !== null)
            this.width = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WIDTH);
        // HEIGHT DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_HEIGHT) !== null)
            this.height = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_HEIGHT);
        this.tooltip = nodeXml.getAttribute('tooltip');

        // BACKGROUDN DEL VIEW
        this.background = nodeXml.getAttribute(LayoutInflater.ATTR_BACKGROUND);
        this.onClickDefinition = nodeXml.getAttribute(LayoutInflater.ATTR_ON_CLICK);

        if (nodeXml.getAttribute(LayoutInflater.ATTR_MIN_HEIGHT) !== null)
            this.minHeigth = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_MIN_HEIGHT))||10;

        if (nodeXml.getAttribute(LayoutInflater.ATTR_MIN_WIDTH) !== null)
            this.minWidth = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_MIN_WIDTH))||10;
        if (nodeXml.getAttribute("cssClassList") !== null && nodeXml.getAttribute("cssClassList").length>0){
            // this.cssClassList = `${nodeXml.getAttribute("cssClassList")}`;
            this.cssClassList = `${this.cssClassList},${nodeXml.getAttribute("cssClassList")}`;
        }

        // AUDIO PARA EL CLICK
        if (nodeXml.getAttribute("audioClick") !== null)
            this.audioClick = new Audio(nodeXml.getAttribute("audioClick"));

        // AUDIO PARA ENCIMA DE CLICK
        if (nodeXml.getAttribute("audioAdove") !== null){
            this.audioAdove = new Audio(nodeXml.getAttribute("audioAdove"));
        }
    }

    async loadResources() {
        if(!this.elemDom) // Verificamos que el elemento este agregado a la vista y que exista
            return;
        if(this.background){
            // Se verifica que tipo de fondo
            if(this.background instanceof BaseBackground)
                this.backgroundPainter = this.background;
            else if(Resource.isImageNinePathResource(this.background)){ // Imagen de fondo de nine path
                // let imageInBase64 = Resource.loa
                this.backgroundPainter = new NinepathBackground(this,this.elemDom,this.background);
            } 
            else if(Resource.isImageResource(this.background) || Resource.isBase64Resource(this.background))
                this.backgroundPainter = new ImageBackground(this,this.elemDom,this.background);
            else if(Resource.isColorResource(this.background))
                this.backgroundPainter = new ColorBackground(this,this.elemDom,this.background);
            else
                throw new Exception(`No se pudo identificar el tipo de fondo [${this.background}]`);
        }else
            this.backgroundPainter = new EmplyBackground(this,this.elemDom);
            
        await this.backgroundPainter.load();

        // Tooltip de Vista
        if(this.tooltip)
            this.elemDom.setAttribute("title", this.tooltip);
        // Visibilidad
        switch (this.visibility) {
            case View.INVISIBLE:
                this.elemDom.style.visibility = 'hidden';
                break;
            case View.GONE:
                this.elemDom.style.visibility = 'hidden';
                break;
            default:
                this.elemDom.style.visibility = 'block';
                break;
        }

        // Cargando OnClick
        if (typeof this.onClickDefinition === 'string') {
            // Buscamos el nombre de metodo en el contexto
            var propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this.context));
            if(propertyNames.find(property=>property===this.onClickDefinition)){
                this.onClick = async function(){
                    // alert("Funcion asyncrona llamada correctamente");
                    Reflect.apply(Reflect.get(this.context,this.onClickDefinition), this.context,this);
                }
            }else
                throw new Exception(`No se pudo encontrar la funcion [${this.this.onClickDefinition}] dentro del contexto [${this.context.constructor.name}]`);
        }

        // OnClick
        if(this.onClick)
            this.elemDom.onclick=()=>{
                if(this.audioClick !== null)
                    this.audioClick.play();
                this.onClick(this);
            };
        // Sobre el componente
        if(this.audioAdove!==null){
            this.elemDom.onmouseenter=()=>{
                this.audioAdove.play();
            };
            // this.elemDom.onmouseout=()=>{
                // this.audioAdove.pause();
                // this.audioAdove.currentTime = 0;
            // };
        }
        // cssClassList
        if(this.cssClassList.length > 0){
            this.cssClassList.split(',').forEach(classNameStyle => this.elemDom.classList.add(classNameStyle));
        }

        // Background
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                this.elemDom.style.width = `${parseInt(this.width)}px`;
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                this.elemDom.style.height = `${parseInt(this.height)}px`;
        }
    }

    addCssClass(cssString){
        let array = this.cssClassList.split(',');
        array.push(cssString);
        this.cssClassList = array.join(',');
        if(this.elemDom)
            this.elemDom.classList.add(cssString);
    }

    removeCssClass(cssString){
        this.cssClassList = this.cssClassList.split(',').filter(classCss => classCss !== cssString).join(',');
        if(this.elemDom)
            this.elemDom.classList.remove(cssString);
    }

    async repaintSync() {
        await this.backgroundPainter.paint();
    }
    
    // this.parentView.elemDom.appendChild(this.elemDom);
    async onMeasureSync(maxWidth, maxHeigth) {
        if(!this.elemDom) return; // No realizada nada si no fué agregado a la vista


        // ************  ANCHO DE PANTALLA  ************
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = (maxWidth - this.margin.left - this.margin.right) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                var width = parseInt(this.width);
                width = Math.max(width,this.maxWidth);
                this.elemDom.style.width = width + 'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = (maxHeigth - this.margin.top - this.margin.bottom) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                var height = parseInt(this.height);
                height = Math.max(height,this.maxHeigth);
                this.elemDom.style.height = height + 'px';
                break;
        }

        await this.backgroundPainter.paint();
    }
}
// Class: src/view/TextView.js
class TextView extends View {
    constructor(context){
        super(context);
        this.text= null;
        this.textColor= null;
        this.textCssStyle = null;
        this.textSize = 12;

        this.elemText= null;
        this.elemIcon= null;
        this.drawableResource= null;
        this.gravityIcon= "none";
        this.singleLine= false;
        this.ellipsize= "none";
        this.imageResource = null;

        this.shadowColor = null;
        this.shadowDx = 0;
        this.shadowDy = 0;
        this.shadowRadius = 3;

    }

    //@Override
    parse(nodeXml){
        super.parse(nodeXml);
        
        this.text = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_TEXT);
        this.textColor = nodeXml.getAttribute("textColor");
        if (nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_LEFT) !== null) {
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_LEFT);
        }
        else if (nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_RIGHT) !== null) {
            this.gravityIcon = LayoutInflater.RIGHT;
            this.drawableResource =  nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_RIGHT);
        }
        else if (nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_TOP) !== null) {
            this.gravityIcon = LayoutInflater.TOP;
            this.drawableResource =  nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_TOP);
        }
        else if (nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_BOTTOM) !== null) {
            this.gravityIcon = LayoutInflater.BOTTOM;
            this.drawableResource = nodeXml.getAttribute(LayoutInflater.ATTR_DRAWABLE_BOTTOM);
        }
        else{
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = null;
        }
        this.singleLine = nodeXml.getAttribute("singleLine")==="true"?true:false;
        this.textStyle = nodeXml.getAttribute("textStyle");

        this.shadowColor = nodeXml.getAttribute("shadowColor");
        this.shadowDx = parseInt(nodeXml.getAttribute("shadowDx"))||this.shadowDx;
        this.shadowDy = parseInt(nodeXml.getAttribute("shadowDy"))||this.shadowDy;
        this.shadowRadius = parseInt(nodeXml.getAttribute("shadowRadius"))||this.shadowRadius;

        this.textSize = nodeXml.getAttribute("textSize")||this.textSize;
    }

    setSingleLine(single) {
        this.singleLine = single;
    }

    setTextColor(color) {
        this.textColor = color;
    }

    //@Override
    createDomElement () {
        super.createDomElement();

        // Texto
        this.elemText = document.createElement('span');
        this.elemText.style.paddingTop = '0px';
        this.elemText.style.paddingLeft = '0px';
        this.elemText.style.paddingBottom = '0px';
        this.elemText.style.paddingRight = '0px';
        this.elemText.style.wordWrap = 'break-word'; // Ajustar texto a contenido
        this.elemText.style.position = 'absolute';
        this.elemText.style.margin = "0px 0px 0px 0px";
        
        // Icono
        this.elemIcon = document.createElement('img');
        this.elemIcon.style.paddingTop = '0px';
        this.elemIcon.style.paddingLeft = '0px';
        this.elemIcon.style.paddingBottom = '0px';
        this.elemIcon.style.paddingRight = '0px';
        this.elemIcon.style.position = 'absolute';
        this.elemIcon.style.margin = "0px 0px 0px 0px";

        this.elemDom.appendChild(this.elemText);
        this.elemDom.appendChild(this.elemIcon);
        return this.elemDom;
    }
    // @Override
    async loadResources() {
        await super.loadResources();

        // Estableciendo valores de los atributos
        this.elemText.innerHTML = this.text;
        this.elemText.style.color = this.textColor;
        if (this.singleLine === true)
            this.elemText.style.whiteSpace = "nowrap";
        this.elemText.style.textOverflow = "ellipsis";
        switch (this.textStyle) {
            case "bold": this.elemText.style.fontWeight = 'bold'; break;
            case "italic": this.elemText.style.fontWeight = 'italic'; break;
            default: this.elemText.style.fontWeight = 'normal'; break;
        }
        if(this.textSize)
            this.elemText.style.fontSize = this.textSize;
        if(this.shadowColor)
            this.elemText.style.textShadow=`${this.shadowDx}px ${this.shadowDy}px ${this.shadowRadius}px ${this.shadowColor}`;
        
        // Cargando la imagen o icono te texto
        this.imageResource = null;
        if(this.drawableResource){
            this.imageResource = await Resource.loadImage(this.drawableResource);
            this.elemIcon.src = this.imageResource.src;
        }
    }

    async onMeasureSync(maxWidth, maxHeight) {
        const marginDrawable = this.elemIcon.clientWidth===0?0:4; // 4px
        switch(this.gravityIcon){
            case "left":
                this.elemIcon.style.left = (this.padding.left) + 'px';
                this.elemIcon.style.top = (this.padding.top) + 'px';

                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                this.elemText.style.left = (this.padding.left + this.elemIcon.clientWidth + marginDrawable) + 'px';
                this.elemText.style.top = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight)-this.elemText.clientHeight) + 'px';

                this.elemDom.style.width = (this.padding.left + (this.elemIcon.clientWidth>0?this.elemIcon.clientWidth+marginDrawable : 0) + this.elemText.clientWidth+this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight) +marginDrawable + this.padding.bottom) + 'px';
                break;
            case "right":
                this.elemText.style.left = (this.padding.left) + 'px';
                this.elemText.style.top = (this.padding.top + (this.elemIcon.clientHeight-this.elemText.clientHeight)) + 'px';

                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }
                this.elemIcon.style.left = (this.padding.left+this.elemText.clientWidth+marginDrawable) + 'px';
                this.elemText.style.top = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight)-this.elemText.clientHeight) + 'px';

                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + (this.elemIcon.clientWidth>0?this.elemIcon.clientWidth+marginDrawable : 0) + this.elemText.clientWidth + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + Math.max(this.elemText.clientHeight, this.elemIcon.clientHeight) + this.padding.bottom) + 'px';
                break;
            case "bottom":
                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                let maximoAncho = Math.max(this.elemText.clientWidth,this.elemIcon.clientWidth);

                this.elemText.style.left = (this.padding.left+maximoAncho/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = (this.padding.top) + 'px';

                this.elemIcon.style.left = (this.padding.left+maximoAncho/2 -this.elemIcon.clientWidth/2) + 'px';
                this.elemIcon.style.top = (this.padding.top+marginDrawable+this.elemText.clientHeight) + 'px';
                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + maximoAncho + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + this.elemText.clientHeight + marginDrawable + this.elemIcon.clientHeight + this.padding.bottom) + 'px';
                break;
            case "top":
                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                let maximoAnchoTop = Math.max(this.elemText.clientWidth,this.elemIcon.clientWidth);
                
                this.elemIcon.style.left = (this.padding.left+maximoAnchoTop/2 -this.elemIcon.clientWidth/2) + 'px';
                this.elemIcon.style.top = (this.padding.top) + 'px';

                this.elemText.style.left = (this.padding.left+maximoAnchoTop/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = (this.padding.top+marginDrawable+this.elemIcon.clientHeight) + 'px';
                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + maximoAnchoTop + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + this.elemText.clientHeight + marginDrawable + this.elemIcon.clientHeight + this.padding.bottom) + 'px';
                break;
            default:
                throw new Exception(`Tipo de alineación [${this.gravityIcon}] no soportada`);
        }
        await this.repaintSync();
    }

    async setDrawableLeftSync(drawable) {
        this.gravityIcon = LayoutInflater.LEFT;
        this.drawableLeft = drawable;
        let image = await Resource.loadImage(drawable);
        this.elemIcon.src = `data:image/png;base64,${image.toDataURL()}`;
    }

    async setDrawableTopSync(drawable) {
        this.gravityIcon = LayoutInflater.TOP;
        this.drawableTop = drawable;
        let image = await Resource.loadImage(drawable);
        this.elemIcon.src = `data:image/png;base64,${image.toDataURL()}`;
    }

    async setDrawableRightSync(drawable, onLoadedDrawable) {
        this.gravityIcon = LayoutInflater.RIGHT;
        this.drawableTop = drawable;
        let image = await Resource.loadImage(drawable);
        this.elemIcon.src = `data:image/png;base64,${image.toDataURL()}`;
    }

    async setTextSync(text) {
        this.text = text;
        this.loadResources();
    }

    getText() {
        return this.text;
    }
}
// Class: src/view/Button.js
class Button extends TextView{
    constructor(context){
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
        this.padding.left = this.padding.top = this.padding.right = this.padding.bottom = 4;
    }
};
// Class: src/view/LinkButton.js
class LinkButton extends Button{
    constructor(context){
        super(context);
    }

    //@Override
    createDomElement () {
        super.createDomElement();
        this.elemDom.classList.add("LinkButton");
        this.elemDom.style.border = "none"
        return this.elemDom;
    }
};
// Class: src/view/EditText.js
class EditText extends View{
    // ems: 20,
    // lines: 1,
    // maxEms: 80,
    // maxLines: 10,
    // hint: null,
    // maxLength: -1,
    // readonly: false,
    constructor (context) {
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.bottom = 4;
        this.ems = 20;
        this.lines = 3,
        this.maxEms = 80;
        this.maxLines = 10;
        this.hint = null;
        this.maxLength = -1;
        this.readonly = false;
        this.text = null;
        this.enabled = true;
    }

    // @Override
    parse(nodeXml) {
        super.parse(nodeXml);
        if (nodeXml.getAttribute("ems") !== null) {
            this.ems = parseInt(nodeXml.getAttribute("ems"));
        }
        if (nodeXml.getAttribute("lines") !== null) {
            this.lines = parseInt(nodeXml.getAttribute("lines"));
        }
        if (nodeXml.getAttribute("maxEms") !== null)
            this.maxEms = parseInt(nodeXml.getAttribute("maxEms"));
        if (nodeXml.getAttribute("maxLines") !== null)
            this.maxLines = parseInt(nodeXml.getAttribute("maxLines"));
        if (nodeXml.getAttribute("maxLines") !== null)
            this.maxLines = parseInt(nodeXml.getAttribute("maxLines"));
        this.hint = nodeXml.getAttribute("hint");
        if (nodeXml.getAttribute("maxlength") !== null)
            this.maxLength = parseInt(nodeXml.getAttribute("maxlength"));
        if (nodeXml.getAttribute("text") !== null)
            this.text = nodeXml.getAttribute("text");
        if (nodeXml.getAttribute("singleLine") === "true")
            this.lines = 1;
        if (nodeXml.getAttribute("enabled") === "false")
            this.enabled = false;
    }

    // @Override
    getTypeElement(){
        return 'TextArea';
    }
    getText() {
        return this.elemDom.value;
    }
    setText(txt) {
        this.elemDom.value = txt;
    }
    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }
    setError(msg) {
        this._super(msg);
        this.elemDom.focus();
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        //cols="5" rows="1"
        this.elemDom.cols = this.ems;
        this.elemDom.rows = this.lines;
        // this.elemDom.style.height = (this.elemDom.rows * 22) + 'px';
        if(this.lines === 1){
            this.elemDom.style.whiteSpace = "nowrap";
            this.elemDom.style.overflowX = "hidden";
        }
        this.elemDom.onkeydown = (e)=>{
            if (this.lines===1&& e.keyCode == 13 && !e.shiftKey){
                e.preventDefault();
                return false;
            }
            else
                return true;
        };
        if (this.hint !== null)
            this.elemDom.placeholder = this.hint;
        if (this.maxLength > 0)
            this.elemDom.setAttribute("maxlength", this.maxLength);
        this.elemDom.style.resize = 'none';
        this.elemDom.value = this.text;
        this.elemDom.disabled = !this.enabled;
        this.elemDom.style.paddingTop = '6px';
        this.elemDom.style.paddingLeft = '6px';
        this.elemDom.style.paddingBottom = '6px';
        this.elemDom.style.paddingRight = '6px';
    }

    getWidth() {
        return super.getWidth()+6*2;
    }

    getHeight() {
        return super.getHeight()+6*2;
    }
}
// Class: src/view/ImageView.js
class ImageView extends View{
    // src: null,
    // scaleType: LayoutInflater.FIT_XY,
    constructor(context){
        super(context);
        this.src = null;
        this.image = null;
        this.scaleType = LayoutInflater.FIT_XY;
    }

    // @Override
    getTypeElement(){
        return 'img';
    }

    // @Override
    parse(nodeXml) {
        super.parse(nodeXml);
        this.src = nodeXml.getAttribute(LayoutInflater.ATTR_SRC);
        this.scaleType = nodeXml.getAttribute(LayoutInflater.ATTR_SCALE_TYPE)||LayoutInflater.FIT_XY;
        this.image = null;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.image = await Resource.loadImage(this.src);
        this.elemDom.src = this.image.src;
    }
    
    // @Override
    async onMeasureSync(maxWidth, maxHeight) {
        // await super.onMeasureSync(maxWidth,maxHeight);
        // Estableciendo dimensión de componente
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = Math.max(maxWidth-this.padding.left - this.padding.right,this.image.clientWidth + this.padding.left + this.padding.right);
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = Math.min(maxWidth-this.padding.left - this.padding.right,this.image.clientWidth + this.padding.left + this.padding.right);
                break;
            default: // tamaño establecido por el usuario
                let width = parseInt(this.width);
                this.elemDom.style.width = (width -this.padding.left - this.image.clientWidth - this.padding.right) + 'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = Math.max(maxHeight-this.padding.top - this.padding.bottom , this.image.clientHeight + this.padding.top + this.padding.bottom);
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = Math.min(maxHeight-this.padding.top - this.padding.bottom,this.image.clientHeight + this.padding.top + this.padding.bottom);
                break;
            default: // tamaño establecido por el usuario
                let height = parseInt(this.height);
                this.elemDom.style.height = (height -this.padding.top - this.image.clientHeight - this.padding.bottom) + 'px';
                break;
        }

        // Ajustando Imagen
        switch (this.scaleType){ //contain
            case LayoutInflater.FIT_CENTER: this.elemDom.style.objectFit = 'none'; break;
            case LayoutInflater.FIT_START: this.elemDom.style.objectFit = 'cover'; break;
            case LayoutInflater.FIT_CENTER_CROP: this.elemDom.style.objectFit = 'scale-down'; break;
            case LayoutInflater.FIT_CENTER_INSIDE: this.elemDom.style.objectFit = 'cover'; break;
            case LayoutInflater.FIT_END: this.elemDom.style.objectFit = 'cover'; break;
            case LayoutInflater.FIT_XY: this.elemDom.style.objectFit = 'fill'; break;
        }
    }

    async setImageResource(pathImage) {
        this.src = pathImage;
        this.image = await Resource.loadImage(this.src);
        this.elemDom.src = this.image.src;
    }
}
// Class: src/view/ImageButton.js

class ImageButton extends ImageView{
    constructor(context){
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.bottom = 4;
    }
};
// Class: src/layout/ViewGroup.js
class ViewGroup extends View{
    constructor(context){
        super(context);
        this.viewsChilds = new Array();
        //this.elemDom.style.overflow = 'hidden';
    }
    // @Override
    parse(nodeXml) {
        super.parse(nodeXml);
        //console.log("Nro hijos de "+nodeXml.tagName+" = "+nodeXml.children.length);
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = this.parseViewChild(nodeChild);
            child.parentView = this;
            this.viewsChilds.push(child);
        }
    }

    parseViewChild(nodeXml) {
        let child = LayoutInflater.inflate(this.context, nodeXml);
        return child;
    }

    findViewById(idView) {
        if (idView === null && idView === undefined)
            return null;
        for (let i = 0; i < this.viewsChilds.length; i++) {
            let view = this.viewsChilds[i];
            if (view.id === idView)
                return view;
            if (view instanceof ViewGroup) {
                var viewTemp = view.findViewById(idView);
                if (viewTemp !== null)
                    return viewTemp;
            }
        }
        return null;
    }

    findViewChildById(idView) {
        if (idView === null && idView === undefined)
            return null;
        for (let i = 0; i < this.viewsChilds.length; i++) {
            let view = this.viewsChilds[i];
            if (view.id === idView)
                return view;
        }
        return null;
    }

    async addViewSync(viewChild) {
        if (viewChild === null || viewChild === undefined)
            throw new Exception("El view que desea agregar es nulo o no esta definido");
        if(!viewChild instanceof View)
            throw new Exception("El objeto a agregar no es una instancia de View");
        viewChild.parentView = this;
        this.elemDom.appendChild(viewChild.createDomElement());
        this.viewsChilds.push(viewChild);
    }

    getViewVisibles() {
        // agrupamos los GONE's y los INVISIBLE's
        let vistos = new Array();
        for (let index = 0; index < this.viewsChilds.length; index++) {
            let view = this.viewsChilds[index];
            if (view.visibility === View.VISIBLE)
                vistos.push(view);
        }
        return vistos;
    }

    getChildCount() {
        return this.viewsChilds.length;
    }

    getChildAt(i) {
        return this.viewsChilds[i];
    }
    
    //@Override
    createDomElement() {
        super.createDomElement();
        for(let view of this.viewsChilds)
            this.elemDom.appendChild(view.createDomElement());
        return this.elemDom;
    }
    
    //@Override
    async loadResources(){
        await super.loadResources();
        for(let view of this.viewsChilds)
            await view.loadResources();
    }
    
    //@Override
    async onMeasureSync(maxWidth, maxHeight){
        await super.onMeasureSync(maxWidth, maxHeight);
        for(let view of this.viewsChilds)
            await view.onMeasureSync(maxWidth, maxHeight);
    }
    
    getContentWidth(maxWidth,viewChild){
        if(maxWidth <= 0)
            return 0;
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                return maxWidth - this.padding.left - this.padding.right - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
            case LayoutInflater.WRAP_CONTENT:
                return this.elemDom.clientWidth - this.padding.left - this.padding.right  - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
            default: // Tamanio especifico 
                let lenght = parseInt(this.width);
                return lenght - this.padding.left - this.padding.right - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
        }
    }

    getContentHeight(maxHeight,viewChild){
        if(maxHeight <= 0)
            return 0;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                return maxHeight - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
            case LayoutInflater.WRAP_CONTENT:
                return this.elemDom.clientWidth - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
            default: // Tamanio especifico 
                let lenght = parseInt(this.height);
                return lenght - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
        }
    }
}
// Class: src/layout/LinearLayout.js
class LinearLayout extends ViewGroup {
    constructor(context) {
        super(context);
        // this.orientation = LayoutInflater.LIN_ORIENTATION_HORIZONTAL;
    }

    //Override
    getTypeElement() {
        return "LinearLayout";
    }

    //Override
    parse(nodeXml) {
        if (nodeXml.getAttribute(LayoutInflater.ATTR_ORIENTATION) === LayoutInflater.LIN_ORIENTATION_VERTICAL)
            this.orientation = LayoutInflater.LIN_ORIENTATION_VERTICAL;
        else if (nodeXml.getAttribute(LayoutInflater.ATTR_ORIENTATION) === LayoutInflater.LIN_ORIENTATION_HORIZONTAL)
            this.orientation = LayoutInflater.LIN_ORIENTATION_HORIZONTAL;
        else
            throw new Exception(
                `La orientación para LinearLayout debe ser unicamente [horizontal o vertical]. Establesca el atributo [${LayoutInflater.ATTR_ORIENTATION}] para definir la orientación de la vista`);
        super.parse(nodeXml);
    }

    //Override
    parseViewChild(nodeXml) {
        let view = super.parseViewChild(nodeXml);
        view.layoutGravity = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY)||
            (this.orientation===LayoutInflater.LIN_ORIENTATION_VERTICAL?
                LayoutInflater.ATTR_LAYOUT_GRAVITY_LEFT:
                LayoutInflater.ATTR_LAYOUT_GRAVITY_TOP);

        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WEIGHT) !== null){
            let weight = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WEIGHT);
            var num = parseFloat(weight);
            if (isNaN(num) === true)
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_LAYOUT_WEIGHT}] del view [${this.constructor.name}] no es un número flotante [${weight}]`);

            if (!(num > 0.0 && num <= 1.0))
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_LAYOUT_WEIGHT}] es [${weight}] del view [${this.constructor.name}] no esta del rango válido entre [0.0 y 1.0]`);
            view.layoutWeight = num;
        }
        return view;
    }

    //@Override
    async onMeasureSync(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        if(visibles.length === 0)
            return;
        if (this.orientation === LayoutInflater.LIN_ORIENTATION_VERTICAL)
            await this.onMeasureVertical(visibles,maxWidth,maxHeight);
        else
            await this.onMeasureHorizontal(visibles,maxWidth,maxHeight);
        await this.repaintSync();
    }

    async onMeasureVertical(visibles, maxWidth, maxHeight) {
        let sumHeight = this.padding.top;
        let mayWidth = this.padding.left + this.padding.right;

        let sumHeigthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            if (view.layoutWeight !== undefined && view.layoutWeight !== null && view.layoutWeight > 0)
                arrayWeigh.push(view);
            else{
                await view.onMeasureSync(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumHeigthWrap += (view.margin.top + view.getHeight() + view.margin.bottom);
                if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right) > mayWidth)
                    mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
                sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
            }
        }

        // Estableciendo alto de los componentes que tiene weight
        if(this.width === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [layoutWeight] en uno de los hijos del [LinearLayout] pero el ancho se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let altoWeigth = this.getContentHeight(maxHeight) - sumHeigthWrap -this.padding.top- this.padding.bottom;
        for(let view of arrayWeigh){
            await view.onMeasureSync(this.getContentWidth(maxWidth,view) , altoWeigth*view.layoutWeight - view.margin.top - view.margin.bottom);
            if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right)>mayWidth)
                mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
            sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
        }

        // Estableciendo dimenciones del componente
        let maxWidthElement, maxHeightElement;
        sumHeight = sumHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = sumHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posTop = this.padding.top;
        for(let view of visibles){
            // Posición horizontal
            view.layoutGravity = view.layoutGravity || LayoutInflater.LEFT;
            let gravitys = view.layoutGravity.split("|");
            for(let gravity of gravitys){
                switch (gravity) {
                    case LayoutInflater.LEFT:
                        view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                        break;
                    case LayoutInflater.RIGHT:
                        view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                        break;
                    case LayoutInflater.CENTER_HORIZONTAL:
                        view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${gravity}]. Utilice unicamente [${LayoutInflater.LEFT},${LayoutInflater.RIGHT},${LayoutInflater.CENTER_HORIZONTAL}]`);
                }
            }

            // Posición vertical
            view.elemDom.style.top = (posTop + view.margin.top) + 'px';
            posTop = posTop + view.margin.top + view.getHeight() + view.margin.bottom;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    async onMeasureHorizontal(visibles, maxWidth, maxHeight) {
        
        let mayHeight = this.padding.top + this.padding.bottom;

        let sumWidthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        let temp = false;
        for(let view of visibles){
            if (view.layoutWeight !== undefined && view.layoutWeight !== null && view.layoutWeight > 0)
                arrayWeigh.push(view);
            else{
                await view.onMeasureSync(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumWidthWrap += (view.margin.left + view.getWidth() + view.margin.right);
                if ((this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                    mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            }
        }

        let sumWidth = this.padding.left + sumWidthWrap;

        // Estableciendo alto de los componentes que tiene weight
        if(this.height === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [layoutWeight] en uno de los hijos del [LinearLayout] pero el alto se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let anchoWeigth = this.getContentWidth(maxWidth) - sumWidthWrap -this.padding.left - this.padding.right;
        for(let view of arrayWeigh){
            await view.onMeasureSync(anchoWeigth*view.layoutWeight - view.margin.left - view.margin.right, this.getContentHeight(maxHeight,view));
            if ( (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            sumWidth+=(view.margin.left + view.getWidth() + view.margin.right);
        }

        // Verificando tamano de 
        let maxWidthElement, maxHeightElement;
        sumWidth = sumWidth + this.padding.right;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: 
                maxWidthElement = sumWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posLeft = this.padding.top;
        for(let view of visibles){
            // Posición vertical
            view.layoutGravity = view.layoutGravity || LayoutInflater.TOP;
            let gravitys = view.layoutGravity.split("|");
            for(let gravity of gravitys){
                switch (gravity) {
                    case LayoutInflater.TOP:
                        view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                        break;
                    case LayoutInflater.BOTTOM:
                        view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.top - this.padding.top) + 'px';
                        break;
                    case LayoutInflater.CENTER_VERTICAL:
                        view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${gravity}]. Utilice unicamente [${LayoutInflater.TOP},${LayoutInflater.BOTTOM},${LayoutInflater.CENTER_VERTICAL}]`);
                }
            }
            // Posición horizontal
            view.elemDom.style.left = (posLeft + view.margin.left) + 'px';
            posLeft = posLeft + view.margin.left + view.getWidth() + view.margin.right;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    setOrientation(orientation) {
        this.orientation = orientation;
    }
}
// Class: src/layout/FrameLayout.js
class FrameLayout extends ViewGroup {
    constructor(context) {
        super(context);
    }
    //Override
    getTypeElement() {
        return "FrameLayout";
    }
    //Override
    parseViewChild(nodeXml) {
        let view = super.parseViewChild(nodeXml);
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY) !== null)
            view.layoutGravity = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY);
        else
            view.layoutGravity = 'left|top';
        return view;
    }
    //@Override
    async onMeasureSync(maxWidth, maxHeight){        
        let visibles = this.getViewVisibles();
        //  Dibujamos todos los componentes
        let mayHeight = this.padding.top + this.padding.bottom;
        let mayWidth = this.padding.left + this.padding.right;
        for(let view of visibles){
            await view.onMeasureSync(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
            if((view.getWidth()+this.padding.left+this.padding.right) > mayWidth)
                mayWidth = (view.getWidth()+this.padding.left+this.padding.right);
            if((view.getHeight()+this.padding.top+this.padding.bottom) > mayHeight)
                mayHeight = (view.getHeight()+this.padding.top+this.padding.bottom);
        }
        let maxWidthElement,maxHeightElement;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }

        for(let view of visibles){
            let gravitys = view.layoutGravity.split("|");
            let leftAligned =false;
            for (let j = 0; j < gravitys.length; j++) {
                let gravity = gravitys[j];
                if (gravity === LayoutInflater.TOP)
                    view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                if (gravity === LayoutInflater.RIGHT){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                }
                if (gravity === LayoutInflater.LEFT){
                    leftAligned = true;
                    view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                }
                if (gravity === LayoutInflater.BOTTOM)
                    view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.bottom - this.padding.bottom) + 'px';
                if (gravity === LayoutInflater.CENTER_HORIZONTAL){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                }
                if (gravity === LayoutInflater.CENTER_VERTICAL)
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                if (gravity === LayoutInflater.CENTER){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                }
            }
            if(!leftAligned)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaintSync();
    }
}
// Class: src/layout/RelativeLayout.js
class RelativeLayout extends ViewGroup{
    constructor(context) {
        super(context);
    }

    //@Override
    parseViewChild(nodeXml) {
        var view = super.parseViewChild(nodeXml);
        view.alignParentTop = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_ALIGNPARENTTOP) === "true");
        view.alignParentRight = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_ALIGNPARENTRIGHT) === "true");
        view.alignParentBottom = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_ALIGNPARENTBOTTOM) === "true");
        view.alignParentLeft = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_ALIGNPARENTLEFT) === "true");
        
        view.centerHorizontal = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_CENTERHORIZONTAL) === "true");
        view.centerVertical = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_CENTERVERTICAL) === "true");
        view.centerInParent = (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_CENTERINPARENT) === "true");
        
        view.above = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_ABOVE);
        view.below = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_BELOW);
        view.toRightOf = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_TORIGHTOF);
        view.toLeftOf = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_TOLEFTOF);
        return view;
    }

    //@Override
    async onMeasureSync(maxWidth, maxHeight){
        await super.onMeasureSync(maxWidth, maxHeight);
        let visibles = this.getViewVisibles();
        var mayHeight = 0;
        var mayWidth = 0;
        // Dibujando todos los componentes sin posicionarlos para obtener sus dimensiones candidato
        for(let view of visibles){
            await view.onMeasureSync(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);
            let sumWidth = this.padding.left + view.margin.left + view.elemDom.clientWidth + view.margin.right + this.padding.right;
            if (sumWidth > mayWidth)
                mayWidth = sumWidth;
            let sumHeight = this.padding.top + view.margin.top + view.elemDom.clientHeight + view.margin.bottom + this.padding.bottom;
            if (sumHeight > mayHeight)
                mayHeight = sumHeight;
        }

        // Iteramos nuevamente para posicionar los elementos a partir de su dimesion y respecto a sus referencias
        for(let view of visibles){
            await view.onMeasureSync(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);

            // Posicionamos la vista segun el layout
            if (view.alignParentTop === true)
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.alignParentRight === true)
                view.elemDom.style.left = (this.elemDom.clientWidth - view.elemDom.clientWidth - view.margin.right - this.padding.right) + 'px';
            if (view.alignParentLeft === true)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            if (view.alignParentBottom === true)
                view.elemDom.style.top = (this.elemDom.clientHeight - view.elemDom.clientHeight - view.margin.bottom - this.padding.bottom) + 'px';

            if (view.centerHorizontal === true)
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
            if (view.centerVertical === true)
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            if (view.centerInParent === true) {
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            }

            // Ubicación respecto a otros elementos
            // ATTR_LAYOUT_ABOVE:"layout_above",//id
            if (view.above) {
                var viewAbove = this.findViewChildById(view.above);
                if (!viewAbove)
                    throw new Exception(`No se encuentra el view hijo con id [${view.above}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewAbove.elemDom.style.top) - viewAbove.margin.top - view.elemDom.clientHeight - view.margin.bottom) + 'px';
            }
            // ATTR_LAYOUT_BELOW:"layout_below",//id
            if (view.below) {
                var viewBelow = this.findViewChildById(view.below);
                if (!viewBelow)
                    throw new Exception(`No se encuentra el view hijo con id [${view.below}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewBelow.elemDom.style.top) + viewBelow.elemDom.clientHeight + viewBelow.margin.bottom + view.margin.top) + 'px';
            }
            // ATTR_LAYOUT_TORIGHTOF:"layout_toRightOf",//id
            if (view.toLeftOf) {
                var viewToLeft = this.findViewChildById(view.toLeftOf);
                if (!viewToLeft)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toLeftOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                if (view.alignParentLeft === true) {
                    await view.onMeasureSync(
                        parseInt(viewToLeft.elemDom.style.left) - view.margin.left - view.margin.right,
                        this.elemDom.clientHeight - this.padding.top - this.padding.bottom);
                        // Posiblemente pintar de nuevo la vista de fondo
                }
                else if (view.toRightOf !== null) {
                    console.log("Entrando por aquiiiiiaaaaaaaaaaaaaaaaaai. Pendiente");
                }
                else {
                    view.elemDom.style.left = (parseInt(viewToLeft.elemDom.style.left) - view.elemDom.clientWidth - view.margin.right) + 'px';
                }
            }
            // ATTR_LAYOUT_TOLEFTOF:"layout_toLeftOf",//id
            if (view.toRightOf) {
                var viewToRight = this.findViewById(view.toRightOf);
                if (viewToRight === null)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toRightOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);

                view.elemDom.style.left = (
                    parseInt(viewToRight.elemDom.style.left)
                    + viewToRight.margin.left
                    + viewToRight.elemDom.clientWidth
                    + viewToRight.margin.right
                    + view.margin.left) + 'px';
            }

            // verificando si tiene position top
            if (view.elemDom.style.top === "")
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.elemDom.style.left === "")
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            var sum = parseInt(view.elemDom.style.top) + view.getHeight() + this.padding.bottom + view.margin.bottom;
            if (sum > mayHeight)
                mayHeight = sum;
            sum = parseInt(view.elemDom.style.left) + view.getWidth() + this.padding.right + view.margin.right;
            if (sum > mayWidth)
                mayWidth = sum;
        }
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = `${mayHeight}px`;
                await this.repaintSync();
                break;
            default: break;
        }
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = `${mayWidth}px`;
                await this.repaintSync();
                break;
            default: break;
        }
    }
};
// Class: src/layout/GridLayout.js
class GridLayout extends ViewGroup {
    constructor(context) {
        super(context);
        this.colums =2;
        this.horizontalSpace = 0;
        this.verticalSpace = 0;
        this.minWidthView = 50;
        this.minHeightView = 20;
    }

    //@Override
    parse(nodeXml) {
        super.parse(nodeXml);
        if (this.width === LayoutInflater.WRAP_CONTENT)
            throw new Exception(`No se permite el ancho dinamico de tipo [${LayoutInflater.WRAP_CONTENT}] para el atributo [layout_width] de la vista [GridLayout]`);

        if (nodeXml.getAttribute("colums"))
            this.colums = parseInt(nodeXml.getAttribute("colums"));
        if (nodeXml.getAttribute("horizontalSpace"))
            this.horizontalSpace = parseInt(nodeXml.getAttribute("horizontalSpace"));
        if (nodeXml.getAttribute("verticalSpace"))
            this.verticalSpace = parseInt(nodeXml.getAttribute("verticalSpace"));
        if (nodeXml.getAttribute("minWidthView"))
            this.minWidthView = parseInt(nodeXml.getAttribute("minWidthView"));
        if (nodeXml.getAttribute("minHeightView"))
            this.minHeightView = parseInt(nodeXml.getAttribute("minHeightView"));
    }

    //@Override
    parseViewChild(nodeXml) {
        let view = super.parseViewChild(nodeXml);
        // if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WIDTH) === LayoutInflater.MATCH_PARENT)
        //     throw `No puede establecer un ancho [${LayoutInflater.ATTR_LAYOUT_WIDTH}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_HEIGHT) === LayoutInflater.MATCH_PARENT)
            throw `No puede establecer un alto [${LayoutInflater.ATTR_LAYOUT_HEIGHT}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        return view;
    }

    //@Override
    async onMeasureSync(maxWidth, maxHeigth){
        let visibles = this.getViewVisibles();
        let maxAnchoView = this.getContentWidth(maxWidth) / this.colums;

        let y = this.padding.top , x;
        let index = 0;
        let mayHeight = 0;

        while(index < visibles.length){
            x = this.padding.left;
            mayHeight = 0;
            for(let j=1; j <=this.colums && index < visibles.length; j++) {
                let view = visibles[index];
                await view.onMeasureSync(maxAnchoView , maxHeigth);
                view.elemDom.style.top  = `${y}px`;
                view.elemDom.style.left  = `${x}px`;
                x+=maxAnchoView;
                console.log("view.getHeight()",view.getHeight());
                if(view.getHeight()>mayHeight)
                    mayHeight = view.getHeight();
                index++;
            }
            console.log("MAY HEIGHT",mayHeight);
            y=y+ mayHeight+this.verticalSpace;
        }

        let maxWidthElement, maxHeightElement;
        y= y + mayHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = y; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            // case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break; // Este caso no se presentara
            default: maxWidthElement = parseFloat(this.width);
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaintSync();
    }
}
// Class: src/page/Page.js
class Page extends Context{
    // viewRoot: null,
    // viewListener: null,
    // urlView: null,
    // history: true,
    // fullScreem: false,
    // previusPage: null,
    // REQUEST_OK: 121,
    // REQUEST_CANCELED: 123,
    // resultCode: this.REQUEST_CANCELED,
    // resultData: null,
    // requestCode: -1,
    // loaded: false,

    constructor(){
        super();
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup) {
            return this.viewRoot.findViewById(idView);
        }
        else
            throw new Exception("El contenidor principal para la pagina no es heredado de ViewGroup");
    }

    setContentView(objView) {
        if (objView instanceof View)
            this.viewRoot = objView;
        else if(typeof objView==='string')
            this.urlView = objView;
        else{
            throw "La vista debe ser una instancia de View o una url de un archivo XML"
        }
    }

    startLoaded(){
        this.viewRoot.elemDom.style.visibility = 'hidden';
        this.viewRoot.elemDom.style.opacity = 0;
    }

    loadedFinized(){
        this.viewRoot.elemDom.style.transition = "opacity 5s ease-in-out";
        this.viewRoot.elemDom.style.opacity = 1;
        this.viewRoot.elemDom.style.visibility = 'visible';
    }

    async onCreate() { }
    async onStart() { }
    async onDestroy() { }
    async onPause() { }
    async onResume() { }

    setNoHistory(history) {
        this.history = !history;
    }

    async startPage(intent) {
        if (intent === undefined || intent === null)
            throw new Exception("El intent es nulo o no esta definido");
        let tree = Store.get('TREE');
        let navigationList = await PageManager.getArrayNavegation();
        console.log("TREE",tree);
        console.log("Pagina",this.constructor.name);
        console.log("PageNavigation",navigationList);

        window.location.href = `${window.location.href}/${intent.pageName}`;
        if(navigationList.pageNames.length === 0 ){
            alert("Error pagina no registrada");
            return;
        }
        if(this.constructor.name !== navigationList.pageNames[0]){
            alert("La pagina raiz no es la misma que la pagina actual");
            return;
        }
        
        // Cargando la pagina
        let newPage = await PageManager.startPageFromIntent(intent);
        
        // Guardando en el historial la navegación de la nueva pagina

        let currentPageConfig = tree.ROOT;
        let index = 0;
        // let pageName = navigationList.listPages[index];
        console.log("Navigation list ",navigationList);
        while(index < navigationList.pageNames.length){
            console.log("Compare",currentPageConfig.pageName,navigationList.pageNames[index]);
            if(currentPageConfig.pageName === navigationList.pageNames[index]){
                if(index + 1 < navigationList.pageNames.length ){
                    // Obtenemos el nombre de la pagina siguiente
                    let pageNameNext = navigationList.pageNames[index+1];
                    // Verificamos si la siguiente pagina existe en arbol de navegacion
                    if(currentPageConfig.navigation[pageNameNext]){ // Existe la pagina en el arbol?
                        currentPageConfig = currentPageConfig.navigation[pageNameNext];
                        index++;
                        continue;
                    }
                    else{
                        alert("No se pudo encontrar la pagina: "+pageNameNext);
                        return;
                    }
                }
                else // Se encontro la ultima raiz del arbol que corresponde a la pagina actual
                    break;
            }
            else{
                alert("Errorrrrrrrrrrrrrr: "+this.constructor.name+" INDEX = "+index);
                return;
            }
        }
        currentPageConfig.navigation[intent.pageName]= {
            extras: {},
            navigation: {},
            pageName: intent.pageName
        };
        Store.set('TREE',tree);
        console.log("NUEVO ARBOL",tree);
        console.log("NUEVO ARBOL GUARDADO",Store.get('TREE'));
    }

    setTitle(title) {
        document.title = title;
    }

    finish() {
        PageManager.finishPage(this);
        if (this.previusPage !== null) {
            if (this.requestCode > 0)
                this.previusPage.onPageResult(this.requestCode, this.resultCode, this.resultData);
        }
    }

    startPageForResult(intent, requestCode) {
        this.requestCode = requestCode;
        this.startPage(intent);
    }

    async onPageResult(requestCode, resultCode, intent) { }
}
// Class: src/page/animation/SpinnerAnimation.js
class SpinnerAnimation {
    constructor(propProgress){
        if(propProgress)
            this.propProgress = propProgress;
        else{
            this.propProgress = {
                left: (PageManager.getWindowsDimension().width / 2 - 150 / 2),
                top: (PageManager.getWindowsDimension().height / 2 - 150 / 2),
                width: 150, 
                height: 150, 
                showBackground: true
            };
        }
        this.elemLoader = null;
        this.elemImgLoader= null;
    }

    show(){
        // Creamos el loader para la pagina
        if(this.propProgress.showBackground===true){
            this.elemLoader = document.createElement('div');
            this.elemLoader.style.margin = '0px';
            this.elemLoader.style.width = '100%';
            this.elemLoader.style.height = '100%';
            this.elemLoader.style.position = 'absolute';
            this.elemLoader.style.backgroundColor = "rgba(1, 11,20, 0.5)";
        }

        this.elemImgLoader = document.createElement('div');
        this.elemImgLoader.style.width = this.propProgress.width + 'px';
        this.elemImgLoader.style.height = this.propProgress.height + 'px';
        this.elemImgLoader.style.position = 'absolute';
        this.elemImgLoader.style.background = '#05112B';
        this.elemImgLoader.style.top = this.propProgress.top + 'px';
        this.elemImgLoader.style.left = this.propProgress.left + 'px';

        var min = Math.min(this.propProgress.width, this.propProgress.height);
        // propProgress.width = min;
        // propProgress.height = min;

        var imgLoader = document.createElement('canvas');
        var radiusBack = this.propProgress.width / 8;

        imgLoader.setAttribute("width", this.propProgress.width - radiusBack * 2);
        imgLoader.setAttribute("height", this.propProgress.height - radiusBack * 2);

        imgLoader.style.position = 'absolute';
        imgLoader.style.top = radiusBack + 'px';
        imgLoader.style.left = radiusBack + 'px';
        var ctx = imgLoader.getContext("2d");

        // Pintando spinner
        var lines = 13;
        var radius = imgLoader.width / 10;
        var rotation = radius;
        ctx.save();

        this.elemImgLoader.style.borderRadius = (radiusBack) + 'px';

        ctx.translate(imgLoader.width / 2, imgLoader.height / 2);
        ctx.rotate(Math.PI * 2 * rotation);
        for (var i = 0; i < lines; i++) {
            ctx.beginPath();
            ctx.rotate(Math.PI * 2 / lines);
            ctx.fillStyle = "rgba(250,254,255," + (1 - i / lines) + ")";
            ctx.arc(imgLoader.width / 2 - radius, 0, radius, 0, 2 * Math.PI, false);
            ctx.fill();
            radius = radius - radius / (lines - 1);
            if (radius < 1)
                break;
        }
        ctx.restore();

        if (this.propProgress.showBackground === true)
            document.body.appendChild(this.elemLoader);
        imgLoader.style.left = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
        this.elemImgLoader.appendChild(imgLoader);
        document.body.appendChild(this.elemImgLoader);
        imgLoader.className = "rotate";
    }

    hide(){
        if (this.propProgress.showBackground === true)
            this.elemLoader.parentNode.removeChild(this.elemLoader);
        //document.body.removeChild(elemLoader);
        this.elemImgLoader.parentNode.removeChild(this.elemImgLoader);
    }
}