// Class: src/core/lang/Exception.js
class Exception extends Error{
    // message = null
    constructor(message){
        super(message);
        this.message = message;
    }

    toString(){
        return this.message;
    }
};
// Class: src/core/lang/Runnable.js
class Runnable {
    constructor(methodRun) {
        this.run = methodRun;
    }

    async run(){
        
    }
}
// Class: src/core/lang/Thread.js
class Thread {
    constructor(runnableObject) {
        this.runnableObject = runnableObject;
        this.promise = null;
    }

    start(){
        var this_ = this;
        (async () => {
            this_.promise = this_.runnableObject.run();
            console.log("PROMOO",this_.promise);
        })();
    }

    interrupt(){
        if(this.promise)
            this.promise.reject("Hilo interrumpido");
    }

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static async sleep(miliseconds) {
        return new Promise(resolve => {
            setTimeout(resolve, miliseconds);
        });
    }
}
// Class: src/core/lang/Timer.js
class Timer {
    constructor(runnableObject,period) {
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
    }

    schedule(runnableObject,period){
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
        this.start();
    }

    start(){
        if(this.intervalId)
            throw new Error(`El Timer ya se encuentra en ejecución.`);
        var this_ = this;
        this.intervalId = setInterval(function(){
            this_.runnableObject.run();
        }, this.period);
    }

    stop(){
        if(this.intervalId)
            clearInterval(this.intervalId);
        this.intervalId = null;
    }
}
// Class: src/core/lang/Store.js
class Store {
    static get(keyName,defaultValue){
        if(!Store.containsKey(keyName))
            Store.set(keyName,defaultValue);
        Store.checkIfExists(keyName);
        let data = JSON.parse(sessionStorage.getItem(keyName));
        if(data.type)
            return data.value;
        return data;
    }

    static set(key,value){
        sessionStorage.setItem(key,JSON.stringify({
            type: typeof value,
            value
        }));
    }

    static checkIfExists(keyName){
        if(!Store.containsKey(keyName))
            throw new Exception(`No existe el atributo [${keyName}]`);
    }

    static containsKey(keyName){
        return (sessionStorage.getItem(keyName))?true:false;
    }
}
// Class: src/util/FileChooser.js
class FileChooser{
    static async showSelectFile(types) {
        return await new Promise(function (resolve, reject) {
            var domoInput = document.createElement("input");
            domoInput.setAttribute("type", "file");
            domoInput.style.visibility = "hidden";
            domoInput.accept = types;

            document.body.appendChild(domoInput);
            domoInput.click();
            domoInput.onchange = function () {
                var reader = new FileReader();
                reader.onload = function (evt) {
                    //                    var parser = new DOMParser();
                    var contents = evt.target.result;
                    // El contenido se encuentra en Base64
                    // application/octet-stream;base64,UEsDBBQAAAgIAEe8.....
                    let posBase = contents.indexOf(',');
                    contents = posBase === -1 ? contents : contents.substr(posBase + 1);
                    //                    var doc = parser.parseFromString(contents, "application/xml");
                    domoInput.remove(); 
                    let fileNameSelected = domoInput.files[0].name;
                    resolve({
                        fileName: fileNameSelected,
                        fileExt: fileNameSelected.substring(fileNameSelected.lastIndexOf('.')+1),
                        dataInBase64: contents,
                        size: domoInput.files[0].size,
                        lastModified: domoInput.files[0].lastModified
                    });
                    //                    cbSelected(doc.documentElement);
                };
                reader.onerror = function (error) {
                    domoInput.remove();
                    reject(error);
                },
                    //                reader.readAsBinaryString(domoInput.files[0],"UTF-8");
                reader.readAsDataURL(domoInput.files[0]);
            };
        });
    }

    static async showSaveFile(urlFile){
        let a = document.createElement("a");
        a.style = "display: none";
        document.body.appendChild(a);
        a.href = urlFile;
        // a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(urlFile);
        a.remove();
    }
};
// Class: src/core/net/DefaultHttpClient.js
class DefaultHttpClient {
    constructor() {
    }

    async execute(httpRequest){
        return await httpRequest.send();
    }
}
// Class: src/core/net/HttpRequest.js
class HttpRequest {
    // this.url
    // params
    // data
    // xmlhttp
    constructor(url) {
        this.url = url;
        this.params = new Array();
        if (window.XMLHttpRequest)
            this.xmlhttp = new XMLHttpRequest();
        else
            this.xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }

    setEntity(d) {
        this.data = d;
    }

    getMethod() {
        return null;
    }
    // setUrl(url) {
    //     this.url = url;
    // }
    addParam(name, value) {
        this.params[name] = value;
    }

    async send() {
        return await new Promise((resolve, reject) => {
            let url = this.url;
            if (this.params.length > 0) {
                if(url.indexOf('?')===-1)
                    url = url + '?';
                for (let elem in this.params) {
                    url = (url + (elem + '=' + this.params[elem]) + "&&");
                }
                url = url.substring(0, url.length - 2);
            }
            this.xmlhttp.open(this.getMethod(), url, true);
            this.xmlhttp.setRequestHeader('Access-Control-Allow-Origin', '*');
            this.xmlhttp.setRequestHeader('Content-Type', 'application/json');
            if(this.data)
                this.xmlhttp.send(JSON.stringify(this.data));
            else
                this.xmlhttp.send();
            this.xmlhttp.onreadystatechange = ()=>{
                if (this.xmlhttp.readyState === XMLHttpRequest.DONE){
                    if(this.xmlhttp.status === 200 || this.xmlhttp.status === 204 ){
                        let httpResonse = new HttpResponse(this.xmlhttp);
                        resolve(httpResonse);
                    }
                }   
            };
        });
    }

    abort() {
        this.xmlhttp.abort();
        this.xmlhttp = null;
    }
}
// Class: src/core/net/HttpResponse.js
class HttpResponse {
    constructor(xmlhttp) {
        this.xmlhttp = xmlhttp;
    }

    getJson() {
        return JSON.parse(this.xmlhttp.responseText);
    }

    getRootElementXml() {
        return this.xmlhttp.responseXML.documentElement;
    }

    getText() {
        return this.xmlhttp.responseText;
    }
}
// Class: src/core/net/HttpGet.js
class HttpGet extends HttpRequest{
    // @Override
    getMethod(){
        return "GET"; 
    }
}
// Class: src/core/net/HttpPost.js
class HttpPost extends HttpRequest{
    // @Override
    getMethod(){
        return "POST"; 
    }
}
// Class: src/core/net/HttpPut.js
class HttpPut extends HttpRequest{
    // @Override
    getMethod(){
        return "PUT"; 
    }
};
// Class: src/core/net/HttpDelete.js
class HttpDelete extends HttpRequest{
    // @Override
    getMethod(){
        return "DELETE"; 
    }
}
// Class: src/core/Context.js
class Context{
    getLayoutInflater() {
        return new LayoutInflater();
    }
};
// Class: src/core/Resource.js
class Resource{
    static listThemes = new Array();

    static async loadTheme(urlTheme) {
        let rootXml = await this.loadLayoutSync(urlTheme);
        let styleObject = {};
        for (let index = 0; index < rootXml.children.length; index++){
            // <style name="PageTheme" parent="Page"></style>
            let styleChildNode = rootXml.children[index];
            let viewName = styleChildNode.getAttribute("view");
            styleObject[viewName] = {};

            for (let indexJ = 0; indexJ < styleChildNode.children.length; indexJ++){
                //<item name="textColor">#808080</item>
                let attrChildNode = styleChildNode.children[indexJ];
                let name = attrChildNode.getAttribute("name");
                let value = attrChildNode.textContent;
                if(value === "true" || value === "false")
                    styleObject[viewName][name] = value === "true";
                else
                    styleObject[viewName][name] = value;
            }
        }
        Store.set('theme', styleObject);
    }

    static getAttrOfTheme(themeName, name, value){
        if(value === undefined)
            value = null;
        let theme = Store.get('theme');
        if(theme[themeName]){
            if(theme[themeName][name]!== null && theme[themeName][name]!== undefined){
                return theme[themeName][name];
            }
            return value;
        }
        return value;
    }

    static async importJs(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].src && scripts[i].src.lastIndexOf(url)!==-1){
                    resolve(scripts[i]);
                    return;
                }
            }
            
            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async importCss(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("link");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].href && scripts[i].href.lastIndexOf(url) !== -1){
                    resolve(scripts[i]);
                    return;
                }
            }

            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('link');
            script.type = 'text/css';
            script.href = url;
            script.rel='stylesheet';
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async import(url){
        if(url.lastIndexOf(".js")!==-1)
            return await this.importJs(url);
        else if(url.lastIndexOf(".css")!==-1)
            return await this.importCss(url);
        else
            throw new Error(`Tipo de archivo [${url}] no soportado. utilice unicamente .js o .css`);
    }
    
    static async importAll(urls) {
        if (Array.isArray(urls) === false)
            throw "Lista de urls vacio para [loadAllScripts]";
        for(let url of urls){
            await Resource.importJs(url);
        }
    };
    
    static async loadLayoutSync(urlXmlLayout){
        let rootXml = await new Promise(function(resolve,reject){
            var xmlhttp;
            if (window.XMLHttpRequest)
                xmlhttp = new XMLHttpRequest();
            else
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4) {
                    if (xmlhttp.status === 200 ||xmlhttp.status === 0) { // Habilitado para archivos en local host (||xmlhttp.status === 0)
                        resolve(xmlhttp.responseXML.documentElement);
                    } else {
                        reject(xmlhttp.statusText);
                    }
                }
            };
            xmlhttp.open("GET", urlXmlLayout, true);
            xmlhttp.send(null);
        });
        return rootXml;
    }

    static async loadImage(urlOrTextBase64){
        if(!urlOrTextBase64)
            throw "No se envió la imagen para la carga";
        if(typeof urlOrTextBase64 !== 'string')
            throw "El parámetro para cargar la imagen no es de tipo texto";
        let imageProm = await new Promise(function(resolve,reject){
            var image = new Image();
            image.onload = function(){
                resolve(image);
            }
            if(Resource.isBase64Resource(urlOrTextBase64)){
                image.src = urlOrTextBase64;
            }
            else{
                image.src =urlOrTextBase64;
            }
        });
        return imageProm;
    }

    static isBase64Resource(urlOrTextBase64){
        return /data:image\/([a-zA-Z]*);base64,([^\"]*)/g.test(urlOrTextBase64);
    }

    static isImageNinePathResource(urlOrTextBase64){
        return /\.9\.(png|gif)/i.test(urlOrTextBase64);
    }

    static isImageResource(urlOrTextBase64){
        return /.(png|gif|jpg)/i.test(urlOrTextBase64);
    }

    static isColorResource(hexColorText){
        return /^#[0-9A-F]{6}$/i.test(hexColorText);
    }

    static async waitToLoadAllResources(){
        await new Promise(function(resolve){
            let callback = function(){
                resolve();
            };

            if (window.attachEvent){
                window.attachEvent('onload', callback);
            }
            else if (window.addEventListener){
                window.addEventListener('load', callback, false);
            }
            else{
                document.addEventListener('load', callback, false);
            }
        });
    }
}
// Class: src/core/PageManager.js
class PageManager {
    static getUrlBrouser(){
        let urlBrouser = window.location.href;
        return urlBrouser;
    }

    static getQueryParams(){
        let urlParams = new URLSearchParams(location.search);
        let params = {};
        for (let [key, value] of urlParams) {
            params[key] = value;
        }
        return params;
    }

    static setUrlBrouser(pageNames){
        window.location.href = `#/${pageNames.join('/')}`;
    }

    static getTreeNavigation(){
        let tree = Store.get('TREE',{
            ROOT: {
                extras:{},
                navigation: {},
                pageName: null
            }
        });
        return tree;
    }


    // pageNames
    static getArrayNavegation(){
        let urlBrouser = PageManager.getUrlBrouser();

        if(urlBrouser.lastIndexOf('#/') !== -1) {
            let listPages = urlBrouser.substring(urlBrouser.lastIndexOf('#/')+2);
            let posQuery = listPages.indexOf('?');
            if(posQuery != -1)
                listPages = listPages.substring(0,posQuery);
            return listPages.split('/');
        }
        return new Array();
    }

    static async startApp(manifestConfig){
        // Cargando tema
        await Resource.loadTheme(manifestConfig.theme);

        // Establecemos los valores correspondientes para los componentes HTML, BODY
        await PageManager.configApp();

        // Guardamos en sesion la configuración del objeto Manifesto
        Store.set('MANIFEST',manifestConfig);
        let navigationList = PageManager.getArrayNavegation();

        console.log("NAVIGATION: ",navigationList);
        
        if(navigationList.length > 0){ // Actualizar pagina establecida
            if(navigationList.length > 1){ // Existe una navegacion previa con varias paginas
                let resultNode = PageManager.getTreeNodeFromUrl();
                // Iniciamos la pagina con los datos guardados en la session
                let intent = new Intent(null, resultNode.currentPageNode.pageName);
                intent.setExtras(resultNode.currentPageNode.extras);
                let pageInstance = await PageManager.startPageFromIntent(intent);
                return;
            }else{ // Se desea cargar una pagina configurada en el manifest
                console.log("TTTTTTTT");
                let mainPageName = navigationList[0];
                let pageConfig = PageManager.findPageConfig(manifestConfig,mainPageName);

                // Agregamos como pagina raiz
                let treeNavigation = {
                    ROOT: {
                        extras: {},
                        navigation: {},
                        pageName: mainPageName
                    }
                }

                // Guardamos el nodo raiz en el arbol de navegación
                Store.set('TREE',treeNavigation);

                // Iniciamos la actividad principal
                let intent = new Intent(null, mainPageName);

                await PageManager.startPageFromIntent(intent);
                return;
            }
        }
        
        // Validando manifest
        let mainPageName = PageManager.findRootPageName(manifestConfig);

        // Colocando la pagina en la URL
        window.location.href = `#/${mainPageName}`;

        // Agregamos como pagina raiz
        let treeNavigation = {
            ROOT: {
                extras: {},
                navigation: {},
                pageName: mainPageName
            }
        }

        // Guardamos el nodo raiz en el arbol de navegación
        Store.set('TREE',treeNavigation);

        // Iniciamos la actividad principal
        let intent = new Intent(null, mainPageName);
        await PageManager.startPageFromIntent(intent);
    }

    static findRootPageName(manifestConfig){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.category=='ROOT');
        if(!pageConfig){
            throw new Exception(`No se encontro nin una pagina principal. Categorice la pagina agregando el atributo [category=='ROOT'] en el Manifest`);
        }
        let posBarra = pageConfig.name.lastIndexOf('/');
        let pageName = pageConfig.name.substring(posBarra+1,pageConfig.name.lastIndexOf('.js'));
        return pageName;
    }

    static findPageConfig(manifestConfig,pageName){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.name.lastIndexOf(`/${pageName}.js`) !== -1);
        if(!pageConfig){
            throw new Exception(`No se encontro la página [${pageName}] en la configuración del Manifest`);
        }
        return pageConfig;
    }

    static async configApp() {
        // Eliminamos margenes y padding del contenedor principal (body,html)
        document.body.style.paddingBottom = '0px';
        document.body.style.paddingTop = '0px';
        document.body.style.paddingLeft = '0px';
        document.body.style.paddingRight = '0px';
        document.body.style.margin = '0px';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
        document.body.style.position = 'absolute';

        // DESABILITAR ELEMENTOS NO SELECCIONABLES
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        //padding: 4px 20px;
        sheet.innerHTML = `html,body,div,span,img{
                                                    -webkit-user-select: none;
                                                    -khtml-user-select: none;
                                                    -moz-user-select: none;
                                                    -o-user-select: none;
                                                    -ms-user-select: none;
                                                    user-select: none;
                                                }`;
        document.body.appendChild(sheet);
        
        // MULTIDIMENSION
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        sheet.innerHTML = `@keyframes rotate{from {rotate:360deg;} to {rotate:0deg;}}
                           @-moz-keyframes rotate-record {0%   {-moz-transform: rotate(360deg);}100% {-moz-transform: rotate(0deg);}}
                           .rotate {-webkit-animation:rotate-record .8s infinite linear;-moz-animation:rotate-record .8s infinite linear;}`;

        document.body.appendChild(sheet);
    }

    static async startPageFromIntent(intent) {
        // Buscamos y verificamos si la pagina este presente en el Manifest
        let manifestConfig = Store.get('MANIFEST');
        // let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.className === intent.pageName);
        let pageConfig = PageManager.findPageConfig(manifestConfig,intent.pageName);

        // Importamos el script
        await Resource.import(pageConfig.name);

        // Instanciamos la Pagina
        var page = null;
        try {
            page = eval(`new ${intent.pageName}()`);
        }
        catch (o) {
            throw new Exception("No existe la pagina [" + intent.pageName + "]");
        }
        await PageManager.loadPage(intent.context, page, intent);
        return page;
    }

    // proProgress:{left:?,top:?,width,height,showBackground:true}
    static async loadPage(previusPage, page, intent) {
        page.previusPage = previusPage;
        // LLamamos el on create de la pagina
        await page.onCreate(intent);
        let pageAnimation = new SpinnerAnimation();
        pageAnimation.show();

        if (previusPage !== null) {
            // VER QUE SE REALIZARA PARA ESTE CASO
            
            // if (previusPage.history === false)
            //     this.removeContext(previusPage);
            // previusPage.onDestroy();
        }
        // Verificamos si tiene contenido la pagina
        if(!page.viewRoot && !page.urlView)
            throw new Exception(`La pagina [${page.constructor.name}] no tiene contenido definido. Asigne un contenido con page.setContentView`);
        if(page.urlView){ // La pagina cargara los elementos a partir de una URL
            let rootXml = await Resource.loadLayoutSync(page.urlView);
            page.viewRoot = await LayoutInflater.inflate(page,rootXml);
        }

        document.body.appendChild(page.viewRoot.elemDom);
        // page.startLoaded(); // Iniciando carga

        let navigator = this.getWindowsDimension();
        await page.viewRoot.loadResources();
        await page.viewRoot.onMeasure(navigator.width,navigator.height);
        page.loadedFinized(); // Carga finalizada
        pageAnimation.hide();

        // Guardamos la pagina actual en la URL
        document.title = page.constructor.name;

        // history.pushState({}, null, newUrlIS);
        // Mostrando todos los elementos
        await LayoutInflater.showAllViews(page.viewRoot);

        await page.onStart(intent);
    }

    static getTreeNodeFromUrl(){
        let tree = Store.get('TREE');
        if(tree === null)
            return null;
        let navigationList = PageManager.getArrayNavegation();

        // console.log("Navigation",navigationList);
        // if(this.constructor.name !== navigationList.pageNames[0]){
        //     alert("La pagina raiz no es la misma que la pagina actual");
        //     return;
        // }
        
        // Guardando en el historial la navegación de la nueva pagina
        let currentPageConfig = tree.ROOT;
        let parentPageNode = null;

        let index = 0;
        while(index < navigationList.length){
            if(currentPageConfig.pageName === navigationList[index]){
                if(index + 1 < navigationList.length ){
                    // Obtenemos el nombre de la pagina siguiente
                    let pageNameNext = navigationList[index+1];
                    // Verificamos si la siguiente pagina existe en arbol de navegacion
                    if(currentPageConfig.navigation[pageNameNext]){ // Existe la pagina en el arbol?
                        parentPageNode = currentPageConfig;
                        currentPageConfig = currentPageConfig.navigation[pageNameNext];
                        index++;
                        continue;
                    }
                    else{
                        alert("No se pudo encontrar la pagina: "+pageNameNext);
                        return;
                    }
                }
                else // Se encontro la ultima raiz del arbol que corresponde a la pagina actual
                    break;
            }
            else{
                alert("Errorrrrrrrrrrrrrr: "+pageName+" INDEX = "+index);
                return;
            }
        }
        return {
            parentNode: parentPageNode,
            currentPageNode: currentPageConfig,
            tree,
            navigationList
        };
    }

    static async finishPage(context) {
        // Eliminamos el componente
        let element = context.viewRoot.elemDom;
        element.parentNode.removeChild(element);

        // Eliminamos del historial

        await context.onDestroy();
    }

    static getWindowsDimension() {
        //        return {
        //                    width:document.body.clientWidth,
        //                    height:document.body.clientHeight
        //               };
        let dim = {
            width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
            height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
        };
        return dim;
    }
}
// Class: src/core/Intent.js
class Intent{
    // context
    // pageName
    constructor(context, pageName){
        this.extras = {};
        this.context= context;
        this.pageName = pageName;
    }

    setExtras(extras){
        this.extras = extras;
    }

    putExtra(name, value) {
        this.extras[name] = value;
    }
    getExtra(name) {
        return this.extras[name];
    }

    getExtras(){
        return this.extras;
    }
}
// Class: src/core/LayoutInflater.js
class LayoutInflater{
    // Atributos generales para los layouts
    static ATTR_WIDTH = "width";
    static ATTR_HEIGHT= "height";
    static ATTR_ID= "id";
    static ATTR_GRAVITY= "layoutGravity";

    static ATTR_GRAVITY_LEFT = "left";
    static ATTR_GRAVITY_RIGHT = "right";
    static ATTR_GRAVITY_TOP = "top";
    static ATTR_GRAVITY_BOTTOM = "bottom";
    static ATTR_GRAVITY_CENTER = "center";
    static ATTR_GRAVITY_CENTER_H = "center_horizontal";
    static ATTR_GRAVITY_CENTER_V = "center_vertical";

    static ATTR_MARGIN= "margin";
    static ATTR_MARGIN_TOP= "marginTop";
    static ATTR_MARGIN_LEFT= "marginLeft";
    static ATTR_MARGIN_RIGHT= "marginRight";
    static ATTR_MARGIN_BOTTOM= "marginBottom";

    static ATTR_PADDING= "padding";
    static ATTR_PADDING_TOP= "paddingTop";
    static ATTR_PADDING_LEFT= "paddingLeft";
    static ATTR_PADDING_RIGHT= "paddingRight";
    static ATTR_PADDING_BOTTOM= "paddingBottom";

    static ATTR_ON_CLICK= "onClick";
    static ATTR_BACKGROUND= "background";
    static ATTR_ORIENTATION= "orientation";
    // Utilizado solo en LinearLayout
    static ATTR_WEIGHT= "weight";

    // Atributos de RelativeLayout
    static ATTR_ALIGNPARENTLEFT= "alignParentLeft";// true;false
    static ATTR_ALIGNPARENTTOP= "alignParentTop";//true;false
    static ATTR_ALIGNPARENTRIGHT= "alignParentRight";//true;false
    static ATTR_ALIGNPARENTBOTTOM= "alignParentBottom";//true;false

    static ATTR_CENTERHORIZONTAL= "centerHorizontal";//true;false
    static ATTR_CENTERVERTICAL= "centerVertical";//true;false
    static ATTR_CENTERINPARENT= "centerInParent";//true;false

    static ATTR_ABOVE= "above";//id
    static ATTR_BELOW= "below";//id

    static ATTR_TORIGHTOF= "toRightOf";//id
    static ATTR_TOLEFTOF= "toLeftOf";//id

    static ATTR_MIN_WIDTH= "minWidth";
    static ATTR_MIN_HEIGHT= "minHeight";

    // TextView
    static ATTR_TEXT= "text";
    static ATTR_DRAWABLE_LEFT= "drawableLeft";
    static ATTR_DRAWABLE_TOP= "drawableTop";
    static ATTR_DRAWABLE_BOTTOM= "drawableBottom";
    static ATTR_DRAWABLE_RIGHT= "drawableRight";

    // ImageVIew
    static ATTR_SRC= "src";
    static ATTR_SCALE_TYPE= "scaleType";

    static FIT_XY= "fitXY";
    static FIT_START= "fitStart";
    static FIT_CENTER= "fitCenter";
    static FIT_CENTER_CROP= "fitCenterCrop";
    static FIT_CENTER_INSIDE= "fitCenterInside";
    static FIT_END= "fitEnd";
    //CENTER = "center"

    // LinearLayout
    static LIN_ORIENTATION_HORIZONTAL= "horizontal";
    static LIN_ORIENTATION_VERTICAL= "vertical";

    // vista
    static ATTR_VISIBILITY= "visibility";

    // Valores que pueden tomar los atributos
    static MATCH_PARENT= "match_parent";
    static WRAP_CONTENT= "wrap_content";
    static LEFT= "left";
    static RIGHT= "right";
    static BOTTOM= "bottom";
    static CENTER_HORIZONTAL= "center_horizontal";
    static CENTER_VERTICAL= "center_vertical";
    static CENTER= "center";
    static TOP= "top";

    static VISIBLE= "visible";
    static INVISIBLE= "invisible";
    static GONE= "gone";

    static REGEX_VARS = /\{\{([a-z_A-Z][a-zA-z_.\d]*)\}\}+/g;

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static async parse(context, firstElement) {
        var view = null;
        try {
            view = eval("new " + firstElement.tagName + "(context)");
        }
        catch (o) {
            throw new Exception("No existe la vista [" + firstElement.tagName + "]");
        }
        await view.parse(firstElement);
        return view;
    }

    static async inflate(context,xmlRoot) {
        let view = await this.parse(context, xmlRoot);
        return view;
    }

    static async showAllViews(rootView){
        if(rootView instanceof Container){
            rootView.elemDom.style.visibility = "visible";
            for( let view of rootView.viewsChilds){
                this.showAllViews(view);
            }
        }else if(rootView instanceof View){
            rootView.elemDom.style.visibility = "visible";
        }
    }
}
// Class: src/view/background/BaseBackground.js
class BaseBackground{
    constructor(view,domElement){
        this.view = view;
        this.domElement = domElement;
    }
    async load(){}
    async paint(){}
}
// Class: src/view/background/ColorBackground.js
class ColorBackground extends BaseBackground{
    constructor(view,domElement,color){
        super(view,domElement);
        this.color= color;
    }
    async load(){
        this.domElement.style.background = this.color;
    }
    async paint(){}
}
// Class: src/view/background/EmplyBackground.js
class EmplyBackground extends BaseBackground{
    constructor(view,domElement){
        super(view,domElement);
    }
    async load(){
        this.domElement.style.background='none';
        this.domElement.style.backgroundColor = 'transparent'; 
    }
    async paint(){}
}
// Class: src/view/background/ImageBackground.js
class ImageBackground extends BaseBackground{
    constructor(view,domElement,urlOrBase64Image){
        super(view,domElement);
        this.urlOrBase64Image = urlOrBase64Image;
    }

    async load(){
        if(Resource.isImageResource(this.urlOrBase64Image))
            this.domElement.style.background = `url('${this.urlOrBase64Image}')`;
        else
            this.domElement.style.background = `data:image/png;base64,${urlOrBase64Image}`;
        // auto|length|cover|contain|intial|inherit
        this.domElement.style.backgroundRepeat = 'no-repeat';
        this.domElement.style.backgroundOrigin = "content-box";
    }

    async paint(){
        this.domElement.style.backgroundSize = `${this.domElement.clientWidth}px ${this.domElement.clientHeight}px`;
    }
}
// Class: src/view/background/NinepathBackground.js
class NinepathBackground extends BaseBackground{
    constructor(view,domElement,imageNinePathBase64){
        super(view,domElement);
        // Padding
        this.padding = null;
        // Stores the pieces used to generate the horizontal layout
        this.horizontalPieces = null;
        // Stores the pieces used to generate the vertical layout
        this.verticalPieces = null;
        this.imageNinePathBase64 = imageNinePathBase64;
        // Stores the 9patch image
        this.bgImage = null;
    }

    getPieces(data, staticColor, repeatColor){
        let tempDS, tempPosition, tempWidth, tempColor, tempType;
        let tempArray = new Array();

        tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7];
        tempDS = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
        tempPosition = 1;

        for (var i = 4, n = data.length - 4; i < n; i += 4) {
            tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3];
            tempType = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
            if (tempDS !== tempType) {
                // box changed colors
                tempWidth = (i / 4) - tempPosition;
                tempArray.push(new Array(tempDS, tempPosition, tempWidth));

                tempDS = tempType;
                tempPosition = i / 4;
                tempWidth = 1;
            }
        }
        
        // push end
        tempWidth = (i / 4) - tempPosition;
        tempArray.push(new Array(tempDS, tempPosition, tempWidth));

        return tempArray;
    }

    getPadBorder(dataPad, width, height){
        var staticRight = dataPad[0] + ',' + dataPad[1] + ',' + dataPad[2] + ',' + dataPad[3];
        var pad = { top: 0, bottom: 0 };
    
        // Padding para la parte superior
        for (var i = 0; i < dataPad.length; i += 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.top++;
        }
        // padding inferior
        for (var i = dataPad.length - 4; i >= 0; i -= 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.bottom++;
        }
        return pad;
    }

    draw(){
        var dCtx, dCanvas, dWidth, dHeight;

        if (this.horizontalPieces === null)
            return;
    
        dWidth = this.domElement.clientWidth;
        dHeight = this.domElement.clientHeight;
        if(dWidth=== 0 && dHeight===0){
            console.warn("Dimensiones boton ",dWidth,dHeight);
            return;
        }
    
        if (dWidth === 0 || dHeight === 0)
            return;
    
        dCanvas = document.createElement('canvas');
        dCtx = dCanvas.getContext('2d');
    
        dCanvas.width = dWidth;
        dCanvas.height = dHeight;
    
        var fillWidth, fillHeight;
        // Determine the width for the static and dynamic pieces
        var tempStaticWidth = 0;
        var tempDynamicCount = 0;
    
        for (var i = 0, n = this.horizontalPieces.length; i < n; i++) {
            if (this.horizontalPieces[i][0] === 's')
                tempStaticWidth += this.horizontalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount;
    
        // Determine the height for the static and dynamic pieces
        var tempStaticHeight = 0;
        tempDynamicCount = 0;
        for (var i = 0, n = this.verticalPieces.length; i < n; i++) {
            if (this.verticalPieces[i][0] === 's')
                tempStaticHeight += this.verticalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillHeight = (dHeight - tempStaticHeight) / tempDynamicCount;
    
        // Loop through each of the vertical/horizontal pieces and draw on
        // the canvas
        for (var i = 0, m = this.verticalPieces.length; i < m; i++) {
            for (var j = 0, n = this.horizontalPieces.length; j < n; j++) {
                var tempFillWidth, tempFillHeight;
    
                tempFillWidth = (this.horizontalPieces[j][0] === 'd') ?
                    fillWidth : this.horizontalPieces[j][2];
                tempFillHeight = (this.verticalPieces[i][0] === 'd') ?
                    fillHeight : this.verticalPieces[i][2];
    
                // Stretching :
                if (this.verticalPieces[i][0] !== 'r') {
                    // Stretching is the same function for the static squares
                    // the only difference is the widths/heights are the same.
                    if (tempFillWidth >= 0 && tempFillHeight >= 0) {
                        dCtx.drawImage(
                            this.bgImage,
                            this.horizontalPieces[j][1], this.verticalPieces[i][1],
                            this.horizontalPieces[j][2], this.verticalPieces[i][2],
                            0, 0,
                            tempFillWidth, tempFillHeight);
                    }
                    else
                        break;
                }
                else {
                    var tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.horizontalPieces[j][2];
                    tempCanvas.height = this.verticalPieces[i][2];
    
                    var tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(
                        this.bgImage,
                        this.horizontalPieces[j][1], this.verticalPieces[i][1],
                        this.horizontalPieces[j][2], this.verticalPieces[i][2],
                        0, 0,
                        this.horizontalPieces[j][2], this.verticalPieces[i][2]);
    
                    var tempPattern = dCtx.createPattern(tempCanvas, 'repeat');
                    dCtx.fillStyle = tempPattern;
                    dCtx.fillRect(
                        0, 0,
                        tempFillWidth, tempFillHeight);
                }
    
                // Shift to next x position
                dCtx.translate(tempFillWidth, 0);
            }
    
            // shift back to 0 x and down to the next line
            dCtx.translate(-dWidth, (this.verticalPieces[i][0] === 's' ? this.verticalPieces[i][2] : fillHeight));
        }
    
        // store the canvas as the div's background
        var url = dCanvas.toDataURL("image/png");
        var tempIMG = new Image();
    
        var _this = this;
        tempIMG.onload = ()=>{
            this.domElement.style.background = `url(${url}) no-repeat`;
        };
        tempIMG.src = url;
    }

    // @Override
    async load(){
        // Limpiando fondo de boton
        this.view.elemDom.style.border = "none"

        // Obteniendo datos de la imagen ninepath.9
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // Cargamos la imagen 
        this.bgImage = await Resource.loadImage(this.imageNinePathBase64);
        this.domElement.style.background = 'none';
        this.domElement.style.backgroundRepeat = "no-repeat";

        // this.view.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        
        // Obteniendo padding
        // var tempCtx, tempCanvas;
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.bgImage.width;
        tempCanvas.height = this.bgImage.height;
        this.tempCtx = tempCanvas.getContext('2d');
        this.tempCtx.drawImage(this.bgImage, 0, 0);

        var dataPad = this.tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        this.padding.top = padRight.top;
        this.padding.bottom = padRight.bottom;
        dataPad = this.tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        this.padding.left = padBottom.top;
        this.padding.right = padBottom.bottom;

        this.view.padding= this.padding;
    }
    
    // @Override
    async paint(){
        // Create a temporary canvas to get the 9Patch index data.
        // var tempCtx, tempCanvas;
        // tempCanvas = document.createElement('canvas');
        // tempCanvas.width = this.bgImage.width;
        // tempCanvas.height = this.bgImage.height;
        // tempCtx = tempCanvas.getContext('2d');
        // tempCtx.drawImage(this.bgImage, 0, 0);

        // // Obteniendo el padding lateral derecho
        // var dataPad = tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        // var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        // this.padding.top = padRight.top;
        // this.padding.bottom = padRight.bottom;
        // dataPad = tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        // var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        // this.padding.left = padBottom.top;
        // this.padding.right = padBottom.bottom;

        // Loop over each  horizontal pixel and get piece
        var data = this.tempCtx.getImageData(0, 0, this.bgImage.width, 1).data;

        // Use the upper-left corner to get staticColor, use the upper-right corner
        // to get the repeatColor.
        var tempLength = data.length - 4;
        var staticColor = data[0] + ',' + data[1] + ',' + data[2] + ',' + data[3];
        var repeatColor = data[tempLength] + ',' + data[tempLength + 1] + ',' +
            data[tempLength + 2] + ',' + data[tempLength + 3];
        this.horizontalPieces = this.getPieces(data, staticColor, repeatColor);

        // Loop over each  horizontal pixel and get piece
        data = this.tempCtx.getImageData(0, 0, 1, this.bgImage.height).data;
        this.verticalPieces = this.getPieces(data, staticColor, repeatColor);

        // use this.horizontalPieces and this.verticalPieces to generate image
        this.draw();
    }
}
// Class: src/ux/animation/SpinnerAnimation.js
class SpinnerAnimation {
    constructor(propProgress){
        if(propProgress)
            this.propProgress = propProgress;
        else{
            this.propProgress = {
                left: (PageManager.getWindowsDimension().width / 2 - 150 / 2),
                top: (PageManager.getWindowsDimension().height / 2 - 150 / 2),
                size: 150,
                showBackground: true,
                backgroundRotation: true,
                parentElement: document.body
            };
        }
        // Creamos el loader para la pagina
        if(this.propProgress.showBackground===true){
            this.elemLoader = document.createElement('div');
            this.elemLoader.style.margin = '0px';
            this.elemLoader.style.width = '100%';
            this.elemLoader.style.height = '100%';
            this.elemLoader.style.position = 'absolute';
            this.elemLoader.style.backgroundColor = "rgba(1, 11,20, 0.5)";
        }

        this.elemImgLoader = document.createElement('div');
        this.elemImgLoader.style.width = this.propProgress.size + 'px';
        this.elemImgLoader.style.height = this.propProgress.size + 'px';
        this.elemImgLoader.style.position = 'absolute';
        this.elemImgLoader.style.top = this.propProgress.top + 'px';
        this.elemImgLoader.style.left = this.propProgress.left + 'px';
        let imgLoader = null;
        if(this.propProgress.backgroundRotation){
            let radiusBack = this.propProgress.size / 8;
            this.elemImgLoader.style.background = '#05112B';
            this.elemImgLoader.style.borderRadius = (radiusBack) + 'px';
            imgLoader = this.createCanvas(this.propProgress.size - radiusBack * 2);
            imgLoader.style.left = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
            imgLoader.style.top = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
        }
        else
            imgLoader = this.createCanvas(this.propProgress.size);
        if (this.propProgress.showBackground === true)
            document.body.appendChild(this.elemLoader);
        imgLoader.className = "rotate";
        this.elemImgLoader.appendChild(imgLoader);
    }

    getRootDomElement(){
        return this.elemImgLoader;
    }

    resize(size){
        this.propProgress.size = size;
        if(this.elemImgLoader.firstChild)
            this.elemImgLoader.removeChild(this.elemImgLoader.firstChild);

        let imgLoader = this.createCanvas(size);
        imgLoader.style.left = "0px";
        imgLoader.style.top = "0px";
        imgLoader.className = "rotate";
        this.elemImgLoader.appendChild(imgLoader);
    }

    createCanvas(size){
        let imgLoader = document.createElement('canvas');
        imgLoader.setAttribute("width", size);
        imgLoader.setAttribute("height", size);

        imgLoader.style.position = 'absolute';
        imgLoader.style.top = '0px';
        imgLoader.style.left = '0px';
        let ctx = imgLoader.getContext("2d");

        // Pintando spinner
        let lines = 13;
        let radius = imgLoader.width / 10;
        let rotation = radius;
        ctx.save();

        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI * 2 * rotation);
        for (let i = 0; i < lines; i++) {
            ctx.beginPath();
            ctx.rotate(Math.PI * 2 / lines);
            ctx.fillStyle = "rgba(250,254,255," + (1 - i / lines) + ")";
            ctx.arc(imgLoader.width / 2 - radius, 0, radius, 0, 2 * Math.PI, false);
            ctx.fill();
            radius = radius - radius / (lines - 1);
            if (radius < 1)
                break;
        }
        ctx.restore();
        return imgLoader;
    }

    show(){
        this.propProgress.parentElement.appendChild(this.elemImgLoader);
    }

    hide(){
        if (this.propProgress.showBackground === true)
            this.elemLoader.parentNode.removeChild(this.elemLoader);
        this.elemImgLoader.parentNode.removeChild(this.elemImgLoader);
    }
}
// Class: src/view/View.js
class View {
    static INVISIBLE = "INVISIBLE";
    static VISIBLE = "VISIBLE";
    static GONE = "GONE";

    constructor(context) {
        if (!context)
            throw new Exception("El contexto no esta en los parametros o es nulo");
        this.context = context;
        this.visibility = View.VISIBLE;
        this.margin = { top: 0, left: 0, right: 0, bottom: 0 };
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        this.parentView = null;
        this.maxWidth = Resource.getAttrOfTheme(this.constructor.name, 'maxWidth', 0);
        this.maxHeigth = Resource.getAttrOfTheme(this.constructor.name, 'maxHeigth', 0);
        this.width = Resource.getAttrOfTheme(this.constructor.name, 'width', LayoutInflater.WRAP_CONTENT);
        this.height = Resource.getAttrOfTheme(this.constructor.name, 'height', LayoutInflater.WRAP_CONTENT);
        this.id = Resource.getAttrOfTheme(this.constructor.name, 'id');
        this.background = Resource.getAttrOfTheme(this.constructor.name, 'background');
        this.cssClassList = Resource.getAttrOfTheme(this.constructor.name, 'cssClassList',this.constructor.name);
        this.onClick = null;
        this.onClickDefinition = null;
        this.tooltip = Resource.getAttrOfTheme(this.constructor.name, 'tooltip');
        this.layoutGravity = null;
        this.audioClick = Resource.getAttrOfTheme(this.constructor.name, 'audioClick');
        this.audioAdove = Resource.getAttrOfTheme(this.constructor.name, 'audioAdove');
        this.requiredInForm = false;
        this.requiredMessage = null;

        this.createHtmlElement();
        this.elemDom.style.visibility = "hidden";
    }

    getAllAttrs(){
        return Object.keys(this);
    }

    setVisibility(v) {
        this.visibility = v;
    }
    
    setToolTip(text) {
        this.tooltip = text;
    }

    setMinWidth(w) {
        this.minWidth = w;
    }
    getContext() {
        return this.context;
    }

    setMinHeight(h) {
        this.minHeigth = h;
    }

    findViewById(idView) {
        if (idView === null && idView === undefined)
            return null;
        if(this.id === idView)
            return this;
        return null;
    }

    createHtmlElemFromType(type) {
        let htmlElement = document.createElement(type);
        // Margenes por defector
        htmlElement.style.marginTop = '0px';
        htmlElement.style.marginLeft = '0px';
        htmlElement.style.marginBottom = '0px';
        htmlElement.style.marginRight = '0px';

        // Padding por defecto
        htmlElement.style.paddingTop = '0px';
        htmlElement.style.paddingLeft = '0px';
        htmlElement.style.paddingBottom = '0px';
        htmlElement.style.paddingRight = '0px';

        htmlElement.style.position = 'absolute';
        return htmlElement;
    }


    createHtmlElement() {
        this.elemDom = this.createHtmlElemFromType(this.getTypeElement());
        return this.elemDom;
    }

    getTypeElement() {
        return this.constructor.name;
    }

    setId(id) {
        this.id = id;
    }

    clone() {
        let copy = Object.assign({}, this);
        copy.elemDom = this.elemDom.cloneNode(true);
    }
    
    getWidth() {
        // return this.width;
        return this.elemDom? this.elemDom.clientWidth: 0;
    }

    getHeight() {
        return this.elemDom? this.elemDom.clientHeight: 0;
    }
    
    setMargin(margin) {
        if (!margin) return;
        let mg = parseInt(margin);
        this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = mg;
    }
    
    setMarginTop(margin) {
        if (!margin) return;
        this.margin.top = parseInt(margin);
    }

    setMarginLeft(margin) {
        if (!margin) return;
        this.margin.left = parseInt(margin);
    }
    setMarginRight(margin) {
        if (!margin) return;
        this.margin.right = parseInt(margin);
    }

    setMarginBottom(margin) {
        if (!margin) return;
        this.margin.bottom = parseInt(margin);
    }

    getBackground() {
        return this.background;
    }

    setBackground(background) {
        this.background = background;
    }

    setWidth(width) {
        this.width = width;
    }

    setHeight(height){
        this.height = height;
    }

    setLayoutGravity(layoutGravity) {
        this.layoutGravity = layoutGravity;
    }

    setOnClickListener(onCLick,contextParam) {
        this.onClick = null;
        this.onClickDefinition = onCLick;
        this.onClickContext = contextParam;
        if (typeof this.onClickDefinition === 'string') {
            // Buscamos el nombre de metodo en el contexto
            let propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this.context));
            if(propertyNames.find(property=>property===this.onClickDefinition)){
                this.onClick = async function(){
                    Reflect.apply(Reflect.get(this.context,this.onClickDefinition), this.context,[this]);
                }
            }else
                throw new Exception(`No se pudo encontrar la funcion [${this.onClickDefinition}] dentro del contexto [${this.context.constructor.name}]`);
        }
        else if (typeof this.onClickDefinition === 'function') {
            let funName = this.onClickDefinition.name;
            // Verificamos si la funcion se encuentra dentro de la vista
            let propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this));
            if(propertyNames.find(property=>property===funName)){
                this.onClick = async function(){
                    Reflect.apply(this.onClickDefinition, this,[this]);
                }
            }else{
                this.onClick = async function(){
                    Reflect.apply(this.onClickDefinition, this.onClickContext ||this.context,[this]);
                }
            }
        }
        else 
            throw new Exception(`El objeto [${onCLick}] no es valido para establecer el Listener de onClick`);

        // OnClick
        if(this.onClick){
            this.elemDom.onclick=()=>{
                if(this.audioClickMedia)
                    this.audioClickMedia.play();
                this.onClick(this);
            };
        }
    }

    async setMP(dr, ic, txt, tc) {
        var popup = new PopupWindow(this.getContext());
        let message = new TextView(popup);
        message.setText(txt);
        if (ic !== null)
            await message.setDrawableLeft(ic);
        message.setBackground(dr);
        message.setSingleLine(true);
        message.setTextColor(tc);

        popup.setView(this);
        popup.setContentView(message);
        popup.show();
        setTimeout(function(){
            popup.cancel();
        },3000);
        return popup;
    }

    async showAlertMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_alerta.9.png", "lib/imgs/ic_msg_alert.png", msg, "#653400");
    }

    async showConfirmMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_confirm.9.png", "lib/imgs/ic_msg_confirm.png", msg, "#346700");
    }

    async showErrorMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_error.9.png", "lib/imgs/ic_msg_error.png", msg, "#A90400");
    }

    async showInfoMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_info.9.png", "lib/imgs/ic_msg_info.png", msg, "#4C95E7");
    }

    getAttrFromNodeXml(nodeXml, attrName){
        let attrValue  = nodeXml.getAttribute(attrName);
        if(attrValue){
            attrValue = attrValue.replace(LayoutInflater.REGEX_VARS,(cmp,paramName)=>{
                if(paramName.indexOf('context.')!==-1)
                    return eval(`this.${paramName}`);
                else
                    return eval(paramName);
            });
        }
        return attrValue;
    }

    async setTheme(themeName){
        let theme = Store.get('theme');
        if(theme[themeName]){
            Object.entries(theme[themeName]).forEach(([key, value]) => {
                this[key] = value;
            });
        }
    }

    async parse(nodeXml) {
        // THEMA PARA LA VISTA
        if (this.getAttrFromNodeXml(nodeXml,"theme"))
            this.setTheme(this.getAttrFromNodeXml(nodeXml,"theme"));

        // VISIBILITY DEL VIEW
        this.visibility = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_VISIBILITY) || this.visibility;

        // MARGEN DEL COMPONENTE
        if(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN)!=null)
            this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN));
        if(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_BOTTOM)!=null)
            this.margin.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_BOTTOM));
        if(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_LEFT)!=null)
            this.margin.left = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_LEFT));
        if(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_RIGHT)!=null)
            this.margin.right = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_RIGHT));
        if(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_TOP)!=null)
            this.margin.top = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MARGIN_TOP));
        if(this.getAttrFromNodeXml(nodeXml,"paddingLeft"))
            this.padding.left = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingLeft"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingRight"))
            this.padding.right = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingRight"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingTop"))
            this.padding.top = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingTop"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingBottom"))
            this.padding.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingBottom"));
        let padding = this.getAttrFromNodeXml(nodeXml,"padding");
        if (padding !== null) {
            let pad = parseInt(padding);
            this.padding.top = this.padding.left = this.padding.right = this.padding.bottom = pad;
        }

        // ID DEL VIEW
        this.id = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ID) || this.id;

        // LAYOUT GRAVITY DEL VIEW
        this.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY) || this.layoutGravity;

        // WIDTH DEL VIEW
        this.width = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WIDTH) || this.width;
        // HEIGHT DEL VIEW
        this.height = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_HEIGHT) || this.height;

        this.tooltip = this.getAttrFromNodeXml(nodeXml,'tooltip') || this.tooltip;

        // BACKGROUDN DEL VIEW
        this.background = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_BACKGROUND) || this.background;
        this.onClickDefinition = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ON_CLICK) || this.onClickDefinition;

        this.minHeigth = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MIN_HEIGHT)) || this.minHeigth;
        this.minWidth = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MIN_WIDTH)) || this.minWidth;

        if (this.getAttrFromNodeXml(nodeXml,"cssClassList")){
            // this.cssClassList = `${nodeXml,"cssClassList")}`;
            this.cssClassList = `${this.cssClassList},${this.getAttrFromNodeXml(nodeXml,"cssClassList")}`;
        }

        // AUDIO PARA EL CLICK
        this.audioClick = this.getAttrFromNodeXml(nodeXml,"audioClick") || this.audioClick;
        this.audioAdove = this.getAttrFromNodeXml(nodeXml,"audioAdove") || this.audioAdove;
            
        this.requiredInForm = this.getAttrFromNodeXml(nodeXml,"requiredInForm") || false;
        this.requiredMessage = this.getAttrFromNodeXml(nodeXml,"requiredMessage");
    }

    async loadResources() {
        if(this.background){
            // Se verifica que tipo de fondo
            if(this.background instanceof BaseBackground)
                this.backgroundPainter = this.background;
            else if(Resource.isImageNinePathResource(this.background)){ // Imagen de fondo de nine path
                // let imageInBase64 = Resource.loa
                this.backgroundPainter = new NinepathBackground(this,this.elemDom,this.background);
            } 
            else if(Resource.isImageResource(this.background) || Resource.isBase64Resource(this.background))
                this.backgroundPainter = new ImageBackground(this,this.elemDom,this.background);
            else if(Resource.isColorResource(this.background) || this.background.indexOf("rgba(")!==-1)
                this.backgroundPainter = new ColorBackground(this,this.elemDom,this.background);
            else
                throw new Exception(`No se pudo identificar el tipo de fondo [${this.background}]`);
        }else
            this.backgroundPainter = new EmplyBackground(this,this.elemDom);

        await this.backgroundPainter.load();

        // Tooltip de Vista
        if(this.tooltip)
            this.elemDom.setAttribute("title", this.tooltip);
        // Visibilidad
        switch (this.visibility) {
            case View.INVISIBLE:
                this.elemDom.style.visibility = 'hidden';
                break;
            case View.GONE:
                this.elemDom.style.visibility = 'hidden';
                break;
            default:
                this.elemDom.style.visibility = 'block';
                break;
        }

        // Cargando OnClick
        if(this.onClickDefinition){
            this.setOnClickListener(this.onClickDefinition);
        }

        if(this.audioClick)
            this.audioClickMedia = new Audio(this.audioClick);
        if(this.audioAdove)
            this.audioAdoveMedia = new Audio(this.audioAdove);
        // Sobre el componente
        if(this.audioAdoveMedia){
            this.elemDom.onmouseenter=()=>{
                this.audioAdoveMedia.play();
            };
            // this.elemDom.onmouseout=()=>{
                // this.audioAdove.pause();
                // this.audioAdove.currentTime = 0;
            // };
        }
        // cssClassList
        if(this.cssClassList.length > 0){
            this.cssClassList.split(',').forEach(classNameStyle => this.elemDom.classList.add(classNameStyle));
        }

        // Background
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                this.elemDom.style.width = `${parseInt(this.width)}px`;
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                this.elemDom.style.height = `${parseInt(this.height)}px`;
        }
    }

    addCssClass(cssString){
        let array = this.cssClassList.split(',');
        array.push(cssString);
        this.cssClassList = array.join(',');
        if(this.elemDom)
            this.elemDom.classList.add(cssString);
    }

    removeCssClass(cssString){
        this.cssClassList = this.cssClassList.split(',').filter(classCss => classCss !== cssString).join(',');
        if(this.elemDom)
            this.elemDom.classList.remove(cssString);
    }

    async repaint() {
        if(this.backgroundPainter)
            await this.backgroundPainter.paint();
    }

    isSizeStatic(){
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT: break;
            default: return true;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT: break;
            default: return true;
        }
        return false;
    }

    async onReMeasure(){
        let viewRootStatic = this;
        while(viewRootStatic !== null){
            if(viewRootStatic.isSizeStatic())
                break;
            if(viewRootStatic.parentView === null)
                break;
            viewRootStatic = viewRootStatic.parentView;
        }
        await viewRootStatic.onMeasure(viewRootStatic.getWidth(),viewRootStatic.getHeight());
    }
    
    // this.parentView.elemDom.appendChild(this.elemDom);
    async onMeasure(maxWidth, maxHeigth) {
        if(!this.elemDom) return; // No realizada nada si no fué agregado a la vista


        // ************  ANCHO DE PANTALLA  ************
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = (maxWidth - this.margin.left - this.margin.right) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                var width = parseInt(this.width);
                width = Math.max(width,this.maxWidth);
                this.elemDom.style.width = width + 'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = (maxHeigth - this.margin.top - this.margin.bottom) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                var height = parseInt(this.height);
                height = Math.max(height,this.maxHeigth);
                this.elemDom.style.height = height + 'px';
                break;
        }
        if(this.backgroundPainter)
            await this.backgroundPainter.paint();
    }

    async remove(){
        if(!this.parentView)
            return;
        if(this.parentView instanceof Container)
            this.parentView.removeView(this);
    }

    cloneDomElem(){
        let dom = this.elemDom.cloneNode(true);
        return dom;
    }
}
// Class: src/view/TextView.js
class TextView extends View {
    constructor(context){
        super(context);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.textColor = Resource.getAttrOfTheme(this.constructor.name, 'textColor');
        this.textCssStyle = Resource.getAttrOfTheme(this.constructor.name, 'textCssStyle');
        this.textSize = Resource.getAttrOfTheme(this.constructor.name, 'textSize',12);
        this.iconSize = Resource.getAttrOfTheme(this.constructor.name, 'iconSize',12);
        this.drawableResource= null;
        this.gravityIcon = Resource.getAttrOfTheme(this.constructor.name, 'gravityIcon','left');
        this.singleLine = Resource.getAttrOfTheme(this.constructor.name, 'singleLine',false);
        this.ellipsize= "none";
        this.imageResource = null;
        this.iconWidth=null;
        this.iconHeight=null;

        this.shadowColor = Resource.getAttrOfTheme(this.constructor.name, 'shadowColor');
        this.shadowDx = Resource.getAttrOfTheme(this.constructor.name, 'shadowDx',0);
        this.shadowDy = Resource.getAttrOfTheme(this.constructor.name, 'shadowDy',0);
        this.shadowRadius = Resource.getAttrOfTheme(this.constructor.name, 'shadowRadius',3);
    }

    //@Override
    async parse(nodeXml){
        await super.parse(nodeXml);
        
        this.text = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TEXT) || this.text;
        this.textColor = this.getAttrFromNodeXml(nodeXml,"textColor") || this.textColor;
        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_LEFT) !== null) {
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_LEFT);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_RIGHT) !== null) {
            this.gravityIcon = LayoutInflater.RIGHT;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_RIGHT);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_TOP) !== null) {
            this.gravityIcon = LayoutInflater.TOP;
            this.drawableResource =  this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_TOP);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_BOTTOM) !== null) {
            this.gravityIcon = LayoutInflater.BOTTOM;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_BOTTOM);
        }
        else{
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = null;
        }
        this.singleLine = this.getAttrFromNodeXml(nodeXml,"singleLine")? (this.getAttrFromNodeXml(nodeXml,"singleLine")==="true") : this.singleLine;
        this.textStyle = this.getAttrFromNodeXml(nodeXml,"textStyle") || this.textStyle;

        this.shadowColor = this.getAttrFromNodeXml(nodeXml,"shadowColor") || this.shadowColor;
        this.shadowDx = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowDx")) || this.shadowDx;
        this.shadowDy = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowDy")) || this.shadowDy;
        this.shadowRadius = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowRadius"))||this.shadowRadius;
        
        this.iconWidth = parseInt(this.getAttrFromNodeXml(nodeXml,"iconWidth")) || this.iconWidth;
        this.iconHeight = parseInt(this.getAttrFromNodeXml(nodeXml,"iconHeight")) || this.iconHeight;

        this.textSize = this.getAttrFromNodeXml(nodeXml,"textSize")||this.textSize;
        if(this.getAttrFromNodeXml(nodeXml,"iconSize"))
            this.iconSize = this.getAttrFromNodeXml(nodeXml,"iconSize")||this.iconSize;
        else
            this.iconSize = this.textSize;
    }

    // Override
    getAllAttrs(){
        return Object.keys(this);
    }

    setSingleLine(single) {
        this.singleLine = single;
    }

    setTextColor(color) {
        this.textColor = color;
    }

    async setText(text){
        this.text = text;
        if(this.elemDom)
            this.elemText.innerHTML = this.text;
        this.onReMeasure();
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.elemText = this.createHtmlElemFromType('span');
        this.elemText.style.wordWrap = 'break-word'; // Ajustar texto a contenido
        this.elemIcon = this.createHtmlElemFromType('img');

        this.elemDom.appendChild(this.elemText);
        this.elemDom.appendChild(this.elemIcon);
        return this.elemDom;
    }

    // @Override
    async loadResources() {
        await super.loadResources();

        // Estableciendo valores de los atributos
        this.elemText.innerHTML = this.text;
        this.elemText.style.color = this.textColor;
        if (this.singleLine === true)
            this.elemText.style.whiteSpace = "nowrap";
        this.elemText.style.textOverflow = "ellipsis";
        switch (this.textStyle) {
            case "bold": this.elemText.style.fontWeight = 'bold'; break;
            case "italic": this.elemText.style.fontWeight = 'italic'; break;
            default: this.elemText.style.fontWeight = 'normal'; break;
        }
        if(this.textSize)
            this.elemText.style.fontSize = this.textSize;
        if(this.shadowColor)
            this.elemText.style.textShadow=`${this.shadowDx}px ${this.shadowDy}px ${this.shadowRadius}px ${this.shadowColor}`;
        
        // Cargando la imagen o icono te texto
        this.imageResource = null;
        if(this.drawableResource){
            this.imageResource = await Resource.loadImage(this.drawableResource);
            this.elemIcon.src = this.imageResource.src;
            let wIcon = parseInt(this.iconSize);

            this.elemIcon.width = this.iconWidth||wIcon;
            this.elemIcon.height = this.iconHeight||wIcon;
        }
    }

    async onMeasure(maxWidth, maxHeight) {
        const marginDrawable = this.elemIcon.clientWidth===0?0:8; // 4px
        // Redimensionando el tamaño del icono al mismo tamaño del texto
        // if(this.drawableResource){
        //     this.elemIcon.width = parseInt(this.textSize);
        //     this.elemIcon.height = parseInt(this.textSize);
        // }
        switch(this.gravityIcon){
            case "left":
                this.elemIcon.style.left = (this.padding.left) + 'px';
                this.elemIcon.style.top = (this.padding.top) + 'px';

                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                this.elemText.style.left = (this.padding.left + this.elemIcon.clientWidth + marginDrawable) + 'px';
                this.elemText.style.top = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight)-this.elemText.clientHeight) + 'px';

                this.elemDom.style.width = (this.padding.left + (this.elemIcon.clientWidth>0?this.elemIcon.clientWidth+marginDrawable : 0) + this.elemText.clientWidth+this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight) +marginDrawable + this.padding.bottom) + 'px';
                break;
            case "right":
                this.elemText.style.left = (this.padding.left) + 'px';
                this.elemText.style.top = (this.padding.top + (this.elemIcon.clientHeight-this.elemText.clientHeight)) + 'px';

                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }
                this.elemIcon.style.left = (this.padding.left+this.elemText.clientWidth+marginDrawable) + 'px';
                this.elemText.style.top = (this.padding.top + Math.max(this.elemIcon.clientHeight,this.elemText.clientHeight)-this.elemText.clientHeight) + 'px';

                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + (this.elemIcon.clientWidth>0?this.elemIcon.clientWidth+marginDrawable : 0) + this.elemText.clientWidth + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + Math.max(this.elemText.clientHeight, this.elemIcon.clientHeight) + this.padding.bottom) + 'px';
                break;
            case "bottom":
                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                let maximoAncho = Math.max(this.elemText.clientWidth,this.elemIcon.clientWidth);

                this.elemText.style.left = (this.padding.left+maximoAncho/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = (this.padding.top) + 'px';

                this.elemIcon.style.left = (this.padding.left+maximoAncho/2 -this.elemIcon.clientWidth/2) + 'px';
                this.elemIcon.style.top = (this.padding.top+marginDrawable+this.elemText.clientHeight) + 'px';
                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + maximoAncho + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + this.elemText.clientHeight + marginDrawable + this.elemIcon.clientHeight + this.padding.bottom) + 'px';
                break;
            case "top":
                switch (this.width) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.width = (
                            maxWidth -
                            this.elemIcon.clientWidth - 
                            marginDrawable -
                            this.padding.left - this.margin.right) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let width = parseInt(this.width);
                        this.elemText.style.width = (
                            width -
                            this.padding.left -
                            this.elemIcon.clientWidth -
                            marginDrawable -
                            this.padding.right) + 'px';
                        break;
                }
                switch (this.height) {
                    case LayoutInflater.MATCH_PARENT:
                        this.elemText.style.height = (
                            maxHeight -
                            this.elemIcon.clientHeight - 
                            marginDrawable -
                            this.padding.top - this.padding.bottom) + 'px';
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        break;
                    default: // tamaño establecido por el usuario
                        let height = parseInt(this.height);
                        this.elemText.style.height = (
                            height -
                            this.padding.top -
                            this.elemIcon.clientHeight -
                            marginDrawable -
                            this.padding.bottom) + 'px';
                        break;
                }

                let maximoAnchoTop = Math.max(this.elemText.clientWidth,this.elemIcon.clientWidth);
                
                this.elemIcon.style.left = (this.padding.left+maximoAnchoTop/2 -this.elemIcon.clientWidth/2) + 'px';
                this.elemIcon.style.top = (this.padding.top) + 'px';

                this.elemText.style.left = (this.padding.left+maximoAnchoTop/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = (this.padding.top+marginDrawable+this.elemIcon.clientHeight) + 'px';
                // establecemos las dimensiones
                this.elemDom.style.width = (this.padding.left + maximoAnchoTop + this.padding.right) + 'px';
                this.elemDom.style.height = (this.padding.top + this.elemText.clientHeight + marginDrawable + this.elemIcon.clientHeight + this.padding.bottom) + 'px';
                break;
            default:
                throw new Exception(`Tipo de alineación [${this.gravityIcon}] no soportada`);
        }
        await this.repaint();
    }

    async setDrawableIcon(drawable,position){
        this.gravityIcon = position;
        this.drawableResource = drawable;
        if(this.elemDom){
            let image = await Resource.loadImage(drawable);
            this.elemIcon.src = image.src;
        }
    }

    async setDrawableLeft(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.LEFT);
    }


    async setDrawableTop(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.TOP);
    }

    async setDrawableRight(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.RIGHT);
    }

    getText() {
        return this.text;
    }
}
// Class: src/view/Button.js
class Button extends TextView{
    constructor(context){
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
        this.padding.left = this.padding.top = this.padding.right = this.padding.bottom = 4;
    }
};
// Class: src/view/LinkButton.js
class LinkButton extends Button{
    constructor(context){
        super(context);
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.elemDom.style.border = "none";
        return this.elemDom;
    }
};
// Class: src/view/EditText.js
class EditText extends View{
    // ems: 20,
    // lines: 1,
    // maxEms: 80,
    // maxLines: 10,
    // hint: null,
    // maxLength: -1,
    // readonly: false,
    constructor (context) {
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.bottom = 4;
        this.ems = Resource.getAttrOfTheme(this.constructor.name, 'ems',20);
        this.lines = Resource.getAttrOfTheme(this.constructor.name, 'lines',3);
        this.hint = null;
        this.maxLength = -1;
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.enabled = true;
        this.textSize = Resource.getAttrOfTheme(this.constructor.name, 'textSize','13px');
        this.textChangeListener = null;
        this.singleLine = Resource.getAttrOfTheme(this.constructor.name, 'singleLine',false);
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.ems = this.getAttrFromNodeXml(nodeXml,"ems")?parseInt(this.getAttrFromNodeXml(nodeXml,"ems")): this.ems;
        this.lines = this.getAttrFromNodeXml(nodeXml,"lines")?parseInt(this.getAttrFromNodeXml(nodeXml,"lines")): this.lines;
        this.hint = this.getAttrFromNodeXml(nodeXml,"hint") || this.hint;
        this.maxlength = this.getAttrFromNodeXml(nodeXml,"maxlength")?parseInt(this.getAttrFromNodeXml(nodeXml,"maxlength")): this.maxlength;
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
        this.singleLine = this.getAttrFromNodeXml(nodeXml,"singleLine")? (this.getAttrFromNodeXml(nodeXml,"singleLine")==="true") : this.singleLine;
        if(this.singleLine === true)
            this.lines = 1;
        this.enabled = this.getAttrFromNodeXml(nodeXml,"enabled")?(this.getAttrFromNodeXml(nodeXml,"enabled")==="true") : this.enabled;
        this.textSize = this.getAttrFromNodeXml(nodeXml,"textSize")||this.textSize;
    }

    // @Override
    getTypeElement(){
        return 'TextArea';
    }
    getText() {
        return this.elemDom.value;
    }
    setText(txt) {
        this.elemDom.value = txt;
    }
    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }
    setError(msg) {
        this._super(msg);
        this.elemDom.focus();
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        //cols="5" rows="1"
        this.elemDom.cols = this.ems;
        this.elemDom.rows = this.lines;
        // this.elemDom.style.height = (this.elemDom.rows * 22) + 'px';
        if(this.lines === 1){
            this.elemDom.style.whiteSpace = "nowrap";
            this.elemDom.style.overflowX = "hidden";
        }
        this.elemDom.onkeydown = (e)=>{
            if (this.lines===1&& e.keyCode == 13 && !e.shiftKey){
                e.preventDefault();
                return false;
            }
            else
                return true;
        };
        if (this.hint !== null)
            this.elemDom.placeholder = this.hint;
        if (this.maxLength > 0)
            this.elemDom.setAttribute("maxlength", this.maxLength);
        this.elemDom.style.resize = 'none';
        this.elemDom.value = this.text;
        this.elemDom.disabled = !this.enabled;
        this.elemDom.style.paddingTop = '6px';
        this.elemDom.style.paddingLeft = '6px';
        this.elemDom.style.paddingBottom = '6px';
        this.elemDom.style.paddingRight = '6px';
        this.elemDom.style.fontSize = this.textSize;
    }

    getWidth() {
        return super.getWidth()+6*2;
    }

    //@Override
    getHeight() {
        return super.getHeight()+6*2;
    }

    setTextChangeListener(textChangeListener){
        this.textChangeListener = textChangeListener;
        this.elemDom.addEventListener('input', (e) => {
            this.textChangeListener.onChange(this.getText());
        });
    }
}
// Class: src/view/ImageView.js
class ImageView extends View{
    // src: null,
    // scaleType: LayoutInflater.FIT_XY,
    constructor(context){
        super(context);
        this.src = null;
        this.image = null;
        this.scaleType = LayoutInflater.FIT_XY;
    }

    //@Override
    async createHtmlElement () {
        super.createHtmlElement();
        // Icono
        this.elemIcon = this.createHtmlElemFromType('img');
        this.elemDom.appendChild(this.elemIcon);
        return this.elemDom;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.src = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_SRC);
        this.scaleType = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_SCALE_TYPE)||LayoutInflater.FIT_CENTER_INSIDE;
        this.image = null;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        if(this.src){
            this.image = await Resource.loadImage(this.src);
            this.elemIcon.src = this.image.src;
        }
    }
    
    // @Override
    async onMeasure(maxWidth, maxHeight) {
        if(this.image){
            // Estableciendo dimensión de componente
            this.elemIcon.style.top = this.padding.top + 'px';
            this.elemIcon.style.left = this.padding.left + 'px';

            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.width = maxWidth +'px';
                    this.elemIcon.style.width = (maxWidth-this.padding.left - this.padding.right)+'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemIcon.style.width = (this.image.clientWidth)+'px';
                    this.elemDom.style.width = (this.padding.left + this.image.clientWidth + this.padding.right)+'px';
                    break;
                default: // tamaño establecido por el usuario
                    let width = parseInt(this.width);
                    this.elemIcon.style.width = (width - this.padding.left - this.padding.right)+'px';
                    this.elemDom.style.width = width+'px';
                    break;
            }
    
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.height = maxHeight +'px';
                    this.elemIcon.style.height = (maxHeight-this.padding.top - this.padding.bottom)+'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemIcon.style.height = (this.image.clientHeight)+'px';
                    this.elemDom.style.height = (this.padding.top + this.image.clientHeight + this.padding.bottom)+'px';
                    break;
                default: // tamaño establecido por el usuario
                    let height = parseInt(this.height);
                    this.elemIcon.style.height = (height - this.padding.top - this.padding.bottom)+'px';
                    this.elemDom.style.height = height+'px';
                    break;
            }
    
            // Ajustando Imagen
            switch (this.scaleType){ //contain
                case LayoutInflater.FIT_CENTER: this.elemIcon.style.objectFit = 'none'; break;
                case LayoutInflater.FIT_START: this.elemIcon.style.objectFit = 'cover'; break;
                case LayoutInflater.FIT_CENTER_CROP: this.elemIcon.style.objectFit = 'scale-down'; break;
                case LayoutInflater.FIT_CENTER_INSIDE: this.elemIcon.style.objectFit = 'contain'; break;
                case LayoutInflater.FIT_END: this.elemIcon.style.objectFit = 'scale-down'; break;
                case LayoutInflater.FIT_XY: this.elemIcon.style.objectFit = 'fill'; break;
            }
        }else{ // El ImageView no tiene imagen
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.width = maxWidth;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemDom.style.width = this.padding.left + this.padding.right;
                    break;
                default: // tamaño establecido por el usuario
                    this.elemDom.style.width = parseInt(this.width) + 'px';
                    break;
            }
    
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.height = maxHeight;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemDom.style.height = this.padding.top + this.padding.bottom;
                    break;
                default: // tamaño establecido por el usuario
                    this.elemDom.style.height = parseInt(this.height) + 'px';
                    break;
            }
        }
        await this.repaint();
    }

    async setImageResource(pathImage) {
        this.src = pathImage;
        if(pathImage){
            if(Resource.isBase64Resource(pathImage)){
                this.image = null;
                this.elemIcon.src = pathImage;
            }
            else{
                this.image = await Resource.loadImage(this.src);
                this.elemIcon.src = this.image.src;
            }
        }
        else{
            this.elemIcon.src = '';
            this.image = null;
        }
    }

    getDomImageResource(){
        return this.elemIcon.src;
    }
}
// Class: src/view/ImageButton.js

class ImageButton extends ImageView{
    constructor(context){
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.bottom = 4;
    }
};
// Class: src/view/Password.js
class Password extends View{
    // ems: 20,
    // lines: 1,
    // maxEms: 80,
    // maxLines: 10,
    // hint: null,
    // maxLength: -1,
    // readonly: false,
    constructor (context) {
        super(context);
        this.margin.left = this.margin.top = this.margin.right = this.bottom = 0;
        this.ems = Resource.getAttrOfTheme(this.constructor.name, 'ems',20);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.ems = this.getAttrFromNodeXml(nodeXml,"ems")?parseInt(this.getAttrFromNodeXml(nodeXml,"ems")): this.ems;
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
    }

    // @Override
    getTypeElement(){
        return 'input';
    }
    
    getText() {
        return this.elemDom.value;
    }

    setText(txt) {
        this.elemDom.value = txt;
    }

    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.elemDom.type = 'password';
        this.elemDom.value = this.text;
        this.elemDom.style.paddingTop = '6px';
        this.elemDom.style.paddingLeft = '6px';
        this.elemDom.style.paddingBottom = '6px';
        this.elemDom.style.paddingRight = '6px';
    }

    getWidth() {
        return super.getWidth()+6*2;
    }

    getHeight() {
        return super.getHeight()+6*2;
    }
}
// Class: src/view/Camera.js

class Camera extends View{
    constructor(context){
        super(context);
        this.captureAudio = false;
        this.captureVideo = true;
    }

    // @Override
    getTypeElement(){
        return 'video';
    }

    async start(){
        let stream = await navigator.mediaDevices.getUserMedia({
            video: this.captureVideo,
            audio: this.captureAudio
        });
        this.elemDom.srcObject = stream;
        this.elemDom.play();
    }

    async stop(){
        if(this.elemDom.srcObject){
            let tracks = this.elemDom.srcObject.getTracks();
            tracks.forEach(track =>{
                track.stop();
            });
        }
        this.elemDom.srcObject = null;
    }

    takePicture(){
        let canvas = document.createElement('canvas');
        canvas.width = this.getWidth();
        canvas.height = this.getHeight();
        canvas.style.visibility = "hidden";
        document.body.appendChild(canvas);
        
        let context = canvas.getContext('2d');
        context.drawImage(this.elemDom, 0, 0,this.getWidth(),this.getHeight());
        let imgBase64 = canvas.toDataURL('image/png');
        canvas.remove();
        return {
            fileExt: 'png',
            dataInBase64: imgBase64.replace("data:image/png;base64,","")
        }
    }
};
// Class: src/view/RadioButton.js
class RadioButton extends View{
    constructor (context) {
        super(context);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.onClick = Resource.getAttrOfTheme(this.constructor.name, 'onClick');
        this.radioGroup = Resource.getAttrOfTheme(this.constructor.name, 'radioGroup');

        
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
        this.onClick = this.getAttrFromNodeXml(nodeXml,"onClick") || this.onClick;
        this.radioGroup = this.getAttrFromNodeXml(nodeXml,"radioGroup") || this.radioGroup;
    }

    // @Override
    getTypeElement(){
        return 'input';
    }
    
    getText() {
        return this.elemDom.value;
    }

    setText(txt) {
        this.elemDom.value = txt;
    }

    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.elemDom.type = 'radio';
        this.elemDom.value = this.text;
        this.elemDom.name = this.radioGroup;

        // this.elemDom.style.height='50px';
        // this.elemDom.style.width='50px';
    }

    getWidth() {
        return super.getWidth();
    }

    getHeight() {
        return super.getHeight();
    }

    isChecked(){
        return this.elemDom.checked;
    }

    setChecked(checket){
        return this.elemDom.checked = checket===true;
    }
}
// Class: src/view/OptionItem.js
class OptionItem extends LinkButton{
    constructor(context){
        super(context);
        this.singleLine = true;
    }
};
// Class: src/view/Spinner.js
class Spinner extends View{
    constructor(context){
        super(context);
        this.popup = new PopupWindow(context);
        let linViews = new LinearLayout(this.popup);

        linViews.setBackground("lib/imgs/bg_popup.9.png");
        linViews.setWidth('250px');
        linViews.setHeight('200px');
        linViews.setOrientation('vertical');
        this.popup.setContentView(linViews);
        this.popup.setView(this);
        this.popup.setPositionOnView('right|top');
        this.setOnClickListener(this.onClickToogleSpinner);
        this.onItemSelected = null;
        this.selectedIndex = -1;
    }

    async onClickOptionItem(viewOption){
        if(this.elemSelected.firstChild)
            this.elemSelected.removeChild(this.elemSelected.firstChild);
        if(this.onItemSelected){
            Reflect.apply(this.onItemSelected, this.context,[viewOption]);
        }
        this.hideOptions();
        let index = 0;
        for(let option of this.popup.getViewRoot().getChilds()){
            if(option === viewOption)
                break;
        }
        await this.setSelecttion(index);
    }

    async setSelecttion(index){
        if(index< 0 || index>= this.popup.getViewRoot().getChilds().length)
            throw new Exception(`El indice para la selección al Spinner debe estar entre [${0}] y [${this.popup.getViewRoot().getChilds().length}]`);
        if(this.selectedIndex===-1){

        }
        let option = this.popup.getViewRoot().getChildAt(index);
        this.elemSelected.appendChild(option.cloneDomElem());
    }

    setOnItemSelected(funOnItem){
        for(let viewOption of this.popup.getViewRoot().getChilds()){
            viewOption.setOnClickListener(this.onClickOptionItem,this);
        }
        this.onItemSelected = funOnItem;
    }

    async onClickToogleSpinner(){
        if(this.popup.isVisible())
            this.hideOptions();
        else
            await this.showOptions();
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();        
        // Conenedor
        this.elemSelected = this.createHtmlElemFromType('div');
        this.elemDom.appendChild(this.elemSelected);

        // Boton select
        this.elemImgBtn = this.createHtmlElemFromType('img');
        this.elemDom.appendChild(this.elemImgBtn);
        return this.elemDom;
    }

    async addOptionItem(viewOption){
        if(!(viewOption instanceof OptionItem))
            throw `Solo es permitido agregar Views de tipo [OptionItem]. El view enviado es de tipo [${viewOption.constructor.name}]`;
        await viewOption.setOnClickListener(this.onClickOptionItem,this);
        await this.popup.getViewRoot().addView(viewOption);
        viewOption.context = this;
    }

    getPopupContext(){
        return this.popup;
    }

    async showOptions(){
        let windowsDimension = PageManager.getWindowsDimension();
        // await this.popup.getViewRoot().onMeasure(windowsDimension.width, windowsDimension.height);
        await this.popup.show();
    }

    hideOptions(){
        this.popup.cancel();
    }
};
// Class: src/view/WaitingView.js
class WaitingView extends View{
    constructor (context) {
        super(context);
    }

    // @Override
    createHtmlElement(){
        this.width='30px';
        this.height='30px';
        super.createHtmlElement();
        this.animation = new SpinnerAnimation({
            left: 0,
            top: 0,
            size: 30, 
            showBackground: false,
            backgroundRotation: false,
            parentElement: this.elemDom
        });
        this.animation.show();
    }

    async onMeasure(maxWidth, maxHeigth) {
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + 30 + this.padding.bottom; break;
            default: maxHeightElement = parseInt(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + 30 + this.padding.right; break;
            default: maxWidthElement = parseInt(this.width);
        }

        this.animation.resize(Math.min(maxWidthElement,maxWidthElement));
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }
}
// Class: src/view/event/TextChangeListener.js
class TextChangeListener {
    onChange(newText) {}
}
// Class: src/layout/Container.js
class Container extends View{
    constructor(context){
        super(context);
        this.viewsChilds = new Array();
    }

    getViewVisibles() {
        // agrupamos los GONE's y los INVISIBLE's
        let vistos = new Array();
        for (let index = 0; index < this.viewsChilds.length; index++) {
            let view = this.viewsChilds[index];
            if (view.visibility === View.VISIBLE)
                vistos.push(view);
        }
        return vistos;
    }

    // @Override
    findViewById(idView) {
        let view = super.findViewById(idView);
        if (view)
            return view;
        for (let i = 0; i < this.viewsChilds.length; i++) {
            view = this.viewsChilds[i];
            let tempView = view.findViewById(idView);
            if(tempView)
                return tempView;
        }
        return null;
    }

    async removeView(viewChild){
        let index = this.viewsChilds.indexOf(viewChild);
        if (index === -1)
            throw new Exception(`No se encontro el view [${viewChild}] en la vista [${this.constructor.name}]`);
        this.viewsChilds.splice(index, 1);
        viewChild.elemDom.remove();
        await this.onReMeasure();
    }
    
    //@Override
    async loadResources(){
        await super.loadResources();
        for(let view of this.viewsChilds)
            await view.loadResources();
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeight){
        await super.onMeasure(maxWidth, maxHeight);
        for(let view of this.viewsChilds)
            await view.onMeasure(maxWidth, maxHeight);
    }

    getChildCount() {
        return this.viewsChilds.length;
    }

    getChildAt(i) {
        return this.viewsChilds[i];
    }

    getChilds(){
        return this.viewsChilds;
    }

    getFirstChild(){
        if(this.viewsChilds.length>0)
            return this.viewsChilds[0];
        return null;
    }

    async setFirstChild(viewChild){
        if(this.viewsChilds.length>0){
            await this.viewsChilds[0].remove();
            this.viewsChilds[0] = viewChild;
        }
        else
            this.viewsChilds.push(viewChild);
        viewChild.parentView = this;
        await viewChild.loadResources();
        this.elemDom.appendChild(viewChild.elemDom);
        await this.onReMeasure();
    }
}
// Class: src/layout/ViewGroup.js
class ViewGroup extends Container{
    constructor(context){
        super(context);
    }

    getContentWidth(maxWidth,viewChild){
        if(maxWidth <= 0)
            return 0;
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                return maxWidth - this.padding.left - this.padding.right - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
            case LayoutInflater.WRAP_CONTENT:
                return this.elemDom.clientWidth - this.padding.left - this.padding.right  - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
            default: // Tamanio especifico 
                let lenght = parseInt(this.width);
                return lenght - this.padding.left - this.padding.right - (viewChild?viewChild.margin.left:0) - (viewChild?viewChild.margin.right:0);
        }
    }

    getContentHeight(maxHeight,viewChild){
        if(maxHeight <= 0)
            return 0;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                return maxHeight - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
            case LayoutInflater.WRAP_CONTENT:
                return this.elemDom.clientWidth - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
            default: // Tamanio especifico 
                let lenght = parseInt(this.height);
                return lenght - this.padding.top - this.padding.bottom - (viewChild?viewChild.margin.top:0) - (viewChild?viewChild.margin.bottom:0);
        }
    }
    
    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = await this.parseViewChild(nodeChild);
            child.parentView = this;
            this.viewsChilds.push(child);
            this.elemDom.appendChild(child.elemDom);
        }
    }

    async parseViewChild(nodeXml) {
        let child = await LayoutInflater.inflate(this.context, nodeXml);
        return child;
    }

    async addView(viewChild) {
        if (viewChild === null || viewChild === undefined)
            throw new Exception("El View que desea agregar es nulo o no esta definido");
        if(!viewChild instanceof View)
            throw new Exception(`El objeto [${viewChild}] a agregar no es una instancia de View`);
        this.viewsChilds.push(viewChild);
        viewChild.parentView = this;
        await viewChild.loadResources();
        this.elemDom.appendChild(viewChild.elemDom);
        await this.onReMeasure();
        await LayoutInflater.showAllViews(viewChild);
    }
}
// Class: src/layout/LinearLayout.js
class LinearLayout extends ViewGroup {
    constructor(context) {
        super(context);
        // this.orientation = LayoutInflater.LIN_ORIENTATION_HORIZONTAL;
    }

    //Override
    async parse(nodeXml) {
        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ORIENTATION) === LayoutInflater.LIN_ORIENTATION_VERTICAL)
            this.orientation = LayoutInflater.LIN_ORIENTATION_VERTICAL;
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ORIENTATION) === LayoutInflater.LIN_ORIENTATION_HORIZONTAL)
            this.orientation = LayoutInflater.LIN_ORIENTATION_HORIZONTAL;
        else
            throw new Exception(
                `La orientación para LinearLayout debe ser unicamente [horizontal o vertical]. Establesca el atributo [${LayoutInflater.ATTR_ORIENTATION}] para definir la orientación de la vista`);
        await super.parse(nodeXml);
    }

    //Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        view.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY);

        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WEIGHT) !== null){
            let weight = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WEIGHT);
            var num = parseFloat(weight);
            if (isNaN(num) === true)
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_WEIGHT}] del view [${this.constructor.name}] no es un número flotante [${weight}]`);

            if (!(num > 0.0 && num <= 1.0))
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_WEIGHT}] es [${weight}] del view [${this.constructor.name}] no esta del rango válido entre [0.0 y 1.0]`);
            view.layoutWeight = num;
        }
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        if (this.orientation === LayoutInflater.LIN_ORIENTATION_VERTICAL)
            await this.onMeasureVertical(visibles,maxWidth,maxHeight);
        else
            await this.onMeasureHorizontal(visibles,maxWidth,maxHeight);
        await this.repaint();
    }

    async onMeasureVertical(visibles, maxWidth, maxHeight) {
        let sumHeight = this.padding.top;
        let mayWidth = this.padding.left + this.padding.right;

        let sumHeigthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            if (view.layoutWeight !== undefined && view.layoutWeight !== null && view.layoutWeight > 0)
                arrayWeigh.push(view);
            else{
                await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumHeigthWrap += (view.margin.top + view.getHeight() + view.margin.bottom);
                if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right) > mayWidth)
                    mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
                sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
            }
        }

        // Estableciendo alto de los componentes que tiene weight
        if(this.height === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [layoutWeight] en uno de los hijos del [LinearLayout] con orientación [${this.orientation}] pero el ancho se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let altoWeigth = this.getContentHeight(maxHeight) - sumHeigthWrap;
        for(let view of arrayWeigh){
            await view.onMeasure(this.getContentWidth(maxWidth,view) , altoWeigth*view.layoutWeight - view.margin.top - view.margin.bottom);
            if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right)>mayWidth)
                mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
            sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
        }

        // Estableciendo dimenciones del componente
        let maxWidthElement, maxHeightElement;
        sumHeight = sumHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = sumHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posTop = this.padding.top;
        for(let view of visibles){
            // Posición horizontal
            view.layoutGravity = view.layoutGravity || LayoutInflater.LEFT;
            let gravitys = view.layoutGravity.split("|");
            for(let layoutGravity of gravitys){
                switch (layoutGravity) {
                    case LayoutInflater.LEFT:
                        view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                        break;
                    case LayoutInflater.RIGHT:
                        view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                        break;
                    case LayoutInflater.CENTER_HORIZONTAL:
                        view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${layoutGravity}]. Utilice unicamente [${LayoutInflater.LEFT},${LayoutInflater.RIGHT},${LayoutInflater.CENTER_HORIZONTAL}]`);
                }
            }

            // Posición vertical
            view.elemDom.style.top = (posTop + view.margin.top) + 'px';
            posTop = posTop + view.margin.top + view.getHeight() + view.margin.bottom;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    async onMeasureHorizontal(visibles, maxWidth, maxHeight) {
        let mayHeight = this.padding.top + this.padding.bottom;

        let sumWidthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            if (view.layoutWeight !== undefined && view.layoutWeight !== null && view.layoutWeight > 0){
                arrayWeigh.push(view);
            }
            else{
                await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumWidthWrap += (view.margin.left + view.getWidth() + view.margin.right);
                if ((this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                    mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            }
        }

        let sumWidth = this.padding.left + sumWidthWrap;

        // Estableciendo alto de los componentes que tiene weight
        if(this.width === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [layoutWeight] en uno de los hijos del [LinearLayout] con orientación [${this.orientation}] pero el alto se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let anchoWeigth = this.getContentWidth(maxWidth) - sumWidthWrap;
        for(let view of arrayWeigh){
            await view.onMeasure(anchoWeigth*view.layoutWeight - view.margin.left - view.margin.right, this.getContentHeight(maxHeight,view));
            if ( (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            sumWidth+=(view.margin.left + view.getWidth() + view.margin.right);
        }

        // Verificando tamano de 
        let maxWidthElement, maxHeightElement;
        sumWidth = sumWidth + this.padding.right;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: 
                maxWidthElement = sumWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posLeft = this.padding.top;
        for(let view of visibles){
            // Posición vertical
            view.layoutGravity = view.layoutGravity || LayoutInflater.TOP;
            let gravitys = view.layoutGravity.split("|");
            for(let layoutGravity of gravitys){
                switch (layoutGravity) {
                    case LayoutInflater.TOP:
                        view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                        break;
                    case LayoutInflater.BOTTOM:
                        view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.top - this.padding.top) + 'px';
                        break;
                    case LayoutInflater.CENTER_VERTICAL:
                        view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${layoutGravity}]. Utilice unicamente [${LayoutInflater.TOP},${LayoutInflater.BOTTOM},${LayoutInflater.CENTER_VERTICAL}]`);
                }
            }
            // Posición horizontal
            view.elemDom.style.left = (posLeft + view.margin.left) + 'px';
            posLeft = posLeft + view.margin.left + view.getWidth() + view.margin.right;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    setOrientation(orientation) {
        this.orientation = orientation;
    }
}
// Class: src/layout/FrameLayout.js
class FrameLayout extends ViewGroup {
    constructor(context) {
        super(context);
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        view.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY)||'left|top';
        return view;
    }

    // @Override
    async addView(viewChild) {
        viewChild.layoutGravity = viewChild.layoutGravity || 'left|top';
        await super.addView(viewChild);
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        //  Dibujamos todos los componentes
        let mayHeight = this.padding.top + this.padding.bottom;
        let mayWidth = this.padding.left + this.padding.right;
        for(let view of visibles){
            await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
            if((view.margin.left+this.padding.left+view.getWidth()+this.padding.right+view.margin.right) > mayWidth)
                mayWidth = (view.margin.left+this.padding.left+view.getWidth()+this.padding.right+view.margin.right);
            if((view.margin.top+this.padding.top+view.getHeight()+this.padding.bottom+view.margin.bottom) > mayHeight)
                mayHeight = (view.margin.top+this.padding.top+view.getHeight()+this.padding.bottom+view.margin.bottom);
        }
        let maxWidthElement,maxHeightElement;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }

        for(let view of visibles){
            let gravitys = view.layoutGravity.split("|");
            let leftAligned =false;
            for (let j = 0; j < gravitys.length; j++) {
                let layoutGravity = gravitys[j];
                if (layoutGravity === LayoutInflater.TOP)
                    view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                if (layoutGravity === LayoutInflater.RIGHT){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                }
                if (layoutGravity === LayoutInflater.LEFT){
                    leftAligned = true;
                    view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                }
                if (layoutGravity === LayoutInflater.BOTTOM)
                    view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.bottom - this.padding.bottom) + 'px';
                if (layoutGravity === LayoutInflater.CENTER_HORIZONTAL){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                }
                if (layoutGravity === LayoutInflater.CENTER_VERTICAL)
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                if (layoutGravity === LayoutInflater.CENTER){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                }
            }
            if(!leftAligned)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaint();
    }
}
// Class: src/layout/RelativeLayout.js
class RelativeLayout extends ViewGroup{
    constructor(context) {
        super(context);
    }

    //@Override
    async parseViewChild(nodeXml) {
        var view = await super.parseViewChild(nodeXml);
        view.alignParentTop = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTTOP) === "true");
        view.alignParentRight = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTRIGHT) === "true");
        view.alignParentBottom = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTBOTTOM) === "true");
        view.alignParentLeft = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTLEFT) === "true");
        
        view.centerHorizontal = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERHORIZONTAL) === "true");
        view.centerVertical = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERVERTICAL) === "true");
        view.centerInParent = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERINPARENT) === "true");
        
        view.above = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ABOVE);
        view.below = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_BELOW);
        view.toRightOf = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TORIGHTOF);
        view.toLeftOf = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TOLEFTOF);
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        await super.onMeasure(maxWidth, maxHeight);
        let visibles = this.getViewVisibles();
        var mayHeight = 0;
        var mayWidth = 0;
        // Dibujando todos los componentes sin posicionarlos para obtener sus dimensiones candidato
        for(let view of visibles){
            await view.onMeasure(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);
            let sumWidth = this.padding.left + view.margin.left + view.elemDom.clientWidth + view.margin.right + this.padding.right;
            if (sumWidth > mayWidth)
                mayWidth = sumWidth;
            let sumHeight = this.padding.top + view.margin.top + view.elemDom.clientHeight + view.margin.bottom + this.padding.bottom;
            if (sumHeight > mayHeight)
                mayHeight = sumHeight;
        }

        // Iteramos nuevamente para posicionar los elementos a partir de su dimesion y respecto a sus referencias
        for(let view of visibles){
            await view.onMeasure(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);

            // Posicionamos la vista segun el layout
            if (view.alignParentTop === true)
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.alignParentRight === true)
                view.elemDom.style.left = (this.elemDom.clientWidth - view.elemDom.clientWidth - view.margin.right - this.padding.right) + 'px';
            if (view.alignParentLeft === true)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            if (view.alignParentBottom === true)
                view.elemDom.style.top = (this.elemDom.clientHeight - view.elemDom.clientHeight - view.margin.bottom - this.padding.bottom) + 'px';

            if (view.centerHorizontal === true)
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
            if (view.centerVertical === true)
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            if (view.centerInParent === true) {
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            }

            // Ubicación respecto a otros elementos
            // ATTR_ABOVE:"above",//id
            if (view.above) {
                var viewAbove = this.findViewById(view.above);
                if (!viewAbove)
                    throw new Exception(`No se encuentra el view hijo con id [${view.above}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewAbove.elemDom.style.top) - viewAbove.margin.top - view.elemDom.clientHeight - view.margin.bottom) + 'px';
            }
            // ATTR_BELOW:"below",//id
            if (view.below) {
                var viewBelow = this.findViewById(view.below);
                if (!viewBelow)
                    throw new Exception(`No se encuentra el view hijo con id [${view.below}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewBelow.elemDom.style.top) + viewBelow.elemDom.clientHeight + viewBelow.margin.bottom + view.margin.top) + 'px';
            }
            // ATTR_TORIGHTOF:"toRightOf",//id
            if (view.toLeftOf) {
                var viewToLeft = this.findViewById(view.toLeftOf);
                if (!viewToLeft)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toLeftOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                if (view.alignParentLeft === true) {
                    await view.onMeasure(
                        parseInt(viewToLeft.elemDom.style.left) - view.margin.left - view.margin.right,
                        this.elemDom.clientHeight - this.padding.top - this.padding.bottom);
                        // Posiblemente pintar de nuevo la vista de fondo
                }
                else if (view.toRightOf !== null) {
                    console.log("Entrando por aquiiiiiaaaaaaaaaaaaaaaaaai. Pendiente");
                }
                else {
                    view.elemDom.style.left = (parseInt(viewToLeft.elemDom.style.left) - view.elemDom.clientWidth - view.margin.right) + 'px';
                }
            }
            // ATTR_TOLEFTOF:"toLeftOf",//id
            if (view.toRightOf) {
                var viewToRight = this.findViewById(view.toRightOf);
                if (viewToRight === null)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toRightOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);

                view.elemDom.style.left = (
                    parseInt(viewToRight.elemDom.style.left)
                    + viewToRight.margin.left
                    + viewToRight.elemDom.clientWidth
                    + viewToRight.margin.right
                    + view.margin.left) + 'px';
            }

            // verificando si tiene position top
            if (view.elemDom.style.top === "")
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.elemDom.style.left === "")
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            var sum = parseInt(view.elemDom.style.top) + view.getHeight() + this.padding.bottom + view.margin.bottom;
            if (sum > mayHeight)
                mayHeight = sum;
            sum = parseInt(view.elemDom.style.left) + view.getWidth() + this.padding.right + view.margin.right;
            if (sum > mayWidth)
                mayWidth = sum;
        }
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = `${mayHeight}px`;
                await this.repaint();
                break;
            default: break;
        }
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = `${mayWidth}px`;
                await this.repaint();
                break;
            default: break;
        }
    }
};
// Class: src/layout/GridLayout.js
class GridLayout extends ViewGroup {
    constructor(context) {
        super(context);
        this.colums =2;
        this.horizontalSpace = 0;
        this.verticalSpace = 0;
        this.minWidthView = 50;
        this.minHeightView = 20;
    }

    //@Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if (this.width === LayoutInflater.WRAP_CONTENT)
            throw new Exception(`No se permite el ancho dinamico de tipo [${LayoutInflater.WRAP_CONTENT}] para el atributo [width] de la vista [GridLayout]`);

        if (this.getAttrFromNodeXml(nodeXml,"colums"))
            this.colums = parseInt(this.getAttrFromNodeXml(nodeXml,"colums"));
        if (this.getAttrFromNodeXml(nodeXml,"horizontalSpace"))
            this.horizontalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,"horizontalSpace"));
        if (this.getAttrFromNodeXml(nodeXml,"verticalSpace"))
            this.verticalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,"verticalSpace"));
        if (this.getAttrFromNodeXml(nodeXml,"minWidthView"))
            this.minWidthView = parseInt(this.getAttrFromNodeXml(nodeXml,"minWidthView"));
        if (this.getAttrFromNodeXml(nodeXml,"minHeightView"))
            this.minHeightView = parseInt(this.getAttrFromNodeXml(nodeXml,"minHeightView"));
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        // if (nodeXml,LayoutInflater.ATTR_WIDTH) === LayoutInflater.MATCH_PARENT)
        //     throw `No puede establecer un ancho [${LayoutInflater.ATTR_WIDTH}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_HEIGHT) === LayoutInflater.MATCH_PARENT)
            throw `No puede establecer un alto [${LayoutInflater.ATTR_HEIGHT}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeigth){
        let visibles = this.getViewVisibles();
        let maxAnchoView = this.getContentWidth(maxWidth) / this.colums;

        let y = this.padding.top , x;
        let index = 0;
        let mayHeight = 0;

        while(index < visibles.length){
            x = this.padding.left;
            mayHeight = 0;
            for(let j=1; j <=this.colums && index < visibles.length; j++) {
                let view = visibles[index];
                await view.onMeasure(maxAnchoView , maxHeigth);
                view.elemDom.style.top  = `${y}px`;
                view.elemDom.style.left  = `${x}px`;
                x+=maxAnchoView;
                if(view.getHeight()>mayHeight)
                    mayHeight = view.getHeight();
                index++;
            }
            y=y+ mayHeight+this.verticalSpace;
        }

        let maxWidthElement, maxHeightElement;
        y= y + mayHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = y; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            // case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break; // Este caso no se presentara
            default: maxWidthElement = parseFloat(this.width);
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaint();
    }
}
// Class: src/layout/Component.js
class Component extends Container {
    constructor(context){
        super(context);
        this.layoutUrl = null;
        this.context = this;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        let layoutUrl = this.getAttrFromNodeXml(nodeXml,'layoutUrl')||this.layoutUrl;
        if(layoutUrl === null || layoutUrl !== undefined)
            await this.setContentView(layoutUrl);
    }

    async setContentView(layoutUrl){
        if(layoutUrl instanceof View){
            this.setFirstChild(layoutUrl);
            await LayoutInflater.showAllViews(layoutUrl);
        }else{
            this.layoutUrl = layoutUrl;
            let rootXmlNode = await Resource.loadLayoutSync(this.layoutUrl);
            let viewInflate =  await LayoutInflater.inflate(this,rootXmlNode);
            this.setFirstChild(viewInflate);
            await LayoutInflater.showAllViews(viewInflate);
        }
    }

    setData(data){
        this.data = data;
    }

    getContextView(){
        return this;
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeigth) {
        if(this.width !== LayoutInflater.MATCH_PARENT && this.width !== LayoutInflater.WRAP_CONTENT)
            maxWidth = parseFloat(this.width);
        if(this.height !== LayoutInflater.MATCH_PARENT && this.height !== LayoutInflater.WRAP_CONTENT)
            maxHeigth = parseFloat(this.height);

        await this.getFirstChild().onMeasure(
            maxWidth - this.padding.left - this.padding.right,
            maxHeigth - this.padding.top - this.padding.bottom);
 
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + this.getFirstChild().getHeight() + this.padding.bottom; break;
            default: maxHeightElement = maxHeigth;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + this.getFirstChild().getWidth() + this.padding.right; break;
            default: maxWidthElement = maxWidth;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }
};
// Class: src/layout/Form.js
class Form extends Container {
    constructor(context){
        super(context);
    }

    // @Override
    findViewById(idView) {
        let view = super.findViewById(idView);
        if(view)
            return view;
        return this.getFirstChild().findViewById(idView);
    }

    // @Override
    getTypeElement(){
        return 'form';
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if(nodeXml.children.length > 1 || nodeXml.children.length === 0)
            throw new Exception(`El layout [${this.constructor.name}] tiene [${nodeXml.children.length}] vistas y solo es permitido 1 vista.`);

        let nodeChild = nodeXml.children[0];
        let child = await this.parseViewChild(nodeChild);
        if(!(child instanceof Container))
            throw new Exception(`La vista [${child.constructor.name}] no es una extención [Container].`);
        child.parentView = this;
        this.viewsChilds.push(child);
        this.elemDom.appendChild(child.elemDom);
    }

    async parseViewChild(nodeXml) {
        let child = await LayoutInflater.inflate(this.context, nodeXml);
        return child;
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeigth) {
        if(this.width !== LayoutInflater.MATCH_PARENT && this.width !== LayoutInflater.WRAP_CONTENT)
            maxWidth = parseFloat(this.width);
        if(this.height !== LayoutInflater.MATCH_PARENT && this.height !== LayoutInflater.WRAP_CONTENT)
            maxHeigth = parseFloat(this.height);

        await this.getFirstChild().onMeasure(
            maxWidth - this.padding.left - this.padding.right,
            maxHeigth - this.padding.top - this.padding.bottom);
 
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + this.getFirstChild().getHeight() + this.padding.bottom; break;
            default: maxHeightElement = maxHeigth;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + this.getFirstChild().getWidth() + this.padding.right; break;
            default: maxWidthElement = maxWidth;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }

    validate(){

    }
};
// Class: src/layout/RadioGroup.js
class RadioGroup extends LinearLayout{
    constructor(context) {
        super(context);
        this.groupName = Math.random().toString(36).slice(-5);
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        if(!(view instanceof RadioButton))
            throw new Exception(`El [${view.constructor.name}] no es valido para el [${this.constructor.name}]. Utilice únicamente [RadioBUtton]`);
        return view;
    }
}
// Class: src/ux/Page.js
class Page extends Context{
    // viewRoot: null,
    // viewListener: null,
    // urlView: null,
    // history: true,
    // fullScreem: false,
    // previusPage: null,
    // REQUEST_OK: 121,
    // REQUEST_CANCELED: 123,
    // resultCode: this.REQUEST_CANCELED,
    // resultData: null,
    // requestCode: -1,
    // loaded: false,

    constructor(){
        super();
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup) {
            return this.viewRoot.findViewById(idView);
        }
        else
            throw new Exception(`El contenidor principal para la pagina [${this.constructor.name}] no es heredado de ViewGroup`);
    }

    setContentView(objView) {
        if (objView instanceof View)
            this.viewRoot = objView;
        else if(typeof objView==='string')
            this.urlView = objView;
        else{
            throw "La vista debe ser una instancia de View o una url de un archivo XML"
        }
    }

    startLoaded(){
        this.viewRoot.elemDom.style.visibility = 'hidden';
        this.viewRoot.elemDom.style.opacity = 0;
    }

    loadedFinized(){
        this.viewRoot.elemDom.style.transition = "opacity 5s ease-in-out";
        this.viewRoot.elemDom.style.opacity = 1;
        this.viewRoot.elemDom.style.visibility = 'visible';
    }

    async onCreate() { }
    async onStart() { }
    async onDestroy() { }
    async onPause() { }
    async onResume() { }

    setNoHistory(history) {
        this.history = !history;
    }

    async startPage(intent) {
        if (intent === undefined || intent === null)
            throw new Exception("El Intent es nulo o no esta definido");
        // Obtenemos el nodo de la pagina actual
        let resultNode = PageManager.getTreeNodeFromUrl();
        if(resultNode === null){
            let treeNavigation = {
                ROOT: {
                    extras: intent.extras,
                    navigation: {},
                    pageName: intent.pageName
                }
            }
    
            // Guardamos el nodo raiz en el arbol de navegación
            Store.set('TREE',treeNavigation);

            window.location.href = `#/${intent.pageName}`;
    
            // Iniciamos la actividad principal
            await PageManager.startPageFromIntent(intent);
        }
        else{
            // Cargando la pagina
            let newPage = await PageManager.startPageFromIntent(intent);
            // Agregamos a la URL la nueva pagina
            resultNode.navigationList.push(intent.pageName);
    
            PageManager.setUrlBrouser(resultNode.navigationList);
            // Agregamos al arbol la pagina
            resultNode.currentPageNode.navigation[intent.pageName]= {
                extras: intent.getExtras(),
                navigation: {},
                pageName: intent.pageName
            };
    
            // Guardamos el arbol
            Store.set('TREE',resultNode.tree);
        }
    }

    setTitle(title) {
        document.title = title;
    }

    async finish() {
        await PageManager.finishPage(this);
        let resultNode = PageManager.getTreeNodeFromUrl();
        console.log("REUST NODE",resultNode);
        // Removemos del historial la pagina actual
        if(resultNode.parentNode === null){ // Es pagina raiz 
            Store.set('TREE',null);
            resultNode.navigationList.pop();
            PageManager.setUrlBrouser(resultNode.navigationList);
        }else{
            delete resultNode.parentNode.navigation[resultNode.pageName];
            console.log("REUST NODE 2",resultNode);
            // Guardamos el arbol
            Store.set('TREE',resultNode.tree);
            // Actualizamos la URL del navegador
            resultNode.navigationList.pop();
            PageManager.setUrlBrouser(resultNode.navigationList);
        }
    }

    startPageForResult(intent, requestCode) {
        this.requestCode = requestCode;
        this.startPage(intent);
    }

    async onPageResult(requestCode, resultCode, intent) { }
}
// Class: src/ux/Dialog.js
class Dialog{
    constructor(context){
        this.elemBackground = null;
        this.context = context;
        this.bgVisble = true;
        this.bgProgressVisble = true;
        this.resolvePromise = null;

        this.viewRoot = null;
        this.urlView = null;

        this.visible = false;
    }

    setContentView(view) {
        if (view instanceof View)
            this.viewRoot = view;
        else if(typeof view==='string')
            this.urlView = view;
        else
            throw `El contenido enviado [${view}] no es valido para el [Dialog]. Establesca solo una url con XML para el layout o una intancia de View`;
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup) {
            return this.viewRoot.findViewById(idView);
        }
        else
            throw new Exception(`El contenidor principal para el Dialogo [${this.constructor.name}] no es heredado de ViewGroup`);
    }

    showBackground(show){
        this.bgVisble = show;
    }

    showBackgroundProgress(show){
        this.bgProgressVisble = show;
    }

    async onStart(){

    }

    isVisible(){
        return this.visible;
    }

    async show(){
        var this_ = this;
        return new Promise((resolve,reject)=>{
            this_.resolvePromise = resolve;
            (async () => {
                // Creamos un fondo opaco para el dialogo
                let pageAnimation = null;
                if (this_.bgVisble === true) {
                    this_.elemBackground = document.createElement('div');

                    // Margenes por defector
                    this_.elemBackground.style.marginTop = '0px';
                    this_.elemBackground.style.marginLeft = '0px';
                    this_.elemBackground.style.marginBottom = '0px';
                    this_.elemBackground.style.marginRight = '0px';
                    // Padding por defecto
                    this_.elemBackground.style.paddingTop = '0px';
                    this_.elemBackground.style.paddingLeft = '0px';
                    this_.elemBackground.style.paddingBottom = '0px';
                    this_.elemBackground.style.paddingRight = '0px';
                    this_.elemBackground.style.position = "absolute";
                    this_.elemBackground.style.width = "100%";
                    this_.elemBackground.style.height = "100%";

                    this_.elemBackground.style.backgroundColor = "rgba(30, 30, 30, 0.7)";
                    document.body.appendChild(this_.elemBackground);
                }
                
                if(this_.bgProgressVisble){
                    // Cargando la vista
                    pageAnimation = new SpinnerAnimation();
                    pageAnimation.show();
                }
                

                // Verificamos si tiene contenido la pagina
                if(this_.viewRoot || this_.urlView)
                    ; // Contenido definido
                else{
                    reject(new Exception(`El dialogo [${this_.constructor.name}] no tiene contenido definido. Asigne uno con [setContentView]`));
                    if(pageAnimation)
                        pageAnimation.hide();
                    return;
                }
                if(this_.viewRoot === null){
                    let rootXml = await Resource.loadLayoutSync(this_.urlView);
                    this_.viewRoot = await LayoutInflater.inflate(this_,rootXml);
                }

                document.body.appendChild(this_.viewRoot.elemDom);
                // page.startLoaded(); // Iniciando carga
        
                let windowsDimension = PageManager.getWindowsDimension();
                await this_.viewRoot.loadResources();
                await this_.viewRoot.onMeasure(windowsDimension.width, windowsDimension.height);

                // Centramos el dialogo
                this.setPosition(windowsDimension);
                if(pageAnimation)
                    pageAnimation.hide();

                // Mostrando todos los elementos
                await LayoutInflater.showAllViews(this_.viewRoot);

                this_.onStart();
                this.visible = true;
            })();
        });
    }

    setPosition(windowsDimension){
        this.viewRoot.elemDom.style.left = (windowsDimension.width / 2 - this.viewRoot.getWidth() / 2) + 'px';
        this.viewRoot.elemDom.style.top = (windowsDimension.height / 2 - this.viewRoot.getHeight() / 2) + 'px';
    }

    async cancel(params){
        if(this.viewRoot && this.viewRoot.elemDom)
            this.viewRoot.elemDom.remove();
        if (this.bgVisble === true)
            this.elemBackground.parentNode.removeChild(this.elemBackground);
        if(this.resolvePromise)
            this.resolvePromise(params);
        this.visible = false;
    }

    getViewRoot(){
        return this.viewRoot;
    }

    getContext(){
        return this.context;
    }
};
// Class: src/ux/PopupWindow.js
class PopupWindow extends Dialog{
    constructor(context) {
        super(context)
        this.position = "left|top";
        this.view = null;
        this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
        this.showBackground(false);
        this.showBackgroundProgress(false);
    }

    setPositionOnView(position) {
        this.position = position;
    }

    setView(view) {
        this.view = view;
    }

    getView(){
        return this.view;
    }

    // @Override
    setPosition(windowsDimension){
        // super.setPosition(windowsDimension);
        let rectView = this.view.elemDom.getBoundingClientRect();
        for(let posItem of this.position.split('|')){
            switch(posItem){
                case 'left':
                    this.viewRoot.elemDom.style.left = (rectView.left) + 'px';
                    break;
                case 'right':
                    this.viewRoot.elemDom.style.left = ( rectView.left + this.view.getWidth() - this.viewRoot.getWidth()) + 'px';
                    break;
                case 'top':
                    this.viewRoot.elemDom.style.top = (rectView.top - this.viewRoot.getHeight()) + 'px';
                    break;
                case 'bottom':
                    this.viewRoot.elemDom.style.top = (rectView.top + this.view.getHeight() - this.viewRoot.getHeight()) + 'px';
                    break;
            }
        }
    }
};
// Class: src/widget/Toast.js
class Toast{
    static LENGTH_SHORT = 1000;
    static LENGTH_LONG = 5000;
 
    static async makeText(context, message, length){
        let dialog = new Dialog(context);
        dialog.showBackground(false);
        dialog.showBackgroundProgress(false);
        let txtMessage = new TextView(context);
        txtMessage.setBackground("lib/imgs/bg_toast.9.png");
        txtMessage.setText(message);
        txtMessage.setSingleLine(true);
        txtMessage.setTextColor('#EC9D52');
        dialog.setContentView(txtMessage);

        dialog.show();
        await Thread.sleep(length);
        dialog.cancel();
    }
}