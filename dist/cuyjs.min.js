// Class: src/core/lang/Exception.js
class Exception extends Error{
    // message = null
    constructor(message){
        super(message);
        this.message = message;
    }

    toString(){
        return this.message;
    }
};
// Class: src/core/lang/Runnable.js
class Runnable {
    constructor(methodRun) {
        this.run = methodRun;
    }

    async run(){
        
    }
}
// Class: src/core/lang/Thread.js
class Thread {
    constructor(runnableObject) {
        this.runnableObject = runnableObject;
        this.promise = null;
    }

    start(){
        var this_ = this;
        (async () => {
            this_.promise = this_.runnableObject.run();
        })();
    }

    interrupt(){
        if(this.promise)
            this.promise.reject("Hilo interrumpido");
    }

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static async sleep(miliseconds) {
        return new Promise(resolve => {
            setTimeout(resolve, miliseconds);
        });
    }
}
// Class: src/core/lang/Timer.js
class Timer {
    constructor(runnableObject,period) {
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
    }

    schedule(runnableObject,period){
        this.runnableObject = runnableObject;
        this.intervalId = null;
        this.period = period;
        this.start();
    }

    isRunning(){
        return this.intervalId!=null;
    }

    start(){
        if(this.intervalId)
            throw new Error(`El Timer ya se encuentra en ejecución.`);
        var this_ = this;
        this.intervalId = setInterval(function(){
            this_.runnableObject.run();
        }, this.period);
    }

    stop(){
        if(this.intervalId)
            clearInterval(this.intervalId);
        this.intervalId = null;
    }
}
// Class: src/core/lang/Store.js
class Store {
    static get(keyName,defaultValue){
        if(!Store.containsKey(keyName))
            Store.set(keyName,defaultValue);
        Store.checkIfExists(keyName);
        let data = JSON.parse(sessionStorage.getItem(keyName));
        if(data.type)
            return data.value;
        return data;
    }

    static set(key,value){
        sessionStorage.setItem(key,JSON.stringify({
            type: typeof value,
            value
        }));
    }

    static checkIfExists(keyName){
        if(!Store.containsKey(keyName))
            throw new Exception(`No existe el atributo [${keyName}]`);
    }

    static containsKey(keyName){
        return (sessionStorage.getItem(keyName))?true:false;
    }
}
// Class: src/util/FileChooser.js
class FileChooser{
    static async readFileInBase64(file){
        return await new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onload = function (evt) {
                //                    var parser = new DOMParser();
                var contents = evt.target.result;
                // El contenido se encuentra en Base64
                // application/octet-stream;base64,UEsDBBQAAAgIAEe8.....
                let posBase = contents.indexOf(',');
                contents = posBase === -1 ? contents : contents.substr(posBase + 1);
                //                    var doc = parser.parseFromString(contents, "application/xml");
                let fileNameSelected = file.name;
                resolve({
                    fileName: fileNameSelected,
                    fileExt: fileNameSelected.substring(fileNameSelected.lastIndexOf('.')+1),
                    dataInBase64: contents,
                    size: file.size,
                    lastModified: file.lastModified
                });
                //                    cbSelected(doc.documentElement);
            };
            reader.onerror = function (error) {
                reject(error);
            },
                //                reader.readAsBinaryString(domoInput.files[0],"UTF-8");
            reader.readAsDataURL(file);
        });
    }

    static async showSelectFile(types) {
        /*
        private String fileName;
        private String fileExt;
        private Integer size;
        private String dataInBase64;
        private long lastModified;*/
        return await new Promise((resolve) => {
            var domoInput = document.createElement("input");
            domoInput.setAttribute('type', "file");
            domoInput.style.visibility = "hidden";
            domoInput.setAttribute('accept', types);

            document.body.appendChild(domoInput);
            domoInput.click();
            domoInput.onchange = function () {
                let file = domoInput.files[0];
                domoInput.remove();
                resolve(file);
            };
        });
    }

    static async showSaveFile(fileName, content){
        let blobData = new Blob([content], {type: "text/plain"});
        let url = window.URL.createObjectURL(blobData);

        let a = document.createElement("a");
        a.style = "display: none";
        document.body.appendChild(a);
        a.href = url;
        a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
    }
};
// Class: src/core/net/HttpRequest.js
class HttpRequest {
    // this.url
    // params
    // data
    // xmlhttp
    constructor(url) {
        this.url = url;
        this.params = new Array();
        this.headers = new Headers();
        this.controller = new AbortController();
        this.signal = this.controller.signal;
        this.blockDomElem=null;
    }

    blockTo(view){
        if(view instanceof View){
            this.blockDomElem = view.elemDom;
        }else if(view instanceof Dialog){
            this.blockDomElem = view.viewRoot.elemDom;
        }else if(view instanceof Page){
            this.blockDomElem = view.viewRoot.elemDom;
        }else
            throw new Exception(`Se enviar uno de los siguiente parámetros [view,Dialog o Page]. Y se envio [${view}]`);            
    }

    setEntity(d) {
        console.log("Estableciendo POST",d);
        this.data = d;
    }

    getMethod() {return null;}

    addParam(name, value) {
        this.params[name] = value;
    }

    addHeader(name, value) {
        this.headers.append(name, value);
    }

    async execute(){
        let bgView = null;
        if(this.blockDomElem){
            let rectView = this.blockDomElem.getBoundingClientRect();
            // Creando fondo de vista
            this.blockDomElem.style.filter = "blur(5px)";

            bgView = document.createElement('div');
            bgView.style.marginTop = '0px';
            bgView.style.marginLeft = '0px';
            bgView.style.marginBottom = '0px';
            bgView.marginRight = '0px';
            // Padding por defecto
            bgView.style.paddingTop = '0px';
            bgView.style.paddingLeft = '0px';
            bgView.style.paddingBottom = '0px';
            bgView.style.paddingRight = '0px';
            bgView.style.position = "absolute";
            bgView.style.width = this.blockDomElem.clientWidth+'px';
            bgView.style.height = this.blockDomElem.clientHeight+'px';
            bgView.style.filter = "blur(3px)";
            bgView.style.backgroundColor = "rgba(30, 30, 30, 0.7)";

            bgView.onclick=async ()=>{
                return false;
            };
            bgView.onmouseenter=async ()=>{
                return false;
            };

            // Agregando el spinner
            let MAX = 150;
            let maxSize = Math.min(this.blockDomElem.clientHeight,MAX);

            let animation = new SpinnerAnimation({
                left: this.blockDomElem.clientWidth/2-maxSize/2,
                top: 0,
                size: maxSize, 
                showBackground: false,
                backgroundRotation: false,
                parentElement: bgView
            });
            bgView.style.left = (rectView.left) + 'px';
            bgView.style.top = (rectView.top) + 'px';
            document.body.appendChild(bgView);
            animation.show();
        }
        let resutl =await this.send();
        if(this.blockDomElem){
            this.blockDomElem.style.filter = "none";
            bgView.remove();
        }
        return resutl;
    }

    async send() {
        let filter = await AjaxFilters.verifUrl(this);
        let url = this.url;
        if (this.params.length > 0) {
            if(url.indexOf('?')===-1)
                url = url + '?';
            for (let elem in this.params) {
                url = (url + (elem + '=' + this.params[elem]) + "&&");
            }
            url = url.substring(0, url.length - 2);
        }
        if(this.data && (typeof this.data==='object'))
            this.addHeader('Content-Type','application/json');

        const response = await fetch(url, {
            method: this.getMethod(),
            //mode: 'no-cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            headers: this.headers,
            credentials: 'include',
            //redirect: 'follow', // manual, *follow, error
            //referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
            body: this.data?JSON.stringify(this.data):undefined, // body data type must match "Content-Type" header
            signal: this.signal
        });

        let httpResponse = new HttpResponse(response);
        if(filter)
            await filter.onPostExecute(httpResponse);
        return httpResponse;
    }

    abort() {
        this.controller.abort();
    }
}
// Class: src/core/net/HttpResponse.js
class HttpResponse {
    constructor(response) {
        this.response = response;
    }

    async getJson() {
        return await this.response.json()
    }

    async getRootElementXml() {
        let text = await this.response.text();
        return (new window.DOMParser()).parseFromString(text, "text/xml");
    }

    async getText() {
        return await this.response.text();
    }
}
// Class: src/core/net/HttpGet.js
class HttpGet extends HttpRequest{
    // @Override
    getMethod(){
        return "GET"; 
    }
}
// Class: src/core/net/HttpPost.js
class HttpPost extends HttpRequest{
    // @Override
    getMethod(){
        return "POST"; 
    }
}
// Class: src/core/net/HttpPut.js
class HttpPut extends HttpRequest{
    // @Override
    getMethod(){
        return "PUT"; 
    }
};
// Class: src/core/net/HttpDelete.js
class HttpDelete extends HttpRequest{
    // @Override
    getMethod(){
        return "DELETE"; 
    }
}
// Class: src/core/net/handler/Filter.js
class Filter{
    async onPreExecute(httpRequest){
        return true;
    }
    
    async onPostExecute(httpResponse){
        return true;
    }
}
// Class: src/core/net/handler/AjaxFilters.js
class AjaxFilters{
    static filters = new Array();

    static addFilter(patternUrl,filter){
        AjaxFilters.filters.push({
            patternUrl,
            filter
        });
    }

    static async verifUrl(httpRequest){
        // '/services/**', '/services/puerto/java'
        let itemFilter = AjaxFilters.filters.find(filterItem=>{
            return httpRequest.url.includes(filterItem.patternUrl);
        });
        if(itemFilter){
            await itemFilter.filter.onPreExecute(httpRequest);
            return itemFilter.filter;
        }
        return null;
    }
}
// Class: src/core/Context.js
class Context{
    async onResize(){}

    static LAYOUT_COMPACT="Compact";
    static LAYOUT_MEDIUM="Medium";
    static LAYOUT_EXPANDED="Expanded";
    static LAYOUT_BIG="Big";

    getLayoutByScreenDimension(pathLayout,layoutSuported){
        // layoutSuported = [Context.LAYOUT_COMPACT,Context.LAYOUT_EXPANDED]
        // pathLayout = pages/home/HomeLayoutBig.xml
        let layoutName = null;
        if(pathLayout.includes(Context.LAYOUT_COMPACT))
            layoutName = pathLayout.substring(0, pathLayout.length - Context.LAYOUT_COMPACT.length- '.xml'.length);
        else if(pathLayout.includes(Context.LAYOUT_MEDIUM))
            layoutName = pathLayout.substring(0, pathLayout.length - Context.LAYOUT_MEDIUM.length- '.xml'.length);
        else if(pathLayout.includes(Context.LAYOUT_EXPANDED))
            layoutName = pathLayout.substring(0, pathLayout.length - Context.LAYOUT_EXPANDED.length- '.xml'.length);
        else if(pathLayout.includes(Context.LAYOUT_BIG))
            layoutName = pathLayout.substring(0, pathLayout.length - Context.LAYOUT_BIG.length- '.xml'.length);
        else
            return pathLayout;
        let screenSize = this.getScreenSize();
        let width = screenSize.width;
        if(this.getScreenOrientation() === 'VERTICAL')
            width = screenSize.height;
        if(Array.isArray(layoutSuported)){
            if(width <30 && layoutSuported.find(Context.LAYOUT_COMPACT)){ // COMPACTO (CELULARES)
                return `${layoutName}${Context.LAYOUT_COMPACT}.xml`;
            }else if(width < 40 && layoutSuported.find(Context.LAYOUT_MEDIUM)){ // MEDIANO (TABLETS)
                return `${layoutName}${Context.LAYOUT_MEDIUM}.xml`;
            }else if(width < 60 && layoutSuported.find(Context.LAYOUT_EXPANDED)){ // EXPANDEND (LAPTOPS O PC)
                return `${layoutName}${Context.LAYOUT_EXPANDED}.xml`;
            }else{ // BIG (TELEVISORES O MONITORES GRANDES)
                return `${layoutName}${Context.LAYOUT_BIG}.xml`;
            }
        }else{
            if(width < 30){ // COMPACTO (CELULARES)
                return `${layoutName}${Context.LAYOUT_COMPACT}.xml`;
            }else if(width < 40){ // MEDIANO (TABLETS)
                return `${layoutName}${Context.LAYOUT_MEDIUM}.xml`;
            }else if(width < 60){ // EXPANDEND (LAPTOPS O PC)
                return `${layoutName}${Context.LAYOUT_EXPANDED}.xml`;
            }else{ // BIG (TELEVISORES O MONITORES GRANDES)
                return `${layoutName}${Context.LAYOUT_BIG}.xml`;
            }
        }
    }

    getScreenSize(){
        let dpival = this.getPPI();
        return {
            width: ((window.screen.width * window.devicePixelRatio)/dpival)*2.54,
            height: ((window.screen.height * window.devicePixelRatio)/dpival)*2.54
        };
    }
    
    getScreenOrientation(){
        if(screen.orientation.type && screen.orientation.type.includes('landscape'))
            return 'HORIZONTAL';
        return 'VERTICAL';
    }
    
    getPPI() {
        // <div id='testdiv' style='height: 1in; left: -100%; position: absolute; top: -100%; width: 1in;'></div>
        let div = document.createElement("div");
        div.style.width = '1in';
        div.style.height = '1in';
        div.style.left = '-100%';
        div.style.top = '-100%';
        div.style.position = 'absolute';
        div.style.margin = 0;
        div.style.border = 'none';
        let body = document.getElementsByTagName("body")[0];
        body.appendChild(div);
        let devicePixelRatio = window.devicePixelRatio || 1;
        let ppi = Math.round(div.offsetWidth * devicePixelRatio);
        body.removeChild(div);
        return ppi;
    }

    setOnClickListenerTo(idView,onClickListener){
        if(idView instanceof View)
            idView.setOnClickListener(onClickListener, this);
        else{
            let view = this.viewRoot.findViewById(idView);
            view.setOnClickListener(onClickListener, this);
        }
    }
};
// Class: src/core/Resource.js
class Resource{
    static listThemes = new Array();

    static async loadTheme(urlTheme) {
        let rootXml = await this.loadLayoutSync(urlTheme);
        let styleObject = {};
        for (let index = 0; index < rootXml.children.length; index++){
            // <style name="PageTheme" parent="Page"></style>
            let styleChildNode = rootXml.children[index];
            let viewName = styleChildNode.getAttribute("view");
            styleObject[viewName] = {};

            for (let indexJ = 0; indexJ < styleChildNode.children.length; indexJ++){
                //<item name="textColor">#808080</item>
                let attrChildNode = styleChildNode.children[indexJ];
                let name = attrChildNode.getAttribute("name");
                let value = attrChildNode.textContent;
                if(value === "true" || value === "false")
                    styleObject[viewName][name] = value === "true";
                else
                    styleObject[viewName][name] = value;
            }
        }
        Resource.THEME = styleObject;
    }

    static getAttrOfTheme(themeName, name, value){
        if(value === undefined)
            value = null;
        let theme = Resource.THEME;
        if(theme[themeName]){
            if(theme[themeName][name]!== null && theme[themeName][name]!== undefined){
                return theme[themeName][name];
            }
            return value;
        }
        return value;
    }

    static async importJs(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].src && scripts[i].src.lastIndexOf(url)!==-1){
                    resolve(scripts[i]);
                    return;
                }
            }
            
            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
            script.async = true;
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            // script.onload = callback;
            script.addEventListener('load',()=>{
                resolve(script);
            },false);
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async importCss(url) {
        return await new Promise(function (resolve, reject) {
            // Verificamos antes si el script ya fue cargado
            var scripts = document.getElementsByTagName("link");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].href && scripts[i].href.lastIndexOf(url) !== -1){
                    resolve(scripts[i]);
                    return;
                }
            }

            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('link');
            script.type = 'text/css';
            script.href = url;
            script.rel='stylesheet';
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve(script);
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };

    static async import(url){
        if(url.lastIndexOf(".js")!==-1)
            return await this.importJs(url);
        else if(url.lastIndexOf(".css")!==-1)
            return await this.importCss(url);
        else
            throw new Error(`Tipo de archivo [${url}] no soportado. utilice unicamente .js o .css`);
    }
    
    static async importAll(urls) {
        if (Array.isArray(urls) === false)
            throw "Lista de urls vacio para [loadAllScripts]";
        for(let url of urls){
            await Resource.importJs(url);
        }
    };
    
    static async loadLayoutSync(urlXmlLayout){
        let rootXml = await new Promise(function(resolve,reject){
            var xmlhttp;
            if (window.XMLHttpRequest)
                xmlhttp = new XMLHttpRequest();
            else
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4) {
                    if (xmlhttp.status === 200 ||xmlhttp.status === 0) { // Habilitado para archivos en local host (||xmlhttp.status === 0)
                        resolve(xmlhttp.responseXML.documentElement);
                    } else {
                        reject(xmlhttp.statusText);
                    }
                }
            };
            xmlhttp.open("GET", urlXmlLayout, true);
            xmlhttp.send(null);
        });
        return rootXml;
    }

    static async loadImage(urlOrTextBase64){
        if(!urlOrTextBase64)
            throw "No se envió la imagen para la carga";
        if(typeof urlOrTextBase64 !== 'string')
            throw "El parámetro para cargar la imagen no es de tipo texto";
        let imageProm = await new Promise(function(resolve,reject){
            var image = new Image();
            image.onload = function(){
                resolve(image);
            }
            image.src =urlOrTextBase64;
        });
        return imageProm;
    }

    static isBase64Resource(urlOrTextBase64){
        return /data:image\/([a-zA-Z]*);base64,([^\"]*)/g.test(urlOrTextBase64);
    }

    static isImageNinePathResource(urlOrTextBase64){
        return /\.9\.(png|gif)/i.test(urlOrTextBase64);
    }

    static isImageResource(urlOrTextBase64){
        return /\.(jpe?g|png|gif|bmp|svg)$/i.test(urlOrTextBase64);
        //return /.(png|gif|jpg|svg)/i.test(urlOrTextBase64);
    }

    static isColorResource(hexColorText){
        return /^#[0-9A-F]{6}$/i.test(hexColorText);
    }

    static async waitToLoadAllResources(){
        await new Promise(function(resolve){
            let callback = function(){
                resolve();
            };

            if (window.attachEvent){
                window.attachEvent('onload', callback);
            }
            else if (window.addEventListener){
                window.addEventListener('load', callback, false);
            }
            else{
                document.addEventListener('load', callback, false);
            }
        });
    }

    static async screnshot(element, posX, posY, width, height){
        /*
        html2canvas(element, {
            onrendered: function (canvas) {
                var context = canvas.getContext('2d');
                var imageData = context.getImageData(posX, posY, width, height).data;
                var outputCanvas = document.createElement('canvas');
                var outputContext = outputCanvas.getContext('2d');
                outputCanvas.width = width;
                outputCanvas.height = height;
    
                var idata = outputContext.createImageData(width, height);
                idata.data.set(imageData);
                outputContext.putImageData(idata, 0, 0);
                callback(outputCanvas.toDataURL().replace("data:image/png;base64,", ""));
            },
            width: width,
            height: height,
            useCORS: true,
            taintTest: false,
            allowTaint: false
        });*/
    }
}
// Class: src/core/PageManager.js
class PageManager {
    static getUrlBrouser(){
        let urlBrouser = window.location.href;
        return urlBrouser;
    }

    static getQueryParams(){
        let urlParams = new URLSearchParams(location.search);
        let params = {};
        for (let [key, value] of urlParams) {
            params[key] = value;
        }
        return params;
    }

    static setUrlBrouser(pageNames){
        window.location.href = `#/${pageNames.join('/')}`;
    }

    // pageNames
    static getArrayNavegation(){
        let urlBrouser = PageManager.getUrlBrouser();

        if(urlBrouser.lastIndexOf('#/') !== -1) {
            let listPages = urlBrouser.substring(urlBrouser.lastIndexOf('#/')+2);
            let posQuery = listPages.indexOf('?');
            if(posQuery != -1)
                listPages = listPages.substring(0,posQuery);
            return listPages.split('/');
        }
        return new Array();
    }

    static async startApp(manifestConfig){
        Resource.MANIFEST = manifestConfig;
        window.onload=(async ()=>{
            // Cargando tema
            await Resource.loadTheme(manifestConfig.theme);

            // Establecemos los valores correspondientes para los componentes HTML, BODY
            await PageManager.configApp();

            let navigationList = PageManager.getArrayNavegation();
            
            if(navigationList.length > 0){
                let mainPageName = navigationList[0];
                // Iniciamos la actividad principal
                let intent = new Intent(null, mainPageName);

                await PageManager.startPageFromIntent(intent);
                return;
            }
            
            // Validando manifest
            let mainPageName = PageManager.findRootPageName(manifestConfig);

            // Iniciamos la actividad principal
            let intent = new Intent(null, mainPageName);
            await PageManager.startPageFromIntent(intent);
        });
    }

    static findRootPageName(manifestConfig){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.category==='ROOT');
        if(!pageConfig){
            throw new Exception(`No se encontro nin una pagina principal. Categorice la pagina agregando el atributo [category=='ROOT'] en el Manifest`);
        }
        let posBarra = pageConfig.name.lastIndexOf('/');
        let pageName = pageConfig.name.substring(posBarra+1,pageConfig.name.lastIndexOf('.js'));
        return pageName;
    }

    static findPageConfig(manifestConfig,pageName){
        let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.name.lastIndexOf(`/${pageName}.js`) !== -1);
        if(!pageConfig){
            throw new Exception(`No se encontro la página [${pageName}] en la configuración del Manifest`);
        }
        return pageConfig;
    }

    static async configApp() {
        // Eliminamos margenes y padding del contenedor principal (body,html)
        document.body.style.paddingBottom = '0px';
        document.body.style.paddingTop = '0px';
        document.body.style.paddingLeft = '0px';
        document.body.style.paddingRight = '0px';
        document.body.style.margin = '0px';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
        document.body.style.position = 'absolute';

        // DESABILITAR ELEMENTOS NO SELECCIONABLES
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        //padding: 4px 20px;
        sheet.innerHTML = `html,body,div,span,img{
                                                    -webkit-user-select: none;
                                                    -khtml-user-select: none;
                                                    -moz-user-select: none;
                                                    -o-user-select: none;
                                                    -ms-user-select: none;
                                                    user-select: none;
                                                }
                                                `;
        document.body.appendChild(sheet);
        
        // MULTIDIMENSION
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        sheet.innerHTML = `@keyframes rotate{from {rotate:360deg;} to {rotate:0deg;}}
                           @-moz-keyframes rotate-record {0%   {-moz-transform: rotate(360deg);}100% {-moz-transform: rotate(0deg);}}
                           .rotate {-webkit-animation:rotate-record .8s infinite linear;-moz-animation:rotate-record .8s infinite linear;}`;

        document.body.appendChild(sheet);
    }

    static async startPageFromIntent(intent) {
        // Buscamos y verificamos si la pagina este presente en el Manifest
        let manifestConfig = Resource.MANIFEST;
        // let pageConfig = manifestConfig.pages.find((pageConfig)=>pageConfig.className === intent.pageName);
        let pageConfig = PageManager.findPageConfig(manifestConfig,intent.pageName);

        // Importamos el script
        await Resource.import(pageConfig.name);

        // Instanciamos la Pagina
        var page = null;
        try {
            page = eval(`new ${intent.pageName}()`);
        }
        catch (o) {
            throw new Exception("No existe la pagina [" + intent.pageName + "]");
        }
        page.context = intent.context;
        await PageManager.loadPage(page, intent);
        return page;
    }

    // proProgress:{left:?,top:?,width,height,showBackground:true}
    static async loadPage(page, intent) {
        // LLamamos el on create de la pagina
        await page.onCreate(intent);
        let pageAnimation = new SpinnerAnimation();
        pageAnimation.show();
        // Verificamos si tiene contenido la pagina
        if(!page.viewRoot && !page.urlView)
            throw new Exception(`La pagina [${page.constructor.name}] no tiene contenido definido. Asigne un contenido con page.setContentView`);
        if(page.urlView){ // La pagina cargara los elementos a partir de una URL
            let rootXml = await Resource.loadLayoutSync(page.urlView);
            page.viewRoot = await LayoutInflater.inflate(page,rootXml);
        }

        document.body.appendChild(page.viewRoot.elemDom);
        // page.startLoaded(); // Iniciando carga
        await page.viewRoot.loadResources();
        await page.onResize();

        page.loadedFinized(); // Carga finalizada
        pageAnimation.hide();

        // Guardamos la pagina actual en la URL
        document.title = page.constructor.name;

        // history.pushState({}, null, newUrlIS);
        // Mostrando todos los elementos
        page.viewRoot.showView();

        // Agregamos el evento redimensionamiento
        window.addEventListener('resize', async () => {
            await page.onResize();
        });

        await page.onStart();
    }

    static async finishPage(context) {
        // Eliminamos el componente
        let element = context.viewRoot.elemDom;
        element.parentNode.removeChild(element);

        // Removemos el listener
        console.log("Removiendo listener");
        window.removeEventListener('resize', async () => {
            console.log("Listener removido");
        });

        // Eliminamos del historial
        await context.onDestroy();
    }

    static getWindowsDimension() {
        //        return {
        //                    width:document.body.clientWidth,
        //                    height:document.body.clientHeight
        //               };
        let dim = {
            width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
            height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
        };
        return dim;
    }
}
// Class: src/core/Intent.js
class Intent{
    // context
    // pageName
    constructor(context, pageName){
        this.extras = {};
        this.context= context;
        this.pageName = pageName;
    }

    setExtras(extras){
        this.extras = extras;
    }

    putExtra(name, value) {
        this.extras[name] = value;
    }
    getExtra(name) {
        return this.extras[name];
    }

    getExtras(){
        return this.extras;
    }
}
// Class: src/core/LayoutInflater.js
class LayoutInflater{
    // Atributos generales para los layouts
    static ATTR_WIDTH = "width";
    static ATTR_HEIGHT= "height";
    static ATTR_GRAVITY= "layoutGravity";

    static ATTR_GRAVITY_LEFT = "left";
    static ATTR_GRAVITY_RIGHT = "right";
    static ATTR_GRAVITY_TOP = "top";
    static ATTR_GRAVITY_BOTTOM = "bottom";
    static ATTR_GRAVITY_CENTER = "center";
    static ATTR_GRAVITY_CENTER_H = "center_horizontal";
    static ATTR_GRAVITY_CENTER_V = "center_vertical";

    static ATTR_MARGIN= "margin";
    static ATTR_MARGIN_TOP= "marginTop";
    static ATTR_MARGIN_LEFT= "marginLeft";
    static ATTR_MARGIN_RIGHT= "marginRight";
    static ATTR_MARGIN_BOTTOM= "marginBottom";

    static ATTR_PADDING= "padding";
    static ATTR_PADDING_TOP= "paddingTop";
    static ATTR_PADDING_LEFT= "paddingLeft";
    static ATTR_PADDING_RIGHT= "paddingRight";
    static ATTR_PADDING_BOTTOM= "paddingBottom";

    static ATTR_ON_CLICK= "onClick";
    static ATTR_BACKGROUND= "background";
    // Utilizado solo en LinearLayout
    static ATTR_WEIGHT= "weight";

    // Atributos de RelativeLayout
    static ATTR_ALIGNPARENTLEFT= "alignParentLeft";// true;false
    static ATTR_ALIGNPARENTTOP= "alignParentTop";//true;false
    static ATTR_ALIGNPARENTRIGHT= "alignParentRight";//true;false
    static ATTR_ALIGNPARENTBOTTOM= "alignParentBottom";//true;false

    static ATTR_CENTERHORIZONTAL= "centerHorizontal";//true;false
    static ATTR_CENTERVERTICAL= "centerVertical";//true;false
    static ATTR_CENTERINPARENT= "centerInParent";//true;false

    static ATTR_ABOVE= "above";//id
    static ATTR_BELOW= "below";//id

    static ATTR_TORIGHTOF= "toRightOf";//id
    static ATTR_TOLEFTOF= "toLeftOf";//id

    static ATTR_MIN_WIDTH= "minWidth";
    static ATTR_MIN_HEIGHT= "minHeight";

    // TextView
    static ATTR_TEXT= "text";
    static ATTR_DRAWABLE_LEFT= "drawableLeft";
    static ATTR_DRAWABLE_TOP= "drawableTop";
    static ATTR_DRAWABLE_BOTTOM= "drawableBottom";
    static ATTR_DRAWABLE_RIGHT= "drawableRight";

    // vista
    static ATTR_VISIBILITY= "visibility";

    // Valores que pueden tomar los atributos
    static MATCH_PARENT= "match_parent";
    static WRAP_CONTENT= "wrap_content";
    static LEFT= "left";
    static RIGHT= "right";
    static BOTTOM= "bottom";
    static CENTER_HORIZONTAL= "center_horizontal";
    static CENTER_VERTICAL= "center_vertical";
    static CENTER= "center";
    static TOP= "top";

    static VISIBLE= "visible";
    static INVISIBLE= "invisible";
    static GONE= "gone";

    static REGEX_VARS = /\{\{([a-zA-Z_.\d\(\)]*)\}\}+/g;

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static async parse(context, firstElement,model) {
        var view = null;
        try {
            view = eval(`new ${firstElement.tagName}(context,model)`);
        }
        catch (o) {
            throw new Exception("No existe la vista [" + firstElement.tagName + "]");
        }
        await view.parse(firstElement);
        return view;
    }

    static async inflate(context,xmlRoot,model) {
        if(!context)
            throw new Exception('No se envió el parametro [context] en el metodo [LayoutInflate.inflate]');
        if(typeof xmlRoot === 'object' && xmlRoot instanceof Element)
             return await this.parse(context, xmlRoot, model);
        else if(typeof xmlRoot === 'string'){
            let xml = await Resource.loadLayoutSync(xmlRoot);
            return await this.parse(context, xml, model);
        }
        throw new Exception(`El [${xmlRoot}] no es valido`);
    }
}
// Class: src/view/background/BaseBackground.js
class BaseBackground{
    constructor(view,domElement){
        this.view = view;
        this.domElement = domElement;
    }
    async load(){}
    async paint(){}
}
// Class: src/view/background/ColorBackground.js
class ColorBackground extends BaseBackground{
    constructor(view,domElement,color){
        super(view,domElement);
        this.color= color;
    }
    async load(){
        this.domElement.style.background = this.color;
    }
    async paint(){}
}
// Class: src/view/background/EmplyBackground.js
class EmplyBackground extends BaseBackground{
    constructor(view,domElement){
        super(view,domElement);
    }
    async load(){
        this.domElement.style.background='none';
        this.domElement.style.backgroundColor = 'transparent'; 
    }
    async paint(){}
}
// Class: src/view/background/ImageBackground.js
class ImageBackground extends BaseBackground{
    constructor(view,domElement,urlOrBase64Image){
        super(view,domElement);
        this.urlOrBase64Image = urlOrBase64Image;
    }

    async load(){
        if(Resource.isImageResource(this.urlOrBase64Image)){
            this.domElement.style.background = `url('${this.urlOrBase64Image}')`;
            var this_ = this;
            await new Promise(function(resolve, reject){
                var img = new Image();
                try {
                    img.addEventListener('load', function() {
                        resolve();
                    }, false);
                    img.addEventListener('error', function() {
                        reject(`Error al obtener la imagen [${this.urlOrBase64Image}]`);
                    }, false);
                }
                catch(error) {
                    resolve(error);
                }
                img.src = this_.urlOrBase64Image;
            });
            this.domElement.style.backgroundSize = `${this.domElement.clientWidth}px ${this.domElement.clientHeight}px`;
        }
        else
            this.domElement.style.background = `data:image/png;base64,${urlOrBase64Image}`;
        // auto|length|cover|contain|intial|inherit
        this.domElement.style.backgroundRepeat = 'no-repeat';
        this.domElement.style.backgroundOrigin = "content-box";
    }

    async paint(){
        this.domElement.style.backgroundSize = `${this.domElement.clientWidth}px ${this.domElement.clientHeight}px`;
    }
}
// Class: src/view/background/NinepathBackground.js
class NinepathBackground extends BaseBackground{
    constructor(view,domElement,imageNinePathBase64){
        super(view,domElement);
        // Padding
        this.padding = null;
        // Stores the pieces used to generate the horizontal layout
        this.horizontalPieces = null;
        // Stores the pieces used to generate the vertical layout
        this.verticalPieces = null;
        this.imageNinePathBase64 = imageNinePathBase64;
        // Stores the 9patch image
        this.bgImage = null;
    }

    getPieces(data, staticColor, repeatColor){
        let tempDS, tempPosition, tempWidth, tempColor, tempType;
        let tempArray = new Array();

        tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7];
        tempDS = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
        tempPosition = 1;

        for (var i = 4, n = data.length - 4; i < n; i += 4) {
            tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3];
            tempType = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
            if (tempDS !== tempType) {
                // box changed colors
                tempWidth = (i / 4) - tempPosition;
                tempArray.push(new Array(tempDS, tempPosition, tempWidth));

                tempDS = tempType;
                tempPosition = i / 4;
                tempWidth = 1;
            }
        }
        
        // push end
        tempWidth = (i / 4) - tempPosition;
        tempArray.push(new Array(tempDS, tempPosition, tempWidth));

        return tempArray;
    }

    getPadBorder(dataPad, width, height){
        var staticRight = dataPad[0] + ',' + dataPad[1] + ',' + dataPad[2] + ',' + dataPad[3];
        var pad = { top: 0, bottom: 0 };
    
        // Padding para la parte superior
        for (var i = 0; i < dataPad.length; i += 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.top++;
        }
        // padding inferior
        for (var i = dataPad.length - 4; i >= 0; i -= 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.bottom++;
        }
        return pad;
    }

    draw(){
        var dCtx, dCanvas, dWidth, dHeight;

        if (this.horizontalPieces === null)
            return;
    
        dWidth = this.domElement.clientWidth;
        dHeight = this.domElement.clientHeight;
        if(dWidth=== 0 && dHeight===0){
            console.warn("Dimensiones boton ",dWidth,dHeight);
            return;
        }
    
        if (dWidth === 0 || dHeight === 0)
            return;
    
        dCanvas = document.createElement('canvas');
        dCtx = dCanvas.getContext('2d');
    
        dCanvas.width = dWidth;
        dCanvas.height = dHeight;
    
        var fillWidth, fillHeight;
        // Determine the width for the static and dynamic pieces
        var tempStaticWidth = 0;
        var tempDynamicCount = 0;
    
        for (var i = 0, n = this.horizontalPieces.length; i < n; i++) {
            if (this.horizontalPieces[i][0] === 's')
                tempStaticWidth += this.horizontalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount;
    
        // Determine the height for the static and dynamic pieces
        var tempStaticHeight = 0;
        tempDynamicCount = 0;
        for (var i = 0, n = this.verticalPieces.length; i < n; i++) {
            if (this.verticalPieces[i][0] === 's')
                tempStaticHeight += this.verticalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillHeight = (dHeight - tempStaticHeight) / tempDynamicCount;
    
        // Loop through each of the vertical/horizontal pieces and draw on
        // the canvas
        for (var i = 0, m = this.verticalPieces.length; i < m; i++) {
            for (var j = 0, n = this.horizontalPieces.length; j < n; j++) {
                var tempFillWidth, tempFillHeight;
    
                tempFillWidth = (this.horizontalPieces[j][0] === 'd') ?
                    fillWidth : this.horizontalPieces[j][2];
                tempFillHeight = (this.verticalPieces[i][0] === 'd') ?
                    fillHeight : this.verticalPieces[i][2];
    
                // Stretching :
                if (this.verticalPieces[i][0] !== 'r') {
                    // Stretching is the same function for the static squares
                    // the only difference is the widths/heights are the same.
                    if (tempFillWidth >= 0 && tempFillHeight >= 0) {
                        dCtx.drawImage(
                            this.bgImage,
                            this.horizontalPieces[j][1], this.verticalPieces[i][1],
                            this.horizontalPieces[j][2], this.verticalPieces[i][2],
                            0, 0,
                            tempFillWidth, tempFillHeight);
                    }
                    else
                        break;
                }
                else {
                    var tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.horizontalPieces[j][2];
                    tempCanvas.height = this.verticalPieces[i][2];
    
                    var tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(
                        this.bgImage,
                        this.horizontalPieces[j][1], this.verticalPieces[i][1],
                        this.horizontalPieces[j][2], this.verticalPieces[i][2],
                        0, 0,
                        this.horizontalPieces[j][2], this.verticalPieces[i][2]);
    
                    var tempPattern = dCtx.createPattern(tempCanvas, 'repeat');
                    dCtx.fillStyle = tempPattern;
                    dCtx.fillRect(
                        0, 0,
                        tempFillWidth, tempFillHeight);
                }
    
                // Shift to next x position
                dCtx.translate(tempFillWidth, 0);
            }
    
            // shift back to 0 x and down to the next line
            dCtx.translate(-dWidth, (this.verticalPieces[i][0] === 's' ? this.verticalPieces[i][2] : fillHeight));
        }
    
        // store the canvas as the div's background
        var url = dCanvas.toDataURL("image/png");
        var tempIMG = new Image();
    
        tempIMG.onload = ()=>{
            this.domElement.style.background = `url(${url}) no-repeat`;
        };
        tempIMG.src = url;
    }

    // @Override
    async load(){
        // Limpiando fondo de boton
        if(this.view)
            this.view.elemDom.style.border = "none"

        // Obteniendo datos de la imagen ninepath.9
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // Cargamos la imagen 
        this.bgImage = await Resource.loadImage(this.imageNinePathBase64);
        this.domElement.style.background = 'none';
        this.domElement.style.backgroundRepeat = "no-repeat";

        // this.view.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        
        // Obteniendo padding
        // var tempCtx, tempCanvas;
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.bgImage.width;
        tempCanvas.height = this.bgImage.height;
        this.tempCtx = tempCanvas.getContext('2d');
        this.tempCtx.drawImage(this.bgImage, 0, 0);

        var dataPad = this.tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        this.padding.top = padRight.top;
        this.padding.bottom = padRight.bottom;
        dataPad = this.tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        this.padding.left = padBottom.top;
        this.padding.right = padBottom.bottom;

        if(this.view)
            this.view.padding= this.padding;
    }
    
    // @Override
    async paint(){
        // Create a temporary canvas to get the 9Patch index data.
        // var tempCtx, tempCanvas;
        // tempCanvas = document.createElement('canvas');
        // tempCanvas.width = this.bgImage.width;
        // tempCanvas.height = this.bgImage.height;
        // tempCtx = tempCanvas.getContext('2d');
        // tempCtx.drawImage(this.bgImage, 0, 0);

        // // Obteniendo el padding lateral derecho
        // var dataPad = tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        // var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        // this.padding.top = padRight.top;
        // this.padding.bottom = padRight.bottom;
        // dataPad = tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        // var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        // this.padding.left = padBottom.top;
        // this.padding.right = padBottom.bottom;

        // Loop over each  horizontal pixel and get piece
        if(!this.tempCtx)
            return;
        var data = this.tempCtx.getImageData(0, 0, this.bgImage.width, 1).data;

        // Use the upper-left corner to get staticColor, use the upper-right corner
        // to get the repeatColor.
        var tempLength = data.length - 4;
        var staticColor = data[0] + ',' + data[1] + ',' + data[2] + ',' + data[3];
        var repeatColor = data[tempLength] + ',' + data[tempLength + 1] + ',' +
            data[tempLength + 2] + ',' + data[tempLength + 3];
        this.horizontalPieces = this.getPieces(data, staticColor, repeatColor);

        // Loop over each  horizontal pixel and get piece
        data = this.tempCtx.getImageData(0, 0, 1, this.bgImage.height).data;
        this.verticalPieces = this.getPieces(data, staticColor, repeatColor);

        // use this.horizontalPieces and this.verticalPieces to generate image
        this.draw();
    }
}
// Class: src/ux/animation/SpinnerAnimation.js
class SpinnerAnimation {
    constructor(propProgress){
        if(propProgress)
            this.propProgress = propProgress;
        else{
            this.propProgress = {
                left: (PageManager.getWindowsDimension().width / 2 - 150 / 2),
                top: (PageManager.getWindowsDimension().height / 2 - 150 / 2),
                size: 150,
                showBackground: true,
                backgroundRotation: true,
                parentElement: document.body
            };
        }
        // Creamos el loader para la pagina
        if(this.propProgress.showBackground===true){
            this.elemLoader = document.createElement('div');
            this.elemLoader.style.margin = '0px';
            this.elemLoader.style.width = '100%';
            this.elemLoader.style.height = '100%';
            this.elemLoader.style.position = 'absolute';
            this.elemLoader.style.backgroundColor = "rgba(1, 11,20, 0.5)";
        }

        this.elemImgLoader = document.createElement('div');
        this.elemImgLoader.style.width = this.propProgress.size + 'px';
        this.elemImgLoader.style.height = this.propProgress.size + 'px';
        this.elemImgLoader.style.position = 'absolute';
        this.elemImgLoader.style.top = this.propProgress.top + 'px';
        this.elemImgLoader.style.left = this.propProgress.left + 'px';
        let imgLoader = null;
        if(this.propProgress.backgroundRotation){
            let radiusBack = this.propProgress.size / 8;
            this.elemImgLoader.style.background = '#05112B';
            this.elemImgLoader.style.borderRadius = (radiusBack) + 'px';
            imgLoader = this.createCanvas(this.propProgress.size - radiusBack * 2);
            imgLoader.style.left = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
            imgLoader.style.top = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
        }
        else
            imgLoader = this.createCanvas(this.propProgress.size);
        if (this.propProgress.showBackground === true)
            document.body.appendChild(this.elemLoader);
        imgLoader.className = "rotate";
        this.elemImgLoader.appendChild(imgLoader);
    }

    getRootDomElement(){
        return this.elemImgLoader;
    }

    resize(size){
        this.propProgress.size = size;
        if(this.elemImgLoader.firstChild)
            this.elemImgLoader.removeChild(this.elemImgLoader.firstChild);

        let imgLoader = this.createCanvas(size);
        imgLoader.style.left = "0px";
        imgLoader.style.top = "0px";
        imgLoader.className = "rotate";
        this.elemImgLoader.appendChild(imgLoader);
    }

    createCanvas(size){
        let imgLoader = document.createElement('canvas');
        imgLoader.setAttribute("width", size);
        imgLoader.setAttribute("height", size);

        imgLoader.style.position = 'absolute';
        imgLoader.style.top = '0px';
        imgLoader.style.left = '0px';
        let ctx = imgLoader.getContext("2d");

        // Pintando spinner
        let lines = 13;
        let radius = imgLoader.width / 10;
        let rotation = radius;
        ctx.save();

        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI * 2 * rotation);
        for (let i = 0; i < lines; i++) {
            ctx.beginPath();
            ctx.rotate(Math.PI * 2 / lines);
            ctx.fillStyle = "rgba(250,254,255," + (1 - i / lines) + ")";
            ctx.arc(imgLoader.width / 2 - radius, 0, radius, 0, 2 * Math.PI, false);
            ctx.fill();
            radius = radius - radius / (lines - 1);
            if (radius < 1)
                break;
        }
        ctx.restore();
        return imgLoader;
    }

    show(){
        this.propProgress.parentElement.appendChild(this.elemImgLoader);
    }

    hide(){
        if (this.propProgress.showBackground === true)
            this.elemLoader.parentNode.removeChild(this.elemLoader);
        this.elemImgLoader.parentNode.removeChild(this.elemImgLoader);
    }
}
// Class: src/view/View.js
class View {
    static INVISIBLE = "invisible";
    static VISIBLE = "visible";
    static GONE = "gone";

    constructor(context,model) {
        if (!context)
            throw new Exception("El contexto no esta en los parametros o es nulo");
        this.context = context;
        this.model = model||null;
        this.margin = { top: 0, left: 0, right: 0, bottom: 0 };
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        this.parentView = null;
        this.maxWidth = Resource.getAttrOfTheme(this.constructor.name, 'maxWidth', -1);
        this.maxHeigth = Resource.getAttrOfTheme(this.constructor.name, 'maxHeigth', -1);
        this.width = Resource.getAttrOfTheme(this.constructor.name, 'width', LayoutInflater.WRAP_CONTENT);
        this.height = Resource.getAttrOfTheme(this.constructor.name, 'height', LayoutInflater.WRAP_CONTENT);
        this.id = Resource.getAttrOfTheme(this.constructor.name, 'id');
        this.background = Resource.getAttrOfTheme(this.constructor.name, 'background');
        this.cssClassList = Resource.getAttrOfTheme(this.constructor.name, 'cssClassList',this.constructor.name);
        this.cssStyle = Resource.getAttrOfTheme(this.constructor.name, 'cssStyle');
        this.onClickListener = null;
        this.onClickItemDefinition = null;
        this.tooltip = Resource.getAttrOfTheme(this.constructor.name, 'tooltip');
        this.audioClick = Resource.getAttrOfTheme(this.constructor.name, 'audioClick');
        this.audioAdove = Resource.getAttrOfTheme(this.constructor.name, 'audioAdove');
        this.requiredInForm = false;
        this.requiredMessage = null;
        this.opacity=1;
        this.visibility = View.VISIBLE;
        this.createHtmlElement();
        this.elemDom.style.visibility = "hidden";

        this.onClickContext = this.getContext();
    }

    setOnClickListenerTo(idView,onClickListener){
        if(idView instanceof View)
            idView.setOnClickListener(onClickListener, this);
        else{
            let view = this.findViewById(idView);
            view.setOnClickListener(onClickListener, this);
        }
    }

    getElemDom(){
        return this.elemDom;
    }

    getMaxWidth(){
        return this.maxWidth;
    }

    setMaxWidth(maxW){
        this.maxWidth = maxW;
    }

    getMaxHeight(){
        return this.maxHeigth;
    }

    getAllAttrs(){
        return Object.keys(this);
    }

    async setVisibility(v) {
        switch(v){
            case View.VISIBLE:
                this.elemDom.style.display = "block";
                this.elemDom.style.visibility = "visible";
                break;
            case View.INVISIBLE:
                this.elemDom.style.display = "block";
                this.elemDom.style.visibility = "hidden";                
                break;
            case View.GONE:
                this.elemDom.style.display = "none";
                break;
        }
        this.visibility = v;
        if(this.parentView !== null && this.parentView !== undefined){
            await this.onReMeasure();
        }
    }
    
    setToolTip(text) {
        this.tooltip = text;
    }

    setMinWidth(w) {
        this.minWidth = w;
    }
    getContext() {
        return this.context;
    }

    setMinHeight(h) {
        this.minHeigth = h;
    }

    findViewById(idView) {
        if (idView === null && idView === undefined)
            return null;
        if(this.id === idView)
            return this;
        return null;
    }

    createHtmlElemFromType(type) {
        let htmlElement = document.createElement(type);
        // Margenes por defector
        htmlElement.style.marginTop = '0px';
        htmlElement.style.marginLeft = '0px';
        htmlElement.style.marginBottom = '0px';
        htmlElement.style.marginRight = '0px';

        // Padding por defecto
        htmlElement.style.paddingTop = '0px';
        htmlElement.style.paddingLeft = '0px';
        htmlElement.style.paddingBottom = '0px';
        htmlElement.style.paddingRight = '0px';

        htmlElement.style.position = 'absolute';
        return htmlElement;
    }

    createHtmlElement() {
        this.elemDom = this.createHtmlElemFromType(this.getTypeElement());
        return this.elemDom;
    }

    getTypeElement() {
        return this.constructor.name;
    }

    setId(id) {
        this.id = id;
    }

    clone() {
        let copy = Object.assign({}, this);
        copy.elemDom = this.elemDom.cloneNode(true);
    }
    
    getWidth() {
        // return this.width;
        return this.elemDom? this.elemDom.clientWidth: 0;
    }

    getHeight() {
        return this.elemDom? this.elemDom.clientHeight: 0;
    }
    
    setMargin(margin) {
        if (!margin) return;
        let mg = parseInt(margin);
        this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = mg;
    }
    
    setMarginTop(margin) {
        if (!margin) return;
        this.margin.top = parseInt(margin);
    }

    setMarginLeft(margin) {
        if (!margin) return;
        this.margin.left = parseInt(margin);
    }
    setMarginRight(margin) {
        if (!margin) return;
        this.margin.right = parseInt(margin);
    }

    setMarginBottom(margin) {
        if (!margin) return;
        this.margin.bottom = parseInt(margin);
    }

    getBackground() {
        return this.background;
    }

    async setBackground(background) {
        this.background = background;
        if(this.background){
            // Se verifica que tipo de fondo
            if(this.background instanceof BaseBackground)
                this.backgroundPainter = this.background;
            else if(Resource.isImageNinePathResource(this.background)){ // Imagen de fondo de nine path
                // let imageInBase64 = Resource.loa
                this.backgroundPainter = new NinepathBackground(this,this.elemDom,this.background);
            } 
            else if(Resource.isImageResource(this.background) || Resource.isBase64Resource(this.background))
                this.backgroundPainter = new ImageBackground(this,this.elemDom,this.background);
            else if(Resource.isColorResource(this.background) || this.background.indexOf("rgba(")!==-1)
                this.backgroundPainter = new ColorBackground(this,this.elemDom,this.background);
            else if(this.background.includes('.js')){
                await Resource.importJs(this.background);
                let backInsName = this.background.substring(this.background.lastIndexOf('/')+1,this.background.length-'.js'.length);
                this.backgroundPainter = eval(`new ${backInsName}(this,this.elemDom)`);
                // this.backgroundPainter = new LateralMenuBackgroud(this,this.elemDom);
            }else
                throw new Exception(`No se pudo identificar el tipo de fondo [${this.background}]`);
        }else{
            this.backgroundPainter = new EmplyBackground(this,this.elemDom);
        }

        await this.backgroundPainter.load();
    }

    setWidth(width) {
        this.width = width;
    }

    setHeight(height){
        this.height = height;
    }

    setLayoutGravity(layoutGravity) {
        this.layoutGravity = layoutGravity;
    }

    setOnClickListener(onClickListener,onClickContext){
        this.onClickItemDefinition = onClickListener;
        if(onClickContext)
            this.onClickContext = onClickContext;
        else
            this.onClickContext = arguments[1]||this.onClickContext;
        if (typeof this.onClickItemDefinition === 'function') {
            this.onClickListener = this.onClickItemDefinition;
        }
        else{
            if (typeof this.onClickItemDefinition === 'string') {
                // Buscamos el nombre de metodo en el contexto
                let propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this.context));
                if(propertyNames.find(property=>property===this.onClickItemDefinition)){
                    this.onClickListener = this.context[this.onClickItemDefinition];
                }else
                    throw new Exception(`No se pudo encontrar la funcion [${this.onClickItemDefinition}] dentro del contexto [${this.context.constructor.name}]`);
            }
            else 
                throw new Exception(`El objeto [${onClickItemListener}] no es valido para establecer el Listener de onClickItemListener`);
        }

        if(this.onClickListener){
            this.elemDom.onclick=()=>{
                if(this.audioClickMedia)
                    this.audioClickMedia.play();
                Reflect.apply(this.onClickListener, this.onClickContext, [this]);
            };
        }
    }

    async setMP(dr, ic, txt, tc) {
        var popup = new PopupWindow(this.getContext());
        let tempCtx = {
            async onResize(){
                // let navigator = PageManager.getWindowsDimension();
                // await this.viewRoot.onMeasure(navigator.width,navigator.height);
            }
        };
        let message = new TextView(tempCtx);
        await message.setText(txt);
        if (ic !== null)
            await message.setDrawableLeft(ic);
        message.setBackground(dr);
        message.setSingleLine(true);
        message.setTextColor(tc);

        popup.setView(this);
        popup.setContentView(message);
        popup.show();
        setTimeout(function(){
            popup.hide();
        },3000);
        return popup;
    }

    async showAlertMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_alerta.9.png", "lib/imgs/ic_msg_alert.png", msg, "#653400");
    }

    async showConfirmMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_confirm.9.png", "lib/imgs/ic_msg_confirm.png", msg, "#346700");
    }

    async showErrorMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_error.9.png", "lib/imgs/ic_msg_error.png", msg, "#A90400");
    }

    async showInfoMsg(msg) {
        await this.setMP("lib/imgs/bg_msg_info.9.png", "lib/imgs/ic_msg_info.png", msg, "#4C95E7");
    }

    async tooglefullScream(){        
        let funCheck = ()=>{
            if(!document.fullscreenElement){
                this.getContext().enableDimensionListener(true);
                this.getContext().onResize();
                document.removeEventListener('fullscreenchange', funCheck);
            }
        };

        document.addEventListener('fullscreenchange', funCheck);
        if (!document.fullscreenElement) {
            this.getContext().enableDimensionListener(false);
            await this.getElemDom().requestFullscreen();
            await this.onMeasure(this.getElemDom().clientWidth, this.getElemDom().clientHeight);
        } else {
            this.getContext().enableDimensionListener(true);
            document.exitFullscreen();
        }
    }

    getAttrFromNodeXml(nodeXml, attrName){
        let attrValue  = nodeXml.getAttribute(attrName);
        if(attrValue){
            attrValue = attrValue.replace(LayoutInflater.REGEX_VARS,(cmp,paramName)=>{
                if(paramName.indexOf('.')!==-1 || this.model===null){
                    return eval(paramName);
                }
                else{
                    let model = this.model;
                    return eval(`model.${paramName}`);
                }
            });
        }
        return attrValue;
    }

    async setTheme(themeName){
        let theme = Resource.THEME;
        if(theme[themeName]){
            Object.entries(theme[themeName]).forEach(([key, value]) => {
                this[key] = value;
            });
        }
    }

    showElemDom(){
        this.elemDom.style.visibility = "visible";
    }

    hideElemDom(){
        this.elemDom.style.visibility = "hidden";
    }

    setOpacity(opacity){
        this.elemDom.style.opacity=opacity;
        this.opacity = opacity;
    }
    
    hideView(){
        if(this instanceof Container){
            for( let view of this.viewsChilds){
                view.hideView();
            }
            this.hideElemDom();
        }else if(this instanceof View){
            this.hideElemDom();
        }
    }

    showView(){
        if(this instanceof Container){
            for( let view of this.viewsChilds){
                view.showView();
            }
            this.showElemDom();
        }else if(this instanceof View){
            this.showElemDom();
        }
    }

    async parse(nodeXml) {
        // THEMA PARA LA VISTA
        if (this.getAttrFromNodeXml(nodeXml,"theme"))
            this.setTheme(this.getAttrFromNodeXml(nodeXml,"theme"));

        // VISIBILITY DEL VIEW
        this.visibility = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_VISIBILITY) || this.visibility;

        // MARGEN DEL COMPONENTE
        if(this.getAttrFromNodeXml(nodeXml,"margin")!=null)
            this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,"margin"));
        if(this.getAttrFromNodeXml(nodeXml,"marginBottom")!=null)
            this.margin.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,"marginBottom"));
        if(this.getAttrFromNodeXml(nodeXml,"marginLeft")!=null)
            this.margin.left = parseInt(this.getAttrFromNodeXml(nodeXml,"marginLeft"));
        if(this.getAttrFromNodeXml(nodeXml,"marginRight")!=null)
            this.margin.right = parseInt(this.getAttrFromNodeXml(nodeXml,"marginRight"));
        if(this.getAttrFromNodeXml(nodeXml,"marginTop")!=null)
            this.margin.top = parseInt(this.getAttrFromNodeXml(nodeXml,"marginTop"));
            
        if(this.getAttrFromNodeXml(nodeXml,"paddingLeft"))
            this.padding.left = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingLeft"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingRight"))
            this.padding.right = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingRight"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingTop"))
            this.padding.top = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingTop"));
        if(this.getAttrFromNodeXml(nodeXml,"paddingBottom"))
            this.padding.bottom = parseInt(this.getAttrFromNodeXml(nodeXml,"paddingBottom"));
        if(this.getAttrFromNodeXml(nodeXml,"opacity"))
            this.opacity = parseFloat(this.getAttrFromNodeXml(nodeXml,"opacity"));
        let padding = this.getAttrFromNodeXml(nodeXml,"padding");
        if (padding !== null) {
            let pad = parseInt(padding);
            this.padding.top = this.padding.left = this.padding.right = this.padding.bottom = pad;
        }

        // ID DEL VIEW
        this.id = this.getAttrFromNodeXml(nodeXml,"id") || this.id;

        // LAYOUT GRAVITY DEL VIEW
        this.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY) || this.layoutGravity;

        // WIDTH DEL VIEW
        this.width = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WIDTH) || this.width;
        // HEIGHT DEL VIEW
        this.height = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_HEIGHT) || this.height;

        this.tooltip = this.getAttrFromNodeXml(nodeXml,'tooltip') || this.tooltip;

        this.cssStyle = this.getAttrFromNodeXml(nodeXml,'cssStyle') || this.cssStyle;

        // BACKGROUDN DEL VIEW
        this.background = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_BACKGROUND) || this.background;
        this.onClickDefinition = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ON_CLICK) || this.onClickDefinition;

        this.minHeigth = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MIN_HEIGHT)) || this.minHeigth;
        this.minWidth = parseInt(this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_MIN_WIDTH)) || this.minWidth;

        if (this.getAttrFromNodeXml(nodeXml,"cssClassList")){
            // this.cssClassList = `${nodeXml,"cssClassList")}`;
            this.cssClassList = `${this.cssClassList},${this.getAttrFromNodeXml(nodeXml,"cssClassList")}`;
        }

        // AUDIO PARA EL CLICK
        this.audioClick = this.getAttrFromNodeXml(nodeXml,"audioClick") || this.audioClick;
        this.audioAdove = this.getAttrFromNodeXml(nodeXml,"audioAdove") || this.audioAdove;
            
        this.requiredInForm = this.getAttrFromNodeXml(nodeXml,"requiredInForm") || false;
        this.requiredMessage = this.getAttrFromNodeXml(nodeXml,"requiredMessage");

        // LIMITES MAXIMOS
        if(this.getAttrFromNodeXml(nodeXml,"maxWidth")!=null)
            this.maxWidth = parseInt(this.getAttrFromNodeXml(nodeXml,"maxWidth"));
        if(this.getAttrFromNodeXml(nodeXml,"maxHeight")!=null)
            this.maxHeigth = parseInt(this.getAttrFromNodeXml(nodeXml,"maxHeight"));

        if(this.getAttrFromNodeXml(nodeXml,"visibility") != null){
            switch(this.getAttrFromNodeXml(nodeXml,"visibility")){
                case View.VISIBLE:
                    this.visibility = View.VISIBLE;
                    this.elemDom.style.visibility = "hidden";
                    break;
                case View.INVISIBLE:
                    this.visibility = View.INVISIBLE;
                    this.elemDom.style.visibility = "hidden";
                    break;
                case View.GONE:
                    this.visibility = View.GONE;
                    this.elemDom.style.display = "none";
                    break;
            }
        }
    }

    async loadResources() {
        await this.setBackground(this.background);

        // Tooltip de Vista
        if(this.tooltip)
            this.elemDom.setAttribute("title", this.tooltip);
        // // Visibilidad
        // switch (this.visibility) {
        //     case View.INVISIBLE:
        //         this.elemDom.style.visibility = 'hidden';
        //         break;
        //     case View.GONE:
        //         this.elemDom.style.visibility = 'hidden';
        //         break;
        //     default:
        //         this.elemDom.style.visibility = 'block';
        //         break;
        // }

        // Cargando OnClick
        if((this.onClick===null || this.onClick === undefined) && this.onClickDefinition){
            this.setOnClickListener(this.onClickDefinition, this.getContext());
        }

        if(this.audioClick)
            this.audioClickMedia = new Audio(this.audioClick);
        if(this.audioAdove)
            this.audioAdoveMedia = new Audio(this.audioAdove);
        // Sobre el componente
        
        this.elemDom.onmouseenter=(event)=>{
            if(this.audioAdoveMedia)
                this.audioAdoveMedia.play();
            event.preventDefault();
            return false;
        };
        // cssClassList
        if(this.cssClassList.length > 0){
            this.cssClassList.split(',').forEach(classNameStyle => this.elemDom.classList.add(classNameStyle));
        }

        // cssStyle
        if(this.cssStyle && !this.elemDom.style.cssText.includes(this.cssStyle)){
            this.elemDom.style.cssText = this.elemDom.style.cssText+this.cssStyle;
        }

        // Background
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                this.elemDom.style.width = `${parseInt(this.width)}px`;
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                this.elemDom.style.height = `${parseInt(this.height)}px`;
        }
        if(this.opacity!==1)
            this.elemDom.style.opacity=this.opacity;
    }

    addCssClass(cssString){
        let array = this.cssClassList.split(',');
        array.push(cssString);
        this.cssClassList = array.join(',');
        if(this.elemDom)
            this.elemDom.classList.add(cssString);
    }

    removeCssClass(cssString){
        this.cssClassList = this.cssClassList.split(',').filter(classCss => classCss !== cssString).join(',');
        if(this.elemDom)
            this.elemDom.classList.remove(cssString);
    }

    async repaint() {
        //if(this.parentView === null)
        //    return;
        if(this.backgroundPainter)
            await this.backgroundPainter.paint();
    }

    isSizeStatic(){
        let r = false;
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: r = false;break;
            case LayoutInflater.WRAP_CONTENT: r = false;break;
            default: r = true;
        }
        let a = false;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: a= false; break;
            case LayoutInflater.WRAP_CONTENT: a= false; break;
            default: a = true;
        }
        return r && a;
    }

    async onReMeasure(){
        let viewRootStatic = this;
        while(viewRootStatic !== null){
            if(viewRootStatic.isSizeStatic())
                break;
            if(viewRootStatic.parentView === null || viewRootStatic.parentView === undefined)
                break;
            viewRootStatic = viewRootStatic.parentView;
        }
        if(viewRootStatic.parentView)
            await viewRootStatic.onMeasure(viewRootStatic.getWidth(),viewRootStatic.getHeight());
        else{
            await viewRootStatic.context.onResize();
        }
    }
    
    // this.parentView.elemDom.appendChild(this.elemDom);
    async onMeasure(maxWidth, maxHeigth) {
        if(!this.elemDom) return; // No realizada nada si no fué agregado a la vista
        if(this.maxWidth>0)
            maxWidth = this.maxWidth;
        if(this.maxHeigth>0)
            maxHeigth = this.maxHeigth;

        // ************  ANCHO DE PANTALLA  ************
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = (maxWidth - this.margin.left - this.margin.right) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                if(this.maxWidth>0 && this.elemDom.clientWidth>maxWidth)
                    this.elemDom.style.width = maxWidth + 'px';
                break;
            default:
                var width = parseInt(this.width);
                width = Math.max(width,this.maxWidth);
                this.elemDom.style.width = width + 'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = (maxHeigth - this.margin.top - this.margin.bottom) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                if(this.maxHeigth>0 && this.elemDom.clientHeight>maxHeigth)
                    this.elemDom.style.height = maxHeigth + 'px';
                break;
            default:
                var height = parseInt(this.height);
                height = Math.max(height,this.maxHeigth);
                this.elemDom.style.height = height + 'px';
                break;
        }
        if(this.backgroundPainter)
            await this.backgroundPainter.paint();
    }

    async remove(){
        if(!this.parentView)
            return;
        if(this.parentView instanceof Container)
            this.parentView.removeView(this);
    }

    cloneDomElem(){
        let dom = this.elemDom.cloneNode(true);
        return dom;
    }
}
// Class: src/view/TextView.js
class TextView extends View {
    constructor(context,model){
        super(context,model);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.textColor = Resource.getAttrOfTheme(this.constructor.name, 'textColor');
        this.textCssStyle = Resource.getAttrOfTheme(this.constructor.name, 'textCssStyle');
        this.textSize = Resource.getAttrOfTheme(this.constructor.name, 'textSize','12px');
        let iconSize = Resource.getAttrOfTheme(this.constructor.name, 'iconSize');
        this.drawableResource= null;
        this.gravityIcon = Resource.getAttrOfTheme(this.constructor.name, 'gravityIcon','left');
        this.singleLine = Resource.getAttrOfTheme(this.constructor.name, 'singleLine',false);
        this.ellipsize= "none";
        this.image = null;
        this.iconWidth=iconSize;
        this.iconHeight=iconSize;
        this.textGravity = 'left|top';

        this.shadowColor = Resource.getAttrOfTheme(this.constructor.name, 'shadowColor');
        this.shadowDx = Resource.getAttrOfTheme(this.constructor.name, 'shadowDx',0);
        this.shadowDy = Resource.getAttrOfTheme(this.constructor.name, 'shadowDy',0);
        this.shadowRadius = Resource.getAttrOfTheme(this.constructor.name, 'shadowRadius',3);
    }

    //@Override
    async parse(nodeXml){
        await super.parse(nodeXml);
        
        this.text = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TEXT) || this.text;
        this.textColor = this.getAttrFromNodeXml(nodeXml,"textColor") || this.textColor;
        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_LEFT) !== null) {
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_LEFT);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_RIGHT) !== null) {
            this.gravityIcon = LayoutInflater.RIGHT;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_RIGHT);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_TOP) !== null) {
            this.gravityIcon = LayoutInflater.TOP;
            this.drawableResource =  this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_TOP);
        }
        else if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_BOTTOM) !== null) {
            this.gravityIcon = LayoutInflater.BOTTOM;
            this.drawableResource = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_DRAWABLE_BOTTOM);
        }
        else{
            this.gravityIcon = LayoutInflater.LEFT;
            this.drawableResource = null;
        }
        this.singleLine = this.getAttrFromNodeXml(nodeXml,"singleLine")? (this.getAttrFromNodeXml(nodeXml,"singleLine")==="true") : this.singleLine;
        this.textStyle = this.getAttrFromNodeXml(nodeXml,"textStyle") || this.textStyle;

        this.shadowColor = this.getAttrFromNodeXml(nodeXml,"shadowColor") || this.shadowColor;
        this.shadowDx = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowDx")) || this.shadowDx;
        this.shadowDy = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowDy")) || this.shadowDy;
        this.shadowRadius = parseInt(this.getAttrFromNodeXml(nodeXml,"shadowRadius"))||this.shadowRadius;
        
        this.iconWidth = parseInt(this.getAttrFromNodeXml(nodeXml,"iconWidth")) || this.iconWidth;
        this.iconHeight = parseInt(this.getAttrFromNodeXml(nodeXml,"iconHeight")) || this.iconHeight;

        this.textSize = this.getAttrFromNodeXml(nodeXml,"textSize")||this.textSize;
        if(this.getAttrFromNodeXml(nodeXml,"iconSize")){
            let iconSize = parseInt(this.getAttrFromNodeXml(nodeXml,"iconSize"));
            this.iconWidth = iconSize;
            this.iconHeight = iconSize;
        }
        this.textGravity = this.getAttrFromNodeXml(nodeXml,"textGravity")||this.textGravity;
    }

    // Override
    getAllAttrs(){
        return Object.keys(this);
    }

    setSingleLine(single) {
        this.singleLine = single;
    }

    setTextColor(color) {
        this.textColor = color;
    }

    setIconWidth(w){
        this.iconWidth = parseInt(w)
    }

    setIconHeight(h){
        this.iconHeight = parseInt(h)
    }

    async setText(text){
        this.text = text;
        if(this.elemDom)
            this.elemText.innerHTML = this.text;
        if(this.parentView !== null && this.parentView !== undefined)
            await this.onReMeasure();
    }

    async setTextSize(textSize){
        this.textSize = textSize;
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.container = this.createHtmlElemFromType('div'); 

        this.elemText = this.createHtmlElemFromType('span');
        this.elemText.style.wordWrap = 'break-word'; // Ajustar texto a contenido

        this.container.appendChild(this.elemText);
        this.elemDom.appendChild(this.container);
        return this.elemDom;
    }

    createDivIcon(tagName){
        // Icono
        this.elemIcon = this.createHtmlElemFromType(tagName||'icon');
        this.elemIcon.style.backgroundRepeat = 'no-repeat';
        this.elemIcon.style.backgroundOrigin="content-box";
        this.elemIcon.style.backgroundSize = "contain";
        this.container.appendChild(this.elemIcon);
        this.isSvg = false;
    }

    getIconWidth(){
        if(this.drawableResource)
            return (this.isSvg?this.elemIcon.getBoundingClientRect().width:this.elemIcon.clientWidth);
        return 0;
    }

    getElemIcon(){
        return this.elemIcon;
    }

    getIconHeight(){
        if(this.drawableResource)
            return (this.isSvg?this.elemIcon.getBoundingClientRect().height:this.elemIcon.clientHeight);
        return 0;
    }

    async loadIcon(){
        if(this.elemIcon){
            this.elemIcon.remove();
            this.image = null;
        }
        if(this.drawableResource){
            if(Resource.isImageResource(this.drawableResource)){
                if(this.drawableResource.lastIndexOf(".svg")===-1){
                    this.createDivIcon();
                    this.image = await Resource.loadImage(this.drawableResource);
                    this.elemIcon.style.background = `url('${this.image.src}')`;
                    this.elemIcon.style.backgroundSize = "contain";
                    this.elemIcon.style.backgroundRepeat = 'no-repeat';
                }else{
                    this.isSvg = true;
                    let svgResource = await Resource.loadLayoutSync(this.drawableResource);
                    this.elemIcon = this.container.appendChild(svgResource);
                }
            }else if(Resource.isBase64Resource(this.drawableResource)){
                if(this.drawableResource.includes('data:image/svg;')){
                    this.isSvg = true;
                    let svgStr = window.atob(this.drawableResource.replace('data:image/svg;base64,',''));
                    var svgDom = new DOMParser().parseFromString(svgStr, 'application/xml');
                    this.elemIcon = this.container.appendChild(svgDom.documentElement);
                }else{
                    this.createDivIcon();
                    this.image = await Resource.loadImage(this.drawableResource);
                    this.elemIcon.style.background = `url('${this.image.src}')`;
                    this.elemIcon.style.backgroundSize = "contain";
                    this.elemIcon.style.backgroundRepeat = 'no-repeat';
                }
            }else
                throw new Exception(`El recurso [${this.drawableResource}] no es valido como imagen.`);
        }else{
            this.createDivIcon();
            this.elemIcon.style.background = '';
            this.image = null;
        }
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        await this.loadIcon();

        // Estableciendo valores de los atributos
        this.elemText.innerHTML = this.text;
        this.elemText.style.color = this.textColor;
        if (this.singleLine === true)
            this.elemText.style.whiteSpace = "nowrap";
        this.elemText.style.textOverflow = "ellipsis";
        switch (this.textStyle) {
            case "bold": this.elemText.style.fontWeight = 'bold'; break;
            case "italic": this.elemText.style.fontWeight = 'italic'; break;
            default: this.elemText.style.fontWeight = 'normal'; break;
        }
        if(this.textSize)
            this.elemText.style.fontSize = this.textSize;
        if(this.shadowColor)
            this.elemText.style.textShadow=`${this.shadowDx}px ${this.shadowDy}px ${this.shadowRadius}px ${this.shadowColor}`;
        
        // Cargando la imagen o icono te texto
        if(this.drawableResource){
            this.elemIcon.style.width = (this.iconWidth||parseInt(this.textSize))+'px';
            this.elemIcon.style.height = (this.iconHeight||parseInt(this.textSize))+'px';
        }
    }

    async onMeasure(maxWidth, maxHeight) {
        const marginDrawable = this.getIconWidth()===0?0:8; // 4px
        // Redimensionando el tamaño del icono al mismo tamaño del texto
        if(this.gravityIcon === 'left'||this.gravityIcon === 'right'){
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemText.style.width = (
                        maxWidth -
                        this.padding.left -
                        this.getIconWidth() - 
                        marginDrawable -
                        this.padding.right) + 'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    break;
                default: // tamaño establecido por el usuario
                    let width = parseInt(this.width);
                    this.elemText.style.width = (
                        width -
                        this.padding.left -
                        this.getIconWidth() -
                        marginDrawable -
                        this.padding.right) + 'px';
                    break;
            }
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemText.style.height = (
                        maxHeight -
                        this.padding.top -
                         this.padding.bottom) + 'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    break;
                default: // tamaño establecido por el usuario
                    let height = parseInt(this.height);
                    this.elemText.style.height = (
                        height -
                        this.padding.top -
                        this.padding.bottom) + 'px';
                    break;
            }
        }
        else if(this.gravityIcon === 'top'||this.gravityIcon === 'bottom'){
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemText.style.width = (
                        maxWidth -
                        this.getIconWidth() - 
                        marginDrawable -
                        this.padding.left - this.margin.right) + 'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    break;
                default: // tamaño establecido por el usuario
                    let width = parseInt(this.width);
                    this.elemText.style.width = (
                        width -
                        this.padding.left -
                        this.getIconWidth() -
                        marginDrawable -
                        this.padding.right) + 'px';
                    break;
            }
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemText.style.height = (
                        maxHeight -
                        this.padding.top -
                        this.getIconHeight() - 
                        marginDrawable -
                         this.padding.bottom) + 'px';
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    break;
                default: // tamaño establecido por el usuario
                    let height = parseInt(this.height);
                    this.elemText.style.height = (
                        height -
                        this.padding.top -
                        this.getIconHeight() -
                        marginDrawable -
                        this.padding.bottom) + 'px';
                    break;
            }
        }

        switch(this.gravityIcon){
            case "left":
                this.elemIcon.style.left = '0px';
                this.elemText.style.left = (this.getIconWidth() + marginDrawable) + 'px';
                this.elemText.style.top = (Math.max(this.getIconHeight(),this.elemText.clientHeight)/2-this.elemText.clientHeight/2) + 'px';
                this.elemIcon.style.top = (Math.max(this.getIconHeight(),this.elemText.clientHeight)/2-this.getIconHeight()/2) + 'px';

                this.container.style.width = (this.getIconWidth() + marginDrawable + this.elemText.clientWidth) + 'px';
                this.container.style.height = Math.max(this.getIconHeight(),this.elemText.clientHeight) + 'px';
                break;
            case "right":
                this.elemText.style.left = '0px';
                this.elemIcon.style.left = (this.elemText.clientWidth+marginDrawable) + 'px';
                this.elemText.style.top = (Math.max(this.getIconHeight(),this.elemText.clientHeight)/2-this.elemText.clientHeight/2) + 'px';
                this.elemIcon.style.top = (Math.max(this.getIconHeight(),this.elemText.clientHeight)/2-this.getIconHeight()/2) + 'px';

                // establecemos las dimensiones
                this.container.style.width = (this.getIconWidth()+marginDrawable + this.elemText.clientWidth) + 'px';
                this.container.style.height = Math.max(this.elemText.clientHeight, this.getIconHeight()) + 'px';
                break;
            case "bottom":
                let maximoAncho = Math.max(this.elemText.clientWidth,this.getIconWidth());

                this.elemText.style.left = (maximoAncho/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = '0px';

                this.elemIcon.style.left = (maximoAncho/2 -this.getIconWidth()/2) + 'px';
                this.elemIcon.style.top = (this.elemText.clientHeight+marginDrawable) + 'px';

                // establecemos las dimensiones
                this.container.style.width = maximoAncho + 'px';
                this.container.style.height = (this.elemText.clientHeight + marginDrawable + this.getIconHeight()) + 'px';
                break;
            case "top":
                let maximoAnchoTop = Math.max(this.elemText.clientWidth,this.getIconWidth());
                
                this.elemIcon.style.left = (maximoAnchoTop/2 -this.getIconWidth()/2) + 'px';
                this.elemIcon.style.top = '0px';

                this.elemText.style.left = (maximoAnchoTop/2 -this.elemText.clientWidth/2) + 'px';
                this.elemText.style.top = (marginDrawable +this.getIconHeight()) + 'px';

                // establecemos las dimensiones
                this.container.style.width = maximoAnchoTop + 'px';
                this.container.style.height = (this.elemText.clientHeight + marginDrawable + this.getIconHeight()) + 'px';
                break;
            default:
                throw new Exception(`Tipo de alineación [${this.gravityIcon}] no soportada`);
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: this.elemDom.style.height = maxHeight + 'px'; break;
            case LayoutInflater.WRAP_CONTENT: this.elemDom.style.height = (this.padding.top +this.container.clientHeight+this.padding.bottom)+'px'; break;
            default: this.elemDom.style.height = parseInt(this.height) + 'px'; break;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: this.elemDom.style.width = maxWidth + 'px'; break;
            case LayoutInflater.WRAP_CONTENT: this.elemDom.style.width = (this.padding.left +this.container.clientWidth+this.padding.right)+'px'; break;
            default: this.elemDom.style.width = parseInt(this.width) + 'px'; break;
        }

        // Posicionamos el texto de acuerdo a alineacion
        let alignement = this.textGravity.split("|");
        let leftAligned =false;
        let topAligned =false;
        for (let j = 0; j < alignement.length; j++) {
            let alin = alignement[j];
            if (alin === LayoutInflater.TOP){
                topAligned = true;
                this.container.style.top = this.padding.top + 'px';
            }
            if (alin === LayoutInflater.RIGHT){
                leftAligned = true;
                this.container.style.left = (this.getWidth() - this.padding.right - this.container.clientWidth) + 'px';
            }
            if (alin === LayoutInflater.LEFT){
                leftAligned = true;
                this.container.style.left = this.padding.left + 'px';
            }
            if (alin === LayoutInflater.BOTTOM){
                topAligned = true;
                this.container.style.top = (this.getHeight() - this.padding.bottom) + 'px';
            }
            if (alin === LayoutInflater.CENTER_HORIZONTAL){
                leftAligned = true;
                this.container.style.left = (this.getWidth()/2 - this.container.clientWidth/2) + 'px';
            }
            if (alin === LayoutInflater.CENTER_VERTICAL){
                topAligned = true;
                this.container.style.top = (this.getHeight() - this.container.clientHeight/2) + 'px';
            }
            if (alin === LayoutInflater.CENTER){
                leftAligned = true;
                topAligned = true;
                this.container.style.left = (this.getWidth() - this.container.clientWidth/2) + 'px';
                this.container.style.top = (this.getHeight() - this.container.clientHeight/2) + 'px';
            }
        }
        if(!leftAligned)
            this.container.style.left = this.padding.left + 'px';
        if(!topAligned)
            this.container.style.top = this.padding.top + 'px';

        await this.repaint();
    }

    async setDrawableIcon(drawable,position){
        this.gravityIcon = position;
        this.drawableResource = drawable;
        if(this.elemDom){
            await this.loadIcon();
            if(this.drawableResource){
                this.elemIcon.style.width = (this.iconWidth||parseInt(this.textSize))+'px';
                this.elemIcon.style.height = (this.iconHeight||parseInt(this.textSize))+'px';
            }
            await this.onReMeasure();
        }
    }

    async setDrawableLeft(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.LEFT);
    }


    async setDrawableTop(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.TOP);
    }

    async setDrawableRight(drawable) {
        await this.setDrawableIcon(drawable,LayoutInflater.RIGHT);
    }

    getText() {
        return this.text;
    }
}
// Class: src/view/Button.js
class Button extends TextView{
    constructor(context,model){
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
        this.padding.left = this.padding.top = this.padding.right = this.padding.bottom = 4;
    }
};
// Class: src/view/LinkButton.js
class LinkButton extends Button{
    constructor(context,model){
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
        this.padding.left = this.padding.top = this.padding.right = this.padding.bottom = 0;
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.elemDom.style.border = "none";
        return this.elemDom;
    }
};
// Class: src/view/EditText.js
class EditText extends View{
    // lines: 1,
    // maxLines: 10,
    // hint: null,
    // maxLength: -1,
    // readonly: false,
    constructor (context,model) {
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
        this.lines = Resource.getAttrOfTheme(this.constructor.name, 'lines',3);
        this.hint = null;
        this.maxLength = -1;
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.enabled = true;
        this.textSize = Resource.getAttrOfTheme(this.constructor.name, 'textSize','13px');
        this.textChangeListener = null;
        this.singleLine = Resource.getAttrOfTheme(this.constructor.name, 'singleLine',false);
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.lines = this.getAttrFromNodeXml(nodeXml,"lines")?parseInt(this.getAttrFromNodeXml(nodeXml,"lines")): this.lines;
        this.hint = this.getAttrFromNodeXml(nodeXml,"hint") || this.hint;
        this.maxlength = this.getAttrFromNodeXml(nodeXml,"maxlength")?parseInt(this.getAttrFromNodeXml(nodeXml,"maxlength")): this.maxlength;
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
        this.singleLine = this.getAttrFromNodeXml(nodeXml,"singleLine")? (this.getAttrFromNodeXml(nodeXml,"singleLine")==="true") : this.singleLine;
        if(this.singleLine === true)
            this.lines = 1;
        this.enabled = this.getAttrFromNodeXml(nodeXml,"enabled")?(this.getAttrFromNodeXml(nodeXml,"enabled")==="true") : this.enabled;
        this.textSize = this.getAttrFromNodeXml(nodeXml,"textSize")||this.textSize;
    }

    // @Override
    createHtmlElement() {
        this.elemDom = this.createHtmlElemFromType(this.getTypeElement());
        this.elemDom.style.resize = 'none';
        this.elemDom.style.paddingTop = '6px';
        this.elemDom.style.paddingLeft = '6px';
        this.elemDom.style.paddingBottom = '6px';
        this.elemDom.style.paddingRight = '6px';
        this.elemDom.contentEditable = 'true';

        this.elemDom.style.overflowX = "hidden";
        this.elemDom.style.overflowY = "hidden";
        return this.elemDom;
    }

    async setLines(lines){
        this.lines = lines;
    }
    
    getText() {
        return this.elemDom.textContent;
    }

    async setText(txt) {
        this.text = txt;
        this.elemDom.textContent = txt;
    }

    setEnabled(sw) {
        this.elemDom.contentEditable = sw+'';
        this.enabled = sw;
    }
    
    // @Override
    async loadResources() {
        await super.loadResources();
        // this.elemDom.style.height = (this.elemDom.rows * 22) + 'px';
        if(this.lines === 1){
            this.elemDom.style.whiteSpace = "nowrap";
            
        }
        this.elemDom.onkeydown = (e)=>{
            if (this.lines===1&& e.keyCode == 13 && !e.shiftKey){
                e.preventDefault();
                return false;
            }
            else
                return true;
        };
        if (this.hint !== null)
            this.elemDom.placeholder = this.hint;
        if (this.maxLength > 0)
            this.elemDom.setAttribute("maxlength", this.maxLength);
        this.elemDom.textContent = this.text;
        this.elemDom.style.fontSize = this.textSize;
        this.elemDom.contentEditable = this.enabled+"";
    }

    setSingleLine(sw){
        this.singleLine = sw;
        if(sw)
            this.lines = 1;
    }

    getWidth() {
        return this.elemDom.clientWidth;
    }

    //@Override
    getHeight() {
        return this.elemDom.clientHeight;
    }

    setTextChangeListener(textChangeListener){
        this.textChangeListener = textChangeListener;
        this.elemDom.addEventListener('input', (e) => {
            this.textChangeListener.onChange(this.getText());
        });
    }
}
// Class: src/view/ImageView.js
class ImageView extends View{
    // src: null,
    constructor(context,model){
        super(context,model);
        this.src = null;
        this.image = null;
        this.scaleType = 'content';
        //this.scaleType = 'scale';
        //this.scaleType = 'original';
        this.isSvg = false;
    }

    //@Override
    async createHtmlElement () {
        super.createHtmlElement();
        return this.elemDom;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.src = this.getAttrFromNodeXml(nodeXml,"src");
        this.scaleType = this.getAttrFromNodeXml(nodeXml,'scaleType')||this.scaleType;
        this.image = null;
    }

    setScaleType(scaleType){
        this.scaleType = scaleType;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        await this.loadIcon();
    }

    createDivIcon(tagName){
        // Icono
        this.elemIcon = this.createHtmlElemFromType(tagName||'icon');
        this.elemIcon.style.backgroundRepeat = 'no-repeat';
        this.elemIcon.style.backgroundOrigin="content-box";
        
        switch(this.scaleType){
            case 'content': this.elemIcon.style.backgroundSize = "contain"; break;
            case 'scale': this.elemIcon.style.backgroundSize="cover"; break;
            case 'original':  this.elemIcon.style.backgroundSize="auto"; break;
        }
        
        this.elemDom.appendChild(this.elemIcon);
        this.isSvg = false;
    }

    async loadIcon(){
        if(this.elemIcon){
            this.elemIcon.remove();
            this.image = null;
        }
        if(this.src){
            if(Resource.isImageResource(this.src)){
                if(this.src.lastIndexOf(".svg")===-1){
                    this.createDivIcon();
                    this.image = await Resource.loadImage(this.src);
                    this.elemIcon.style.background = `url('${this.image.src}')`;
                }else{
                    this.isSvg = true;
                    let svgResource = await Resource.loadLayoutSync(this.src);
                    this.elemIcon = this.elemDom.appendChild(svgResource);
                }
            }else if(Resource.isBase64Resource(this.src)){
                if(this.src.includes('data:image/svg;')){
                    this.isSvg = true;
                    let svgStr = window.atob(this.src.replace('data:image/svg;base64,',''));
                    this.elemDom.innerHTML=svgStr;
                    this.elemIcon = this.elemDom.firstElementChild;
                }else{
                    this.createDivIcon();
                    this.image = await Resource.loadImage(this.src);
                    this.elemIcon.style.background = `url('${this.image.src}')`;
                }
            }else
                throw new Exception(`El recurso [${this.src}] no es valido como imagen.`);
        }else{
            this.createDivIcon();
            this.elemIcon.style.background = '';
            this.image = null;
        }
    }

    getElemIcon(){
        return this.elemIcon;
    }
    
    // @Override
    async onMeasure(maxWidth, maxHeight) {
        if(this.image||this.isSvg){
            // Estableciendo dimensión de componente
            let maxIconW, maxIconH;
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.width = maxWidth +'px';
                    maxIconW = maxWidth - this.padding.left - this.padding.right;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    maxIconW = (this.isSvg?this.elemIcon.getBBox().width:this.image.width);
                    this.elemDom.style.width = (this.padding.left + maxIconW + this.padding.right)+'px';
                    break;
                default: // tamaño establecido por el usuario
                    let width = parseInt(this.width);
                    this.elemDom.style.width = width+'px';
                    maxIconW = width - this.padding.left - this.padding.right;
                    break;
            }
    
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.height = maxHeight +'px';
                    maxIconH = maxHeight-this.padding.top - this.padding.bottom;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    maxIconH = (this.isSvg?this.elemIcon.getBBox().height:this.image.height);
                    this.elemDom.style.height = (this.padding.top + maxIconH + this.padding.bottom)+'px';
                    break;
                default: // tamaño establecido por el usuario
                    let height = parseInt(this.height);
                    maxIconH = height - this.padding.left - this.padding.bottom;
                    this.elemDom.style.height = height+'px';
                    break;
            }
            
            if(!this.elemIcon)
                return;
            switch(this.scaleType){
                case 'content':
                    this.elemIcon.style.width = maxIconW+'px';
                    this.elemIcon.style.height = maxIconH+'px';
                    break;
                case 'scale':
                case 'original':
                    let wD,hD;
                    if(this.isSvg){
                        let rectSvg = this.elemIcon.getBBox();
                        wD = rectSvg.width;
                        hD = rectSvg.height;
                    }else{
                        wD = this.image.width;
                        hD = this.image.height;
                    }
                    let sourceRatio = wD / hD;
                    let targetRatio = maxIconW / maxIconH;
                    if (sourceRatio > targetRatio){
                        //maxIconW = maxIconW;
                        maxIconH = maxIconW/sourceRatio;
                    }
                    else{
                        maxIconW = maxIconH*sourceRatio;
                        //maxIconH = maxIconH;
                    }
                    this.elemIcon.style.backgroundSize=`${maxIconW}px ${maxIconH}px`;
                    this.elemIcon.style.width = maxIconW+'px';
                    this.elemIcon.style.height = maxIconH+'px';
                    break;
            }

            // Centramos la imagen
            this.elemIcon.style.top = (this.elemDom.clientHeight/2-this.elemIcon.clientHeight/2)+'px';
            if(this.offsetTop<this.padding.top)
                this.elemIcon.style.top = this.padding.top + 'px';

            this.elemIcon.style.left = (this.elemDom.clientWidth/2-this.elemIcon.clientWidth/2) + 'px';
            if(this.offsetLeft<this.padding.left)
                this.elemIcon.style.left = this.padding.left+'px';
            this.elemIcon.style.backgroundSize = `${this.elemIcon.clientWidth}px ${this.elemIcon.clientHeight}px`;
        }else{ // El ImageView no tiene imagen
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.width = maxWidth;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemDom.style.width = this.padding.left + this.padding.right;
                    break;
                default: // tamaño establecido por el usuario
                    this.elemDom.style.width = parseInt(this.width) + 'px';
                    break;
            }
    
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    this.elemDom.style.height = maxHeight;
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    this.elemDom.style.height = this.padding.top + this.padding.bottom;
                    break;
                default: // tamaño establecido por el usuario
                    this.elemDom.style.height = parseInt(this.height) + 'px';
                    break;
            }
        }
        await this.repaint();
    }

    async setImageResource(pathImage) {
        this.src = pathImage;
        await this.loadIcon();
        await this.onReMeasure();
    }

    getImageResource(){
        return this.src;
    }
}
// Class: src/view/ImageButton.js
class ImageButton extends ImageView{
    constructor(context,model){
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 4;
    }
};
// Class: src/view/Password.js
class Password extends View{
    // lines: 1,
    // maxLines: 10,
    // hint: null,
    // maxLength: -1,
    // readonly: false,
    constructor (context,model) {
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 0;
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
    }

    // @Override
    getTypeElement(){
        return 'input';
    }
    
    getText() {
        return this.elemDom.value;
    }

    setText(txt) {
        this.elemDom.value = txt;
    }

    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.elemDom.type = 'password';
        this.elemDom.value = this.text;
        this.elemDom.style.paddingTop = '6px';
        this.elemDom.style.paddingLeft = '6px';
        this.elemDom.style.paddingBottom = '6px';
        this.elemDom.style.paddingRight = '6px';
    }

    getWidth() {
        return super.getWidth()+6*2;
    }

    getHeight() {
        return super.getHeight()+6*2;
    }
}
// Class: src/view/Camera.js
class Camera extends View{
    constructor(context,model){
        super(context,model);
        this.captureAudio = false;
        this.captureVideo = true;
    }

    // @Override
    getTypeElement(){
        return 'video';
    }

    async start(){
        let stream = await navigator.mediaDevices.getUserMedia({
            video: this.captureVideo,
            audio: this.captureAudio
        });
        this.elemDom.srcObject = stream;
        this.elemDom.play();
    }

    async stop(){
        if(this.elemDom.srcObject){
            let tracks = this.elemDom.srcObject.getTracks();
            tracks.forEach(track =>{
                track.stop();
            });
        }
        this.elemDom.srcObject = null;
    }

    takePicture(){
        let canvas = document.createElement('canvas');
        canvas.width = this.getWidth();
        canvas.height = this.getHeight();
        canvas.style.visibility = "hidden";
        document.body.appendChild(canvas);
        
        let context = canvas.getContext('2d');
        context.drawImage(this.elemDom, 0, 0,this.getWidth(),this.getHeight());
        let imgBase64 = canvas.toDataURL('image/png');
        canvas.remove();
        return {
            fileExt: 'png',
            dataInBase64: imgBase64.replace("data:image/png;base64,","")
        }
    }
};
// Class: src/view/RadioButton.js
class RadioButton extends View{
    constructor (context,model) {
        super(context,model);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.onClick = Resource.getAttrOfTheme(this.constructor.name, 'onClick');
        this.radioGroup = Resource.getAttrOfTheme(this.constructor.name, 'radioGroup');
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.text = this.getAttrFromNodeXml(nodeXml,"text") || this.text;
        this.onClick = this.getAttrFromNodeXml(nodeXml,"onClick") || this.onClick;
        this.radioGroup = this.getAttrFromNodeXml(nodeXml,"radioGroup") || this.radioGroup;
    }

    // @Override
    getTypeElement(){
        return 'input';
    }
    
    getText() {
        return this.elemDom.value;
    }

    setText(txt) {
        this.elemDom.value = txt;
    }

    setEnabled(sw) {
        this.elemDom.disabled = !sw;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.elemDom.type = 'radio';
        this.elemDom.value = this.text;
        this.elemDom.name = this.radioGroup;

        // this.elemDom.style.height='50px';
        // this.elemDom.style.width='50px';
    }

    getWidth() {
        return super.getWidth();
    }

    getHeight() {
        return super.getHeight();
    }

    isChecked(){
        return this.elemDom.checked;
    }

    setChecked(checket){
        return this.elemDom.checked = checket===true;
    }
}
// Class: src/view/OptionItem.js
class OptionItem extends LinkButton{
    constructor(context,model){
        super(context,model);
        this.singleLine = true;
    }
};
// Class: src/view/Spinner.js
class Spinner extends Button{
    constructor(context,model){
        super(context,model);
        this.text = Resource.getAttrOfTheme(this.constructor.name, 'text');
        this.position = Resource.getAttrOfTheme(this.constructor.name, 'position');
        this.replaceableValue = Resource.getAttrOfTheme(this.constructor.name, 'replaceableValue')=='true'?true:false;

        this.popup = new PopupWindow(context);
        let linViews = new LinearLayout(this.popup);
        linViews.setWidth('200px');
        linViews.setHeight('160px');
        linViews.setOrientation('vertical');
        this.popup.setContentView(linViews);
        this.popup.setView(this);
        this.popup.setPositionOnView(this.position);
        this.selectedIndex = -1;
        this.onClickContext = super.context;
    }

    setOnClickListener(onClickListener,onClickContext){
        this.onClickItemDefinition = onClickListener;
        if(onClickContext)
            this.onClickContext = onClickContext;
        else
            this.onClickContext = arguments[1]||this.onClickContext;
        if (typeof this.onClickItemDefinition === 'function') {
            this.onClickListener = this.onClickItemDefinition;
        }
        else{
            if (typeof this.onClickItemDefinition === 'string') {
                // Buscamos el nombre de metodo en el contexto
                let propertyNames = Object.getOwnPropertyNames(Object.getPrototypeOf(this.context));
                if(propertyNames.find(property=>property===this.onClickItemDefinition)){
                    this.onClickListener = this.context[this.onClickItemDefinition];
                }else
                    throw new Exception(`No se pudo encontrar la funcion [${this.onClickItemDefinition}] dentro del contexto [${this.context.constructor.name}]`);
            }
            else 
                throw new Exception(`El objeto [${onClickItemListener}] no es valido para establecer el Listener de onClickItemListener`);
        }
        if(this.onClickListener){
            this.elemDom.onclick=()=>{
                if(this.audioClickMedia)
                    this.audioClickMedia.play();
                this.onClickToogleSpinner();
            };
        }
    }

    async onClickOptionItem(viewOption){
        this.hideOptions();
        let index = 0;
        for(let option of this.popup.getContentView().getChilds()){
            if(option === viewOption)
                break;
            index++;
        }
        if(index == this.popup.getContentView().getChilds().length){
            // No se encuentra lo seleccionado
            console.log("No se encuentra lo seleccionado");
        }else{
            if(this.replaceableValue){
                await this.setText(viewOption.getText());
                // await this.onReMeasure();
                // await this.context.onResize();
            }
            if(this.onClickListener){
                Reflect.apply(this.onClickListener, this.onClickContext, [viewOption]);
            }
        }
    }

    async onClickToogleSpinner(){
        if(this.popup.isVisible())
            this.hideOptions();
        else
            await this.showOptions();
    }

    getPopupContext(){
        return this.popup;
    }

    async showOptions(){
        let windowsDimension = PageManager.getWindowsDimension();
        // await this.popup.getViewRoot().onMeasure(windowsDimension.width, windowsDimension.height);
        await this.popup.show();
    }

    hideOptions(){
        this.popup.hide();
    }

    async addOptionItem(optionItem) {
        this.setOnClickListenerTo(optionItem, this.onClickOptionItem);
        await this.popup.getContentView().addView(optionItem);
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if(this.getAttrFromNodeXml(nodeXml,"position") != null){
            this.position = this.getAttrFromNodeXml(nodeXml,"position");
            this.popup.setPositionOnView(this.position);
        }
        if(this.getAttrFromNodeXml(nodeXml,"text") != null){
            this.text = this.getAttrFromNodeXml(nodeXml,"text");
        }
        if(this.getAttrFromNodeXml(nodeXml,"replaceableValue") != null){
            this.replaceableValue = this.getAttrFromNodeXml(nodeXml,"replaceableValue")=='true'?true:false;
        }

        switch(this.position){
            case 'top':
                this.popup.getContentView().setBackground(Resource.getAttrOfTheme(this.constructor.name, 'backgroundTop'));
                break;
            case 'bottom':
                this.popup.getContentView().setBackground(Resource.getAttrOfTheme(this.constructor.name, 'backgroundBottom'));
                break;
        }
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = await LayoutInflater.inflate(this.context, nodeChild,this.model);
            this.setOnClickListenerTo(child, this.onClickOptionItem);
            await this.popup.getContentView().addView(child);
        }
    }
};
// Class: src/view/WaitingView.js
class WaitingView extends View{
    constructor (context,model) {
        super(context,model);
    }

    // @Override
    createHtmlElement(){
        this.width='30px';
        this.height='30px';
        super.createHtmlElement();
        this.animation = new SpinnerAnimation({
            left: 0,
            top: 0,
            size: 30, 
            showBackground: false,
            backgroundRotation: false,
            parentElement: this.elemDom
        });
        this.animation.show();
    }

    async onMeasure(maxWidth, maxHeigth) {
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + 30 + this.padding.bottom; break;
            default: maxHeightElement = parseInt(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + 30 + this.padding.right; break;
            default: maxWidthElement = parseInt(this.width);
        }

        this.animation.resize(Math.min(maxWidthElement,maxWidthElement));
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }
}
// Class: src/view/WebView.js
class WebView extends View{
    constructor (context,model) {
        super(context,model);
        this.margin.left = this.margin.top = this.margin.right = this.margin.bottom = 0;
        this.src = null;
    }

    //@Override
    async createHtmlElement () {
        super.createHtmlElement();
        this.elemIframe = this.createHtmlElemFromType('iframe');
        this.elemDom.appendChild(this.elemIframe);
        return this.elemDom;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.src = this.getAttrFromNodeXml(nodeXml,"src") || this.src;
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        if(this.src)
            this.elemIframe.src=this.src;
    }
    
    setUrl(url) {
        this.url = url;
        this.elemIframe.src=this.url;
    }

    async onMeasure(maxWidth, maxHeigth) {
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: 
                maxHeightElement = maxHeigth; 
                this.elemIframe.height = maxHeigth-this.padding.top-this.padding.bottom;
                break;
            case LayoutInflater.WRAP_CONTENT:
                maxHeightElement = this.padding.top + this.elemIframe.clientHeight + this.padding.bottom;
                break;
            default:
                maxHeightElement = parseInt(this.height);
                this.elemIframe.height = maxHeightElement-this.padding.top-this.padding.bottom;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                maxWidthElement = maxWidth;
                this.elemIframe.width = maxWidth-this.padding.left-this.padding.right;
                break;
            case LayoutInflater.WRAP_CONTENT:
                maxWidthElement = this.padding.left + this.elemIframe.clientWidth + this.padding.right; 
                break;
            default:
                maxWidthElement = parseInt(this.width);
                this.elemIframe.width = maxWidthElement-this.padding.left-this.padding.right;
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }
}
// Class: src/view/event/TextChangeListener.js
class TextChangeListener {
    onChange(newText) {}
}
// Class: src/layout/ScrollView.js
class ScrollView extends View{
    constructor (context,model) {
        super(context,model);
        this.content = null;
        this.MIN_HEIGHT_THUMB=50; // 50px
        this.MIN_HEIGHT = 300;
        this.MIN_WIDTH = 500;
        this.PADDING_SCROLL=5;
    }

    // @Override
    findViewById(idView) {
        if(this.id && this.id === idView) {
            return this;
        }
        if(!this.content)
            return null;
        return this.content.findViewById(idView);
    }
    
    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if(nodeXml.children.length>1)
            throw new Exception(`El layout [ScrollView] no puede tener de un hijo. El hijo [${nodeXml.children[1].tabName}] debe ser borrado.`);
        if(nodeXml.children.length === 1){
            let view = await LayoutInflater.inflate(this.context, nodeXml.children[0],this.model);
            await this.setContent(view);
        }
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        this.bgBarScroll = new NinepathBackground(null,this.barScroll,'lib/imgs/bg_v_bar_scroll.9.png');
        await this.bgBarScroll.load();
        this.bgScroll = new NinepathBackground(null,this.scroll,'lib/imgs/bg_v_scroll.9.png');
        await this.bgScroll.load();
        this.scroll.style.width=(this.bgScroll.padding.left + this.bgScroll.padding.right+1)+'px';
        await this.addEventScroll();
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.barScroll = this.createHtmlElemFromType('BarScroll');
        this.scroll = this.createHtmlElemFromType('Scroll');
        this.bodyScroll = this.createHtmlElemFromType('BodyScroll');
        this.bodyScroll.style.overflow='hidden';

        this.elemDom.appendChild(this.bodyScroll);
        this.elemDom.appendChild(this.barScroll);
        this.elemDom.appendChild(this.scroll);
        return this.elemDom;
    }

    async setContent(view){
        this.content = view;
        view.parentView = this;
        await view.loadResources();
        this.bodyScroll.appendChild(view.elemDom);
        view.showView();
    }

    moveContent(dist){
        if(!this.moving)
            return;
        let alto = this.bodyScroll.clientHeight;
        if (this.lastTop + dist > 0)
            this.content.elemDom.style.top = '0px';
        else if (this.lastTop + dist + this.content.elemDom.clientHeight < alto)
            this.content.elemDom.style.top = (alto - this.content.elemDom.clientHeight) + 'px';
        else
            this.content.elemDom.style.top = (this.lastTop + dist) + 'px';

        if(this.content.elemDom.offsetTop<0){
            // Posicionamos el scroll
            let heightArea = this.bodyScroll.clientHeight;
            let viewableRatio =  heightArea/this.content.elemDom.clientHeight;

            let surplus =  Math.abs(this.content.elemDom.offsetTop)* viewableRatio;
            this.scroll.style.top=this.padding.top+this.bgBarScroll.padding.top+surplus+'px';
        }
        else
            this.scroll.style.top=(this.padding.top+this.bgBarScroll.padding.top)+'px';
    }

    startMovement(yClick){
        if(this.content.elemDom.clientHeight<this.bodyScroll.clientHeight)
            return;
        this.starty = yClick;
        this.moving = true;
        this.lastTop = this.content.elemDom.offsetTop;
        //this.content.elemDom.style.pointerEvents = "none";
    }

    stopMovement(){
        this.moving = false;
        //this.content.elemDom.style.pointerEvents = "auto";
    }

    async addEventScroll(){
        // MOUSE
        this.bodyScroll.onmouseenter=(event=>{
            this.stopMovement();
            event.preventDefault();
        });
        this.bodyScroll.onmousedown=(event=>{
            this.startMovement(parseInt(event.clientY));
            return true;
        });
        this.bodyScroll.onmouseup=(event=>{
            this.stopMovement();
            event.preventDefault();
        });
        this.bodyScroll.onmousemove=(event=>{
            if(!this.moving)
                return;
            let dist = parseInt(event.clientY) - this.starty;
            this.moveContent(dist);
            event.preventDefault();
            //event.stopPropagation();
            //return false;
        });

        // TOUCHS
        this.bodyScroll.ontouchstart=(evTouch=>{
            let event = evTouch.touches[0];
            this.startMovement(parseInt(event.clientY));
        });
        this.bodyScroll.ontouchmove=(evTouch=>{
            if(!this.moving)
                return;
            let event = evTouch.touches[0];
            let dist = parseInt(event.clientY) - this.starty;
            this.moveContent(dist);
        });
        this.bodyScroll.ontouchend=(evTouch=>{
            this.stopMovement();
        });
        this.bodyScroll.ontouchcancel=(evTouch=>{
            this.stopMovement();
        });
    }

    async onMeasure(maxWidth, maxHeight) {
        this.stopMovement();
        if(!this.content){
            await super.onMeasure(maxWidth,maxHeight);
            alert("Falta completar con Scroll Vacio");
            return;
        }

        this.bodyScroll.style.left=this.padding.left+'px';
        this.bodyScroll.style.top=this.padding.top+'px';

        let lastHeightContent = this.content.elemDom.clientHeight;
        
        let witchBarScroll = this.bgBarScroll.padding.left + this.bgScroll.padding.left+this.bgScroll.padding.right+this.bgBarScroll.padding.right;

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = maxWidth+'px';
                this.bodyScroll.style.width = (maxWidth- this.padding.left - this.padding.right - witchBarScroll)+'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = this.MIN_WIDTH+'px';
                this.bodyScroll.style.width = (this.MIN_WIDTH - this.padding.left - this.padding.right - witchBarScroll)+'px';
                break;
            default:
                let width = parseFloat(this.width);
                this.elemDom.style.width = width+'px';
                this.bodyScroll.style.width = (width - this.padding.left - this.padding.right - witchBarScroll)+'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = maxHeight+'px';
                this.bodyScroll.style.height = (maxHeight - this.padding.top - this.padding.bottom)+'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = this.MIN_HEIGHT+'px';
                this.bodyScroll.style.height = (this.MIN_HEIGHT - this.padding.top - this.padding.bottom)+'px';
                break;
            default:
                let height = parseFloat(this.height);
                this.elemDom.style.height = height+'px';
                this.bodyScroll.style.height = (height - this.padding.top - this.padding.bottom)+'px';
                break;
        }

        // Operaciones despues de pintar el Scroll
        await this.content.onMeasure(this.bodyScroll.clientWidth,this.bodyScroll.clientHeight);
        this.content.elemDom.style.left = 0+'px';
        await this.backgroundPainter.paint();

        // Verificamos si el contenido es de menor altura que el ScrollView
        if(this.content.elemDom.clientHeight<this.bodyScroll.clientHeight){
            this.barScroll.style.visibility = "hidden";
            this.scroll.style.visibility = "hidden";
            return;
        }else{
            this.barScroll.style.visibility = "visible";
            this.scroll.style.visibility = "visible";
        }

        // Pintamos el BarScroll
        this.barScroll.style.width=witchBarScroll+'px';
        this.barScroll.style.height=this.bodyScroll.clientHeight+'px';
        this.barScroll.style.left = (this.elemDom.clientWidth-this.barScroll.clientWidth-this.padding.right)+'px';
        this.barScroll.style.top = this.padding.top+'px';
        await this.bgBarScroll.paint();

        // Calculamos el tamanio del boton del scroll
        // Fuente: https://stackoverflow.com/questions/16366795/how-to-calculate-the-size-of-scroll-bar-thumb
        let heightArea = this.bodyScroll.clientHeight;
        let viewableRatio =  heightArea/this.content.elemDom.clientHeight;
        let thumbHeight = heightArea * viewableRatio;

        this.scroll.style.height = (thumbHeight-this.bgScroll.padding.top-this.bgScroll.padding.bottom)+'px';
        this.scroll.style.left = (this.elemDom.clientWidth-this.barScroll.clientWidth/2-this.padding.right-this.scroll.clientWidth/2)+'px';

        // Verificamos si es necesari mover el Scroll
        if(this.scroll.style.visibility === 'visible'){
            if(lastHeightContent !== this.content.elemDom.clientHeight){
                let posLastY = this.barScroll.clientHeight/2;

                if(this.content.elemDom.offsetTop === 0){
                    this.content.elemDom.style.top = 0+'px';
                    this.scroll.style.top = (this.padding.top+this.bgBarScroll.padding.top)+'px';
                }else{
                    if(this.content.elemDom.clientHeight > lastHeightContent){

                    }
                    else{
                        let lastScrollY = this.scroll.offsetTop;
                        let lastContentY = this.content.elemDom.offsetTop;
                    }
                }
            }
            // (lastHeightContent === this.content.elemDom.clientHeight){
                // No realizar nada si la altura no cambio
        }
        else{
            this.content.elemDom.style.top = 0+'px';
            this.scroll.style.top = (this.padding.top+this.bgBarScroll.padding.top)+'px';
        }
        
        await this.bgScroll.paint();
    }
};
// Class: src/layout/Container.js
class Container extends View{
    constructor(context,model){
        super(context,model);
        this.viewsChilds = new Array();
    }

    getViewVisibles() {
        // agrupamos los GONE's y los INVISIBLE's
        let vistos = new Array();
        for (let index = 0; index < this.viewsChilds.length; index++) {
            let view = this.viewsChilds[index];
            if (view.visibility === View.VISIBLE || view.visibility === View.INVISIBLE)
                vistos.push(view);
        }
        return vistos;
    }

    async removeAllViews(){
        for(let view of this.viewsChilds){
            view.elemDom.remove();
        }
        this.viewsChilds = new Array();
        await this.onReMeasure();
    }

    // @Override
    findViewById(idView) {
        let view = super.findViewById(idView);
        if (view)
            return view;
        for (let view of this.viewsChilds) {
            let tempView = view.findViewById(idView);
            if(tempView)
                return tempView;
        }
        return null;
    }

    async removeView(viewChild){
        let index = this.viewsChilds.indexOf(viewChild);
        if (index === -1)
            throw new Exception(`No se encontro el view [${viewChild}] en la vista [${this.constructor.name}]`);
        this.viewsChilds.splice(index, 1);
        viewChild.elemDom.remove();
        await this.onReMeasure();
    }
    
    //@Override
    async loadResources(){
        await super.loadResources();
        for(let view of this.viewsChilds)
            await view.loadResources();
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeight){
        await super.onMeasure(maxWidth, maxHeight);
        for(let view of this.viewsChilds)
            await view.onMeasure(maxWidth, maxHeight);
    }

    getChildCount() {
        return this.viewsChilds.length;
    }

    getChildAt(i) {
        return this.viewsChilds[i];
    }

    getChilds(){
        return this.viewsChilds;
    }

    getFirstChild(){
        if(this.viewsChilds.length>0)
            return this.viewsChilds[0];
        return null;
    }

    async addView(viewChild) {
        if (viewChild === null || viewChild === undefined)
            throw new Exception("El View que desea agregar es nulo o no esta definido");
        if(!viewChild instanceof View)
            throw new Exception(`El objeto [${viewChild}] a agregar no es una instancia de View`);
        this.viewsChilds.push(viewChild);
        viewChild.parentView = this;

        await viewChild.loadResources();
        this.elemDom.appendChild(viewChild.elemDom);
        if(this.elemDom.style.visibility==='visible'){
            await this.onReMeasure();
            viewChild.showView();
        }
    }

    async setFirstChild(viewChild){
        for(let view of this.viewsChilds){
            view.elemDom.remove();
        }
        this.viewsChilds = new Array();
        await this.addView(viewChild);
    }

    getContentWidth(maxWidth,viewChild){
        switch (this.width) {
            case LayoutInflater.WRAP_CONTENT:
            case LayoutInflater.MATCH_PARENT:
                if(viewChild){
                    if(viewChild.maxWidth > 0 && maxWidth > viewChild.maxWidth)
                        maxWidth = viewChild.maxWidth;
                    return maxWidth - this.padding.left - this.padding.right - viewChild.margin.left - viewChild.margin.right;
                }
                return maxWidth - this.padding.left - this.padding.right;
            default: // Tamanio especifico 
                let lenght = parseInt(this.width);
                if(viewChild){
                    if(viewChild.maxWidth > 0 && lenght > viewChild.maxWidth)
                        lenght = viewChild.maxWidth;
                    return lenght - this.padding.left - this.padding.right - viewChild.margin.left - viewChild.margin.right;
                }
                return lenght - this.padding.left - this.padding.right;
        }
    }

    getContentHeight(maxHeight,viewChild){
        switch (this.height) {
            case LayoutInflater.WRAP_CONTENT:
            case LayoutInflater.MATCH_PARENT:
                if(viewChild){
                    if(viewChild.maxHeight>0 && maxHeight>viewChild.maxHeight)
                        maxHeight = viewChild.maxHeight;
                    return maxHeight - this.padding.top - this.padding.bottom - viewChild.margin.top - viewChild.margin.bottom;
                }
                return maxHeight - this.padding.top - this.padding.bottom;
            default: // Tamanio especifico 
                let lenght = parseInt(this.height);
                if(viewChild){
                    if(viewChild.maxHeight > 0 && lenght > viewChild.maxHeight)
                        lenght = viewChild.maxHeight;
                }
                return lenght - this.padding.top - this.padding.bottom;
        }
    }
}
// Class: src/layout/ViewGroup.js
class ViewGroup extends Container{
    constructor(context,model){
        super(context,model);
    }
    
    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = await this.parseViewChild(nodeChild);
            child.parentView = this;
            this.viewsChilds.push(child);
            this.elemDom.appendChild(child.elemDom);
        }
    }

    async parseViewChild(nodeXml) {
        let child = await LayoutInflater.inflate(this.context, nodeXml,this.model);
        return child;
    }
}
// Class: src/layout/LinearLayout.js
class LinearLayout extends ViewGroup {
    constructor(context,model) {
        super(context,model);
    }

    //Override
    async parse(nodeXml) {
        if (this.getAttrFromNodeXml(nodeXml,'orientation') === 'vertical')
            this.orientation = 'vertical';
        else if (this.getAttrFromNodeXml(nodeXml,'orientation') === 'horizontal')
            this.orientation = 'horizontal';
        else
            throw new Exception(
                `La orientación para LinearLayout debe ser unicamente [horizontal o vertical]. Establesca el atributo [orientation] para definir la orientación de la vista`);
        await super.parse(nodeXml);
    }

    //Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        view.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY);

        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WEIGHT) !== null){
            let weight = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_WEIGHT);
            var num = parseFloat(weight);
            if (isNaN(num) === true)
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_WEIGHT}] del view [${this.constructor.name}] no es un número flotante [${weight}]`);

            if (!(num > 0.0 && num <= 1.0))
                throw new Exception(
                    `El valor del atributo [${LayoutInflater.ATTR_WEIGHT}] es [${weight}] del view [${this.constructor.name}] no esta del rango válido entre [0.0 y 1.0]`);
            view.weight = num;
        }
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        if (this.orientation === 'vertical')
            await this.onMeasureVertical(visibles,maxWidth,maxHeight);
        else{ // horizontal
            await this.onMeasureHorizontal(visibles,maxWidth,maxHeight);
        }
        await this.repaint();
    }

    async onMeasureVertical(visibles, maxWidth, maxHeight) {
        let sumHeight = this.padding.top;
        let mayWidth = this.padding.left + this.padding.right;

        let sumHeigthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            if (view.weight !== undefined && view.weight !== null && view.weight > 0)
                arrayWeigh.push(view);
            else{
                await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumHeigthWrap += (view.margin.top + view.getHeight() + view.margin.bottom);
                if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right) > mayWidth)
                    mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
                sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
            }
        }

        // Estableciendo alto de los componentes que tiene weight
        if(this.height === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [weight] en uno de los hijos del [LinearLayout] con orientación [${this.orientation}] pero el ALTO se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let altoWeigth = this.getContentHeight(maxHeight) - sumHeigthWrap;
        for(let view of arrayWeigh){
            await view.onMeasure(this.getContentWidth(maxWidth,view) , altoWeigth*view.weight - view.margin.top - view.margin.bottom);
            if((this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right)>mayWidth)
                mayWidth = (this.padding.left + view.margin.left + view.getWidth() + view.margin.right + this.padding.right);
            sumHeight+=(view.margin.top + view.getHeight() + view.margin.bottom);
        }

        // Estableciendo dimenciones del componente
        let maxWidthElement, maxHeightElement;
        sumHeight = sumHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = sumHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posTop = this.padding.top;
        for(let view of visibles){
            // Posición horizontal
            view.layoutGravity = view.layoutGravity || LayoutInflater.LEFT;
            let gravitys = view.layoutGravity.split("|");
            for(let layoutGravity of gravitys){
                switch (layoutGravity) {
                    case LayoutInflater.LEFT:
                        view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                        break;
                    case LayoutInflater.RIGHT:
                        view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                        break;
                    case LayoutInflater.CENTER_HORIZONTAL:
                        view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${layoutGravity}]. Utilice unicamente [${LayoutInflater.LEFT},${LayoutInflater.RIGHT},${LayoutInflater.CENTER_HORIZONTAL}]`);
                }
            }

            // Posición vertical
            view.elemDom.style.top = (posTop + view.margin.top) + 'px';
            posTop = posTop + view.margin.top + view.getHeight() + view.margin.bottom;
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    async onMeasureHorizontal(visibles, maxWidth, maxHeight) {
        let mayHeight = this.padding.top + this.padding.bottom;

        let sumWidthWrap = 0;
        let arrayWeigh = new Array();

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            if (view.weight !== undefined && view.weight !== null && view.weight > 0){
                arrayWeigh.push(view);
            }
            else{
                await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
                sumWidthWrap += (view.margin.left + view.getWidth() + view.margin.right);
                if ((this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                    mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            }
        }

        let sumWidth = this.padding.left + sumWidthWrap;

        // Estableciendo alto de los componentes que tiene weight
        if(this.width === LayoutInflater.WRAP_CONTENT && arrayWeigh.length >0)
            throw new Exception(`Se especifico el atributo [weight] en uno de los hijos del [LinearLayout] con orientación [${this.orientation}] pero el ALTO se definio como [${LayoutInflater.WRAP_CONTENT}]. Especifique un tamaño fijo o ajustado al padre con [${LayoutInflater.MATCH_PARENT}]`);
        let anchoWeigth = this.getContentWidth(maxWidth) - sumWidthWrap;
        for(let view of arrayWeigh){
            await view.onMeasure(anchoWeigth*view.weight - view.margin.left - view.margin.right, this.getContentHeight(maxHeight,view));
            if ( (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom) > mayHeight)
                mayHeight = (this.padding.top + view.margin.top + view.getHeight() + view.margin.bottom + this.padding.bottom);
            sumWidth+=(view.margin.left + view.getWidth() + view.margin.right);
        }

        // Verificando tamano de 
        let maxWidthElement, maxHeightElement;
        sumWidth = sumWidth + this.padding.right;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: 
                maxWidthElement = sumWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        
        // Dibujando las vistas
        let posLeft = this.padding.left;
        for(let view of visibles){
            // Posición vertical
            view.layoutGravity = view.layoutGravity || LayoutInflater.TOP;
            let gravitys = view.layoutGravity.split("|");
            for(let layoutGravity of gravitys){
                switch (layoutGravity) {
                    case LayoutInflater.TOP:
                        view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                        break;
                    case LayoutInflater.BOTTOM:
                        view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.top - this.padding.top) + 'px';
                        break;
                    case LayoutInflater.CENTER_VERTICAL:
                        view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                        break;
                    default:
                        throw new Exception(
                            `La orientación para el LinearLayout es [${this.orientation}] y la vista [${view.constructor.name}] tiene asignado la alineación [${layoutGravity}]. Utilice unicamente [${LayoutInflater.TOP},${LayoutInflater.BOTTOM},${LayoutInflater.CENTER_VERTICAL}]`);
                }
            }
            // Posición horizontal
            view.elemDom.style.left = (posLeft + view.margin.left) + 'px';
            posLeft = posLeft + view.margin.left + view.getWidth() + view.margin.right;
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
    }

    setOrientation(orientation) {
        this.orientation = orientation;
    }
}
// Class: src/layout/FrameLayout.js
class FrameLayout extends ViewGroup {
    constructor(context,model) {
        super(context,model);
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        view.layoutGravity = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_GRAVITY)||'left|top';
        return view;
    }

    // @Override
    async addView(viewChild) {
        viewChild.layoutGravity = viewChild.layoutGravity || 'left|top';
        await super.addView(viewChild);
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        //  Dibujamos todos los componentes
        let mayHeight = this.padding.top + this.padding.bottom;
        let mayWidth = this.padding.left + this.padding.right;
        for(let view of visibles){
            await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
            if((view.margin.left+this.padding.left+view.getWidth()+this.padding.right+view.margin.right) > mayWidth)
                mayWidth = (view.margin.left+this.padding.left+view.getWidth()+this.padding.right+view.margin.right);
            if((view.margin.top+this.padding.top+view.getHeight()+this.padding.bottom+view.margin.bottom) > mayHeight)
                mayHeight = (view.margin.top+this.padding.top+view.getHeight()+this.padding.bottom+view.margin.bottom);
        }
        let maxWidthElement,maxHeightElement;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }

        for(let view of visibles){
            let gravitys = view.layoutGravity.split("|");
            let leftAligned =false;
            let topAligned =false;
            for (let j = 0; j < gravitys.length; j++) {
                let layoutGravity = gravitys[j];
                if (layoutGravity === LayoutInflater.TOP){
                    view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
                    topAligned=true;
                }
                if (layoutGravity === LayoutInflater.RIGHT){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement - view.getWidth() - view.margin.right - this.padding.right) + 'px';
                }
                if (layoutGravity === LayoutInflater.LEFT){
                    leftAligned = true;
                    view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                }
                if (layoutGravity === LayoutInflater.BOTTOM){
                    view.elemDom.style.top = (maxHeightElement - view.getHeight() - view.margin.bottom - this.padding.bottom) + 'px';
                    topAligned=true;
                }
                if (layoutGravity === LayoutInflater.CENTER_HORIZONTAL){
                    leftAligned = true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                }
                if (layoutGravity === LayoutInflater.CENTER_VERTICAL){
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                    topAligned=true;
                }
                if (layoutGravity === LayoutInflater.CENTER){
                    leftAligned = true;
                    topAligned=true;
                    view.elemDom.style.left = (maxWidthElement / 2 - view.getWidth() / 2) + 'px';
                    view.elemDom.style.top = (maxHeightElement / 2 - view.getHeight() / 2) + 'px';
                }
            }
            if(!leftAligned)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            if(!topAligned)
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
        }
        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaint();
    }
}
// Class: src/layout/RelativeLayout.js
class RelativeLayout extends ViewGroup{
    constructor(context,model) {
        super(context,model);
    }

    //@Override
    async parseViewChild(nodeXml) {
        var view = await super.parseViewChild(nodeXml);
        view.alignParentTop = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTTOP) === "true");
        view.alignParentRight = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTRIGHT) === "true");
        view.alignParentBottom = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTBOTTOM) === "true");
        view.alignParentLeft = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ALIGNPARENTLEFT) === "true");
        
        view.centerHorizontal = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERHORIZONTAL) === "true");
        view.centerVertical = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERVERTICAL) === "true");
        view.centerInParent = (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_CENTERINPARENT) === "true");
        
        view.above = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_ABOVE);
        view.below = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_BELOW);
        view.toRightOf = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TORIGHTOF);
        view.toLeftOf = this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_TOLEFTOF);
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        await super.onMeasure(maxWidth, maxHeight);
        let visibles = this.getViewVisibles();
        var mayHeight = 0;
        var mayWidth = 0;
        // Dibujando todos los componentes sin posicionarlos para obtener sus dimensiones candidato
        for(let view of visibles){
            await view.onMeasure(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);
            let sumWidth = this.padding.left + view.margin.left + view.elemDom.clientWidth + view.margin.right + this.padding.right;
            if (sumWidth > mayWidth)
                mayWidth = sumWidth;
            let sumHeight = this.padding.top + view.margin.top + view.elemDom.clientHeight + view.margin.bottom + this.padding.bottom;
            if (sumHeight > mayHeight)
                mayHeight = sumHeight;
        }

        // Iteramos nuevamente para posicionar los elementos a partir de su dimesion y respecto a sus referencias
        for(let view of visibles){
            await view.onMeasure(
                maxWidth- this.padding.left - this.padding.right,
                maxHeight-this.padding.top - this.padding.bottom);

            // Posicionamos la vista segun el layout
            if (view.alignParentTop === true)
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.alignParentRight === true)
                view.elemDom.style.left = (this.elemDom.clientWidth - view.elemDom.clientWidth - view.margin.right - this.padding.right) + 'px';
            if (view.alignParentLeft === true)
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            if (view.alignParentBottom === true)
                view.elemDom.style.top = (this.elemDom.clientHeight - view.elemDom.clientHeight - view.margin.bottom - this.padding.bottom) + 'px';

            if (view.centerHorizontal === true)
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
            if (view.centerVertical === true)
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            if (view.centerInParent === true) {
                view.elemDom.style.left = (this.elemDom.clientWidth / 2 - view.elemDom.clientWidth / 2) + 'px';
                view.elemDom.style.top = (this.elemDom.clientHeight / 2 - view.elemDom.clientHeight / 2) + 'px';
            }

            // Ubicación respecto a otros elementos
            // ATTR_ABOVE:"above",//id
            if (view.above) {
                var viewAbove = this.findViewById(view.above);
                if (!viewAbove)
                    throw new Exception(`No se encuentra el view hijo con id [${view.above}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewAbove.elemDom.style.top) - viewAbove.margin.top - view.elemDom.clientHeight - view.margin.bottom) + 'px';
            }
            // ATTR_BELOW:"below",//id
            if (view.below) {
                var viewBelow = this.findViewById(view.below);
                if (!viewBelow)
                    throw new Exception(`No se encuentra el view hijo con id [${view.below}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                view.elemDom.style.top = (parseInt(viewBelow.elemDom.style.top) + viewBelow.elemDom.clientHeight + viewBelow.margin.bottom + view.margin.top) + 'px';
            }
            // ATTR_TORIGHTOF:"toRightOf",//id
            if (view.toLeftOf) {
                var viewToLeft = this.findViewById(view.toLeftOf);
                if (!viewToLeft)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toLeftOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);
                if (view.alignParentLeft === true) {
                    await view.onMeasure(
                        parseInt(viewToLeft.elemDom.style.left) - view.margin.left - view.margin.right,
                        this.elemDom.clientHeight - this.padding.top - this.padding.bottom);
                        // Posiblemente pintar de nuevo la vista de fondo
                }
                else if (view.toRightOf !== null) {
                    console.log("Entrando por aquiiiiiaaaaaaaaaaaaaaaaaai. Pendiente");
                }
                else {
                    view.elemDom.style.left = (parseInt(viewToLeft.elemDom.style.left) - view.elemDom.clientWidth - view.margin.right) + 'px';
                }
            }
            // ATTR_TOLEFTOF:"toLeftOf",//id
            if (view.toRightOf) {
                var viewToRight = this.findViewById(view.toRightOf);
                if (viewToRight === null)
                    throw new Exception(`No se encuentra el view hijo con id [${view.toRightOf}] citado en la vista [${view.name}], para el contenedor [${this.name}]`);

                view.elemDom.style.left = (
                    parseInt(viewToRight.elemDom.style.left)
                    + viewToRight.margin.left
                    + viewToRight.elemDom.clientWidth
                    + viewToRight.margin.right
                    + view.margin.left) + 'px';
            }

            // verificando si tiene position top
            if (view.elemDom.style.top === "")
                view.elemDom.style.top = (this.padding.top + view.margin.top) + 'px';
            if (view.elemDom.style.left === "")
                view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
            var sum = parseInt(view.elemDom.style.top) + view.getHeight() + this.padding.bottom + view.margin.bottom;
            if (sum > mayHeight)
                mayHeight = sum;
            sum = parseInt(view.elemDom.style.left) + view.getWidth() + this.padding.right + view.margin.right;
            if (sum > mayWidth)
                mayWidth = sum;
        }
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = `${mayHeight}px`;
                await this.repaint();
                break;
            default: break;
        }
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = `${mayWidth}px`;
                await this.repaint();
                break;
            default: break;
        }
    }
};
// Class: src/layout/GridLayout.js
class GridLayout extends ViewGroup {
    constructor(context,model) {
        super(context,model);
        this.colums =2;
        this.horizontalSpace = 0;
        this.verticalSpace = 0;
        this.minWidthView = 50;
        this.minHeightView = 20;
    }

    //@Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if (this.width === LayoutInflater.WRAP_CONTENT)
            throw new Exception(`No se permite el ancho dinamico de tipo [${LayoutInflater.WRAP_CONTENT}] para el atributo [width] de la vista [GridLayout]`);

        if (this.getAttrFromNodeXml(nodeXml,"colums"))
            this.colums = parseInt(this.getAttrFromNodeXml(nodeXml,"colums"));
        if (this.getAttrFromNodeXml(nodeXml,"horizontalSpace"))
            this.horizontalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,"horizontalSpace"));
        if (this.getAttrFromNodeXml(nodeXml,"verticalSpace"))
            this.verticalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,"verticalSpace"));
        if (this.getAttrFromNodeXml(nodeXml,"minWidthView"))
            this.minWidthView = parseInt(this.getAttrFromNodeXml(nodeXml,"minWidthView"));
        if (this.getAttrFromNodeXml(nodeXml,"minHeightView"))
            this.minHeightView = parseInt(this.getAttrFromNodeXml(nodeXml,"minHeightView"));
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        // if (nodeXml,LayoutInflater.ATTR_WIDTH) === LayoutInflater.MATCH_PARENT)
        //     throw `No puede establecer un ancho [${LayoutInflater.ATTR_WIDTH}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        if (this.getAttrFromNodeXml(nodeXml,LayoutInflater.ATTR_HEIGHT) === LayoutInflater.MATCH_PARENT)
            throw `No puede establecer un alto [${LayoutInflater.ATTR_HEIGHT}] de tipo [${LayoutInflater.MATCH_PARENT}] para la vista [${nodeXml.tagName}] en el contenedor [GridLayout]`;
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeigth){
        let visibles = this.getViewVisibles();
        let maxAnchoView = this.getContentWidth(maxWidth) / this.colums;

        let y = this.padding.top , x;
        let index = 0;
        let mayHeight = 0;

        while(index < visibles.length){
            x = this.padding.left;
            mayHeight = 0;
            for(let j=1; j <=this.colums && index < visibles.length; j++) {
                let view = visibles[index];
                await view.onMeasure(maxAnchoView , maxHeigth);
                view.elemDom.style.top  = `${y+view.margin.top}px`;
                view.elemDom.style.left  = `${x+view.margin.left}px`;
                x+=maxAnchoView;
                if(view.margin.top+view.getHeight()+view.margin.bottom>mayHeight)
                    mayHeight = view.margin.top+view.getHeight()+view.margin.bottom;
                index++;
            }
            y=y+ mayHeight+this.verticalSpace;
        }

        let maxWidthElement, maxHeightElement;
        //y= y + mayHeight + this.padding.bottom;

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = y; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            // case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break; // Este caso no se presentara
            default: maxWidthElement = parseFloat(this.width);
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        await this.repaint();
    }
}
// Class: src/layout/Component.js
class Component extends Container {
    constructor(context,model){
        super(context,model);
        this.layoutUrl = null;
        this.inflated=false;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        let layoutUrl = this.getAttrFromNodeXml(nodeXml,'layoutUrl')||this.layoutUrl;
        if(layoutUrl === null || layoutUrl !== undefined)
            await this.setContentView(layoutUrl);
    }
    
    async onCreate(){}

    // @Override
    async loadResources(){
        await super.loadResources();
        if(this.inflated){
            return;
        }
        if(this.layoutUrl===null || this.layoutUrl === undefined){
            this.inflated = true;
            await this.onCreate();
            return;
        }
        if(this.layoutUrl instanceof View){
            await this.layoutUrl.loadResources();
            await this.setFirstChild(layoutUrl);
            if(this.elemDom.style.visibility==='visible')
                this.layoutUrl.showView();
        }else{
            let viewInflate =  await LayoutInflater.inflate(this.getContext(),this.layoutUrl,this.model);
            await viewInflate.loadResources();
            await this.setFirstChild(viewInflate);
            if(this.elemDom.style.visibility==='visible')
                viewInflate.showView();
        }
        this.layoutUrl = null;
        this.inflated = true;
        await this.onCreate();
    }

    setContentView(layoutUrl){
        this.layoutUrl = layoutUrl;
    }

    setData(data){
        this.data = data;
    }

    getContextView(){
        return this;
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeigth) {
        if(this.width !== LayoutInflater.MATCH_PARENT && this.width !== LayoutInflater.WRAP_CONTENT)
            maxWidth = parseFloat(this.width);
        if(this.height !== LayoutInflater.MATCH_PARENT && this.height !== LayoutInflater.WRAP_CONTENT)
            maxHeigth = parseFloat(this.height);

        if(!this.getFirstChild()){ // No se asigno el contenido
            console.log("No se asigno el contenido");
            let maxWidthElement, maxHeightElement;
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
                case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + this.padding.bottom; break;
                default: maxHeightElement = maxHeigth;
            }
    
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
                case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + this.padding.right; break;
                default: maxWidthElement = maxWidth;
            }
    
            this.elemDom.style.height = `${maxHeightElement}px`;
            this.elemDom.style.width = `${maxWidthElement}px`;
            return;
        }

        await this.getFirstChild().onMeasure(
            maxWidth - this.padding.left - this.padding.right,
            maxHeigth - this.padding.top - this.padding.bottom);
 
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + this.getFirstChild().getHeight() + this.padding.bottom; break;
            default: maxHeightElement = maxHeigth;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + this.getFirstChild().getWidth() + this.padding.right; break;
            default: maxWidthElement = maxWidth;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }
};
// Class: src/layout/FormLayout.js
class FormLayout extends Container {
    constructor(context,model){
        super(context,model);
    }

    // @Override
    findViewById(idView) {
        let view = super.findViewById(idView);
        if(view)
            return view;
        return this.getFirstChild().findViewById(idView);
    }

    // @Override
    getTypeElement(){
        return 'form';
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        if(nodeXml.children.length > 1 || nodeXml.children.length === 0)
            throw new Exception(`El layout [${this.constructor.name}] tiene [${nodeXml.children.length}] vistas y solo es permitido 1 vista.`);

        let nodeChild = nodeXml.children[0];
        let child = await this.parseViewChild(nodeChild);
        if(!(child instanceof Container))
            throw new Exception(`La vista [${child.constructor.name}] no es una extención [Container].`);
        child.parentView = this;
        this.viewsChilds.push(child);
        this.elemDom.appendChild(child.elemDom);
    }

    async parseViewChild(nodeXml) {
        let child = await LayoutInflater.inflate(this.context, nodeXml,this.model);
        return child;
    }
    
    //@Override
    async onMeasure(maxWidth, maxHeigth) {
        if(this.width !== LayoutInflater.MATCH_PARENT && this.width !== LayoutInflater.WRAP_CONTENT)
            maxWidth = parseFloat(this.width);
        if(this.height !== LayoutInflater.MATCH_PARENT && this.height !== LayoutInflater.WRAP_CONTENT)
            maxHeigth = parseFloat(this.height);

        await this.getFirstChild().onMeasure(
            maxWidth - this.padding.left - this.padding.right,
            maxHeigth - this.padding.top - this.padding.bottom);
 
        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeigth; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = this.padding.top + this.getFirstChild().getHeight() + this.padding.bottom; break;
            default: maxHeightElement = maxHeigth;
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = this.padding.left + this.getFirstChild().getWidth() + this.padding.right; break;
            default: maxWidthElement = maxWidth;
        }

        this.elemDom.style.height = `${maxHeightElement}px`;
        this.elemDom.style.width = `${maxWidthElement}px`;
        
        await this.repaint();
    }

    validate(){

    }
};
// Class: src/layout/RadioGroup.js
class RadioGroup extends LinearLayout{
    constructor(context,model) {
        super(context,model);
        this.groupName = Math.random().toString(36).slice(-5);
    }

    //@Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        if(!(view instanceof RadioButton))
            throw new Exception(`El [${view.constructor.name}] no es valido para el [${this.constructor.name}]. Utilice únicamente [RadioBUtton]`);
        return view;
    }
}
// Class: src/layout/FlowLayout.js
class FlowLayout extends ViewGroup {
    constructor(context,model) {
        super(context,model);
        this.alignment="center";
        this.verticalSpace = 0;
        this.horizontalSpace = 0;
    }

    //Override
    async parse(nodeXml) {
        this.alignment = this.getAttrFromNodeXml(nodeXml,'alignment')||this.alignment;
        if (this.getAttrFromNodeXml(nodeXml,"verticalSpace"))
            this.verticalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,'verticalSpace'));
        if (this.getAttrFromNodeXml(nodeXml,"horizontalSpace"))
            this.horizontalSpace = parseInt(this.getAttrFromNodeXml(nodeXml,'horizontalSpace'));
        await super.parse(nodeXml);
    }

    //Override
    async parseViewChild(nodeXml) {
        let view = await super.parseViewChild(nodeXml);
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        let visibles = this.getViewVisibles();
        let mayHeight = this.verticalSpace;
        let mayWidth = this.horizontalSpace;

        // Establenciendo dimensión de los componentes que no tienen weight
        for(let view of visibles){
            await view.onMeasure(this.getContentWidth(maxWidth,view),this.getContentHeight(maxHeight,view));
            let h = view.margin.top + view.getHeight() + view.margin.bottom + this.verticalSpace;
            let w = view.margin.left + view.getWidth() + view.margin.right + this.horizontalSpace;

            if (h > mayHeight)
                mayHeight = h;
            if (w > mayWidth)
                mayWidth = w;
        }

        let maxWidthElement, maxHeightElement;
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = mayHeight; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = mayWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }

        let posY = this.padding.top;
        mayHeight = 0;
        let i = 0
        let rowI=0;
        let wContent = maxWidthElement - this.padding.left - this.padding.right;
        let acumulate = 0;
        let mayAcumulate = 0;

        while(i < visibles.length){
            let view = visibles[i];
            let w = view.margin.left + view.getWidth() + view.margin.right;
            let h = view.margin.top + view.getHeight() + view.margin.bottom;
            if(this.padding.left + acumulate + w +this.horizontalSpace+this.padding.right> wContent){
                let posStart;
                if(this.alignment === 'left')
                    posStart = 0;
                else // center
                    posStart = (wContent/2-acumulate/2);
                
                // Esto es solo para centrar todos los de la fila
                for(let j = rowI;j <i ; j++){
                    let viewRow = visibles[j];
                    viewRow.elemDom.style.left  = `${this.padding.left+viewRow.margin.left+posStart}px`;
                    posStart+=(viewRow.margin.left+viewRow.elemDom.clientWidth + viewRow.margin.right + this.horizontalSpace);
                }
                posY = posY + mayHeight + this.verticalSpace;
                mayHeight = 0;
                if(acumulate>mayAcumulate)
                    mayAcumulate = acumulate;
                acumulate = 0;
                rowI = i;
            }
            view.elemDom.style.top  = `${view.margin.top + posY}px`;
            if (h > mayHeight)
                mayHeight = h;
            acumulate+=w;
            i++
        }

        let posStart;
        if(this.alignment === 'left')
            posStart = 0;
        else // center
            posStart = (wContent/2-acumulate/2);

        // Esto es solo para centrar todos los de la fila
        for(let j = rowI;j <i ; j++){
            let viewRow = visibles[j];
            viewRow.elemDom.style.left  = `${this.padding.left+viewRow.margin.left+posStart}px`;
            posStart+=(viewRow.margin.left+viewRow.elemDom.clientWidth + viewRow.margin.right + this.horizontalSpace);
        }
        if(acumulate > mayAcumulate)
            mayAcumulate = acumulate;

        if(this.height === LayoutInflater.WRAP_CONTENT)
            maxHeightElement = posY + mayHeight + this.padding.bottom;
        if(this.width === LayoutInflater.WRAP_CONTENT)
            maxWidthElement = (this.padding.left + mayAcumulate + this.padding.right)+'px';
        this.elemDom.style.width = maxWidthElement+'px';
        this.elemDom.style.height = maxHeightElement+'px';
        await this.repaint();
    }
}
// Class: src/layout/TabLayout.js
class TabLayout extends View {
    constructor(context,model) {
        super(context,model);
        this.tabSelected=-1;
        this.tabs = new Array();
        this.tabContentBg = null;
        this.colorTabTitle='#D2D3D5';
        this.audioClickTabMedia = null;
        this.audioAdoveTabMedia = null;
        this.audioClickTab = Resource.getAttrOfTheme(this.constructor.name, 'audioClickTab');
        this.audioAdoveTab = Resource.getAttrOfTheme(this.constructor.name, 'audioAdoveTab');
    }

    //@Override
    createHtmlElement() {
        super.createHtmlElement();
        this.textTabs = this.createHtmlElemFromType('TextTabs');
        this.contentTab = this.createHtmlElemFromType('ContentTab');

        this.container = this.createHtmlElemFromType('BodyTab');
        this.container.appendChild(this.textTabs);
        this.container.appendChild(this.contentTab);
        this.elemDom.appendChild(this.container);
        return this.elemDom;
    }

    // @Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        this.colorTabTitle = this.getAttrFromNodeXml(nodeXml,'colorTabTitle')||this.colorTabTitle;
        this.audioClickTab = this.getAttrFromNodeXml(nodeXml,"audioClickTab") || this.audioClickTab;
        this.audioAdoveTab = this.getAttrFromNodeXml(nodeXml,"audioAdoveTab") || this.audioAdoveTab;
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let view = await this.parseViewChild(nodeChild);
            await this.addTab(view,view.tabName);
        }
    }

    // @Override
    async loadResources() {
        await super.loadResources();
        if(this.audioClickTab)
            this.audioClickTabMedia = new Audio(this.audioClickTab);
        if(this.audioAdoveTab)
            this.audioAdoveTabMedia = new Audio(this.audioAdoveTab);
    }

    async parseViewChild(nodeXml) {
        let view = await LayoutInflater.inflate(this.context, nodeXml,this.model);
        view.tabName = this.getAttrFromNodeXml(nodeXml,"tabName")||this.tabName;
        view.parentView = this;
        return view;
    }

    //@Override
    showElemDom(){
        super.showElemDom();
        let view = this.getTabSelected();
        if(view)
            view.showView();
    }

    async onClickTab(viewOnClicked){
        let view = this.getTabSelected();
        if(view){
            view.tabTitle.bgTitleTab = new NinepathBackground(null,view.tabTitle.titleContent,'lib/imgs/bg_titletab_unselected.9.png');
            await view.tabTitle.bgTitleTab.load();
            view.elemDom.remove();
        }

        let indexSelected= this.tabs.findIndex(vv=>vv===viewOnClicked);
        viewOnClicked.tabTitle.bgTitleTab = new NinepathBackground(null,viewOnClicked.tabTitle.titleContent,'lib/imgs/bg_titletab_selected.9.png');
        await viewOnClicked.tabTitle.bgTitleTab.load();
        this.contentTab.appendChild(viewOnClicked.elemDom);
        this.tabSelected = indexSelected;
        await this.onReMeasure();
        viewOnClicked.showView();
    }

    // @Override
    async addTab(view,textTabName) {
        let elemText = this.createHtmlElemFromType('span');
        elemText.style.wordWrap = 'break-word'; // Ajustar texto a contenido
        elemText.style.whiteSpace = "nowrap";
        elemText.innerHTML = textTabName;

        let textConentTab = this.createHtmlElemFromType('TabTitle');
        textConentTab.appendChild(elemText);
        textConentTab.style.color = this.colorTabTitle;
        textConentTab.classList.add("TabTitle");
        textConentTab.onmouseenter=()=>{
            if(this.audioAdoveTabMedia){
                this.audioAdoveTabMedia.play();
            }
            return false;
        };
            // this.elemDom.onmouseout=()=>{
                // this.audioAdove.pause();
                // this.audioAdove.currentTime = 0;
            // };
        
        this.textTabs.appendChild(textConentTab);
        view.tabName = textTabName;
        view.tabTitle = {
            bgTitleTab: null,
            elemTitle: elemText,
            titleContent: textConentTab
        };
        textConentTab.onclick=()=>{
            if(this.audioClickTabMedia)
                this.audioClickTabMedia.play();
            (async () => {
                await this.onClickTab(view);
            })();
            
        };
        await view.loadResources();
        if(this.tabSelected===-1){
            // Agregamos el contenido
            this.contentTab.appendChild(view.elemDom);
            this.tabSelected = 0;
            view.tabTitle.bgTitleTab = new NinepathBackground(null,textConentTab,'lib/imgs/bg_titletab_selected.9.png');
        }else{
            view.tabTitle.bgTitleTab = new NinepathBackground(null,textConentTab,'lib/imgs/bg_titletab_unselected.9.png');
        }
        await view.tabTitle.bgTitleTab.load();
        this.tabs.push(view);

        if(this.elemDom.style.visibility==='visible'){
            await this.onReMeasure();
            view.showView();
        }
    }

    getTabAt(index){
        return this.tabs[index];
    }

    getTabSelected(){
        if(this.tabSelected===-1)
            return null;
        return this.tabs[this.tabSelected];
    }

    //@Override
    async onMeasure(maxWidth, maxHeigth){
        if(this.tabs.length===0){
            await super.onMeasure(maxWidth,maxHeigth);
            return;
        }
        if(this.tabContentBg === null){
            // Cargamos el fondo de pantalla
            this.tabContentBg = new NinepathBackground(null,this.contentTab,'lib/imgs/bg_tabcontent.9.png');
            await this.tabContentBg.load();
        }

        // Pintamos los nombres de las pestañas
        let mayHT = 0;
        let posX= this.tabContentBg.padding.left;
        let space = 10;

        // tabTitle
        for(let view of this.tabs){
            view.tabTitle.titleContent.style.width = (view.tabTitle.bgTitleTab.padding.left+view.tabTitle.elemTitle.clientWidth+view.tabTitle.bgTitleTab.padding.right)+'px';
            view.tabTitle.titleContent.style.height = (view.tabTitle.bgTitleTab.padding.top+view.tabTitle.elemTitle.clientHeight+view.tabTitle.bgTitleTab.padding.bottom)+'px';
            view.tabTitle.elemTitle.style.left= view.tabTitle.bgTitleTab.padding.left+'px';
            view.tabTitle.elemTitle.style.top= view.tabTitle.bgTitleTab.padding.top+'px';
            await view.tabTitle.bgTitleTab.paint();

            view.tabTitle.titleContent.style.left = posX + 'px';
            posX+=(view.tabTitle.titleContent.clientWidth + space);
            if(view.tabTitle.titleContent.clientHeight > mayHT)
                mayHT = view.tabTitle.titleContent.clientHeight;
        }
        mayHT=mayHT-3;

        // Pintamos el contenido de las pestanas
        let view = this.getTabSelected();
        let maxWidthElement, maxHeightElement;
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                maxWidthElement = maxWidth - this.padding.left - this.padding.right;
                break;
            case LayoutInflater.WRAP_CONTENT:
                maxWidthElement = maxWidth - this.padding.left - this.padding.right;
                break;
            default:
                let width = parseInt(this.width);
                maxWidthElement = width - this.padding.left - this.padding.right;
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                maxHeightElement = maxHeigth - this.padding.top - this.padding.bottom - mayHT; break;
                break;
            case LayoutInflater.WRAP_CONTENT:
                maxHeightElement = maxHeigth - this.padding.top - this.padding.bottom - mayHT; break;
                break;
            default:
                let height = parseInt(this.height);
                maxHeightElement = height - this.padding.top - this.padding.bottom - mayHT; break;
                break;
        }

        await view.onMeasure(
            maxWidthElement-this.tabContentBg.padding.left-this.tabContentBg.padding.right , 
            maxHeightElement-this.tabContentBg.padding.top-this.tabContentBg.padding.bottom);

        this.contentTab.style.top=mayHT+'px';
        view.elemDom.style.top = this.tabContentBg.padding.top+'px';
        view.elemDom.style.left = this.tabContentBg.padding.left+'px';
        this.container.style.left = this.padding.left+'px';
        this.container.style.right = this.padding.right+'px';
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.textTabs.style.height = mayHT+'px';
                this.textTabs.style.width = (maxWidth-this.padding.left-this.padding.right)+'px';
                this.contentTab.style.width = (maxWidth-this.padding.left-this.padding.right)+'px';
                this.container.style.width = (maxWidth-this.padding.left-this.padding.right)+'px';
                this.elemDom.style.width = maxWidth+'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.textTabs.style.height = mayHT+'px';
                this.textTabs.style.width = Math.max(posX,view.elemDom.clientWidth +this.tabContentBg.padding.left+this.tabContentBg.padding.right)+'px';
                this.contentTab.style.width = this.textTabs.clientWidth+'px';
                this.container.style.width = this.textTabs.clientWidth+'px';

                this.elemDom.style.width = (this.padding.left+this.container.clientWidth+this.padding.right)+'px';
                break;
            default:
                let width = parseInt(this.width);

                this.textTabs.style.height = mayHT+'px';
                this.textTabs.style.width = (width-this.padding.left-this.padding.right)+'px';
                this.contentTab.style.width = this.textTabs.clientWidth+'px';
                this.container.style.width = this.textTabs.clientWidth+'px';
                this.elemDom.style.width = width+'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.textTabs.style.height = mayHT+'px';
                this.contentTab.style.height = (maxHeigth - mayHT-this.padding.top - this.padding.bottom)+'px';
                this.container.style.height = (maxHeigth - this.padding.top - this.padding.bottom)+'px';
                this.elemDom.style.height = maxHeigth+'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.textTabs.style.height = mayHT+'px';
                this.contentTab.style.height = (view.elemDom.clientHeight +this.tabContentBg.padding.top+this.tabContentBg.padding.bottom)+'px';
                this.container.style.height = (mayHT + this.textTabs.clientHeight)+'px';

                this.elemDom.style.height = (this.padding.top +this.textTabs.clientHeight + this.contentTab.clientHeight + this.padding.bottom)+'px';
                break;
            default:
                let height = parseInt(this.height);
                this.textTabs.style.height = mayHT+'px';
                this.contentTab.style.height = (height - mayHT-this.padding.top-this.padding.bottom)+'px';
                this.container.style.height = (height - this.padding.top-this.padding.bottom)+'px';
                this.elemDom.style.height= height+'px';
                break;
        }
        await this.tabContentBg.paint();
        await this.repaint();
    }
}
// Class: src/layout/MenuLayout.js
class MenuLayout extends View {
    static MODE_SEPARATED='SEPARATED';
    static MODE_UNITED='UNITED';

    constructor(context,model) {
        super(context,model);
        this.linContainer = new LinearLayout(context);
        this.linContainer.setOrientation('horizontal');
        this.btnMenu = new ImageButton(context);
        this.btnMenu.setImageResource('lib/imgs/bg_btn_menu.png');
        this.btnMenu.width='50px';
        this.btnMenu.height='50px';
        this.linContainer.parentView = this;
        this.btnMenu.parentView = this;
        this.mode = MenuLayout.MODE_SEPARATED;
        this.btnMenu.setOnClickListener(this.showOptionDialog,this);
        this.dialog = null;
    }

    async hidePopup(){
        this.dialog.hide();
        this.dialog = null;
    }

    async showOptionDialog(){
        if(this.dialog){
            this.dialog.hide();
            this.dialog = null;
            return;
        }
        this.linContainer.elemDom.remove();
        // Cambiamos la alineacion de los elementos
        for(let view of this.linContainer.getChilds()){
            view.setLayoutGravity('left');
        }
        this.linContainer.setOrientation('vertical');
        this.linContainer.setOnClickListener(this.hidePopup,this);
        await this.linContainer.setBackground('lib/imgs/bg_popup_bottom.9.png');
        this.dialog = new PopupWindow(this.getContext());
        this.dialog.setView(this.btnMenu);
        this.dialog.setPositionOnView('right|bottom');
        this.dialog.setContentView(this.linContainer);
        await this.dialog.show();
    }

    async cancelOptionDialog(){
        this.linContainer.setOrientation('horizontal');
        this.linContainer.padding = {left:0,right:0,top:0,bottom:0};
        for(let view of this.linContainer.getChilds()){
            view.setLayoutGravity('top');
        }
        await this.linContainer.setBackground(null);
        this.elemDom.appendChild(this.linContainer.elemDom);
        this.dialog = null;
        this.linContainer.hideView();
    }

    //Override
    async parse(nodeXml) {
        await super.parse(nodeXml);
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = await this.parseViewChild(nodeChild);
            child.parentView = this.linContainer;
            await this.linContainer.addView(child);
        }
    }

    //@Override
    async loadResources(){
        await super.loadResources();
        await this.linContainer.loadResources();
        await this.btnMenu.loadResources();
        if(this.mode===MenuLayout.MODE_SEPARATED){
            this.elemDom.appendChild(this.linContainer.elemDom);
            this.linContainer.showView();
        }
        else{
            this.elemDom.appendChild(this.btnMenu.elemDom);
            this.btnMenu.showView();
        }
        this.showView();
    }


    //Override
    async parseViewChild(nodeXml) {
        let view = await LayoutInflater.inflate(this.context, nodeXml,this.model);
        return view;
    }

    //@Override
    async onMeasure(maxWidth, maxHeight){
        if(this.dialog){
            this.dialog.hide();
            await this.cancelOptionDialog();
        }

        let maxWidthElement, maxHeightElement;
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT: maxWidthElement = maxWidth; break;
            case LayoutInflater.WRAP_CONTENT: maxWidthElement = maxWidth; break;
            default: maxWidthElement = parseFloat(this.width);
        }
        switch (this.height) {
            case LayoutInflater.MATCH_PARENT: maxHeightElement = maxHeight; break;
            case LayoutInflater.WRAP_CONTENT: maxHeightElement = maxWidth; break;
            default: maxHeightElement = parseFloat(this.height);
        }

        await this.linContainer.onMeasure(maxWidthElement-this.padding.left-this.padding.right,maxHeightElement-this.padding.top-this.padding.bottom);
        if(this.padding.left+this.linContainer.margin.left+this.linContainer.elemDom.clientWidth+this.linContainer.margin.right+this.padding.right>maxWidth){
            if(this.mode===MenuLayout.MODE_SEPARATED){
                //this.toButtomMode();
                this.elemDom.appendChild(this.btnMenu.elemDom);
                this.linContainer.hideView();
                this.btnMenu.showView();
            }
            this.btnMenu.onMeasure(maxWidthElement-this.padding.left-this.padding.right,maxHeightElement-this.padding.top-this.padding.bottom);
            this.btnMenu.elemDom.style.left=(this.padding.left+this.btnMenu.margin.left)+'px';
            this.btnMenu.elemDom.style.top=(this.padding.top+this.btnMenu.margin.top)+'px';
            this.mode=MenuLayout.MODE_UNITED;
            // Ajustando las dimensiones
            if(this.width === LayoutInflater.WRAP_CONTENT)
                maxWidthElement = this.padding.left+this.btnMenu.margin.left+this.btnMenu.elemDom.clientWidth+this.btnMenu.margin.right+this.padding.right;
            if(this.height === LayoutInflater.WRAP_CONTENT)
                maxHeightElement = this.padding.top+this.btnMenu.margin.top+this.btnMenu.elemDom.clientHeight+this.btnMenu.margin.bottom+this.padding.bottom;
        }else{
            if(this.mode===MenuLayout.MODE_UNITED){
                this.btnMenu.elemDom.remove();
                //this.elemDom.appendChild(this.linContainer.elemDom);
                this.mode=MenuLayout.MODE_SEPARATED;
                this.btnMenu.hideView();
                this.linContainer.showView();
            }
            // Ajustando las dimensiones
            if(this.width === LayoutInflater.WRAP_CONTENT)
                maxWidthElement = this.padding.left+this.linContainer.margin.left+this.linContainer.elemDom.clientWidth+this.linContainer.margin.right+this.padding.right;
            if(this.height === LayoutInflater.WRAP_CONTENT)
                maxHeightElement = this.padding.top+this.linContainer.margin.top+this.linContainer.elemDom.clientHeight+this.linContainer.margin.bottom+this.padding.bottom;

            // Las opciones se puede visualizar en el componente raiz
            this.linContainer.elemDom.style.left=(this.padding.left+this.linContainer.margin.left)+'px';
            this.linContainer.elemDom.style.top=(this.padding.top+this.linContainer.margin.top)+'px';
        }
        this.elemDom.style.width = maxWidthElement+'px';
        this.elemDom.style.height = maxHeightElement+'px';
        await this.repaint();
    }
}
// Class: src/ux/Page.js
class Page extends Context{
    // viewRoot: null,
    // viewListener: null,
    // urlView: null,
    // history: true,
    // fullScreem: false,
    // REQUEST_OK: 121,
    // REQUEST_CANCELED: 123,
    // resultCode: this.REQUEST_CANCELED,
    // resultData: null,
    // requestCode: -1,
    // loaded: false,

    constructor(){
        super();
        this.modals = new Array();
    }

    // @Override
    async onResize(){
        let navigator = PageManager.getWindowsDimension();
        await this.viewRoot.onMeasure(navigator.width,navigator.height);
        for(let dia of this.modals){
            await dia.onResize();
        }
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup || this.viewRoot instanceof ScrollView)
            return this.viewRoot.findViewById(idView);
        else
            throw new Exception(`El contenidor principal para la pagina [${this.constructor.name}] no es heredado de ViewGroup`);
    }

    getViewRoot(){
        return this.viewRoot;
    }

    getContext(){
        return this.context;
    }

    setContentView(objView) {
        if (objView instanceof View)
            this.viewRoot = objView;
        else if(typeof objView==='string')
            this.urlView = objView;
        else{
            throw "La vista debe ser una instancia de View o una url de un archivo XML"
        }
    }

    startLoaded(){
        this.viewRoot.elemDom.style.visibility = 'hidden';
        this.viewRoot.elemDom.style.opacity = 0;
    }

    loadedFinized(){
        this.viewRoot.elemDom.style.transition = "opacity 5s ease-in-out";
        this.viewRoot.elemDom.style.opacity = 1;
        this.viewRoot.elemDom.style.visibility = 'visible';
    }

    async onCreate() { }
    async onStart() { }
    async onDestroy() { }
    async onPause() { }
    async onResume() { }

    setNoHistory(history) {
        this.history = !history;
    }

    async startPage(intent) {
        if (intent === undefined || intent === null)
            throw new Exception("El Intent es nulo o no esta definido");
        if(!intent.context)
            throw new Exception("No se el contexto (Page) actual para iniciar la pagina ["+intent.pageName+"]");
        if(!(intent.context instanceof Page))
            throw new Exception("El contexto enviado en el [Intent] no es una instancia de una pagina ["+intent.context+"]");

        // Iniciamos la actividad principal
        intent.context.viewRoot.elemDom.style.display = "none";
        await intent.context.onPause();
        await PageManager.startPageFromIntent(intent);
    }

    setTitle(title) {
        document.title = title;
    }

    async finish(dataResult) {
        let previusPage = this.context;

        await PageManager.finishPage(this);

        if(previusPage){
            console.log("Volviendo a cargar la pagina anterior");
            await previusPage.onResume(dataResult);
            previusPage.viewRoot.elemDom.style.display = "block";
        }else{
            // Se retorna a la pagina inicial
            //console.log("NO hay pagina anterior registrada");
        }
    }

    setOnClickListenerTo(idView,onClickListener){
        if(idView instanceof View)
            idView.setOnClickListener(onClickListener, this);
        else{
            let view = this.viewRoot.findViewById(idView);
            view.setOnClickListener(onClickListener, this);
        }
    }

    async startPageForResult(intent, requestCode) {
        this.requestCode = requestCode;
        await this.startPage(intent);
    }

    async onPageResult(requestCode, resultCode, intent) { }
}
// Class: src/ux/Dialog.js
class Dialog extends Context{
    constructor(context){
        super();
        if(!(context instanceof Page))
            throw new Exception(`El contexto para el Dialogo [${this.constructor.name}] debe ser un [Page] y se envio [${context}]`);
        this.elemBackground = null;
        this.context = context;
        this.bgVisble = true;
        this.bgProgressVisble = true;
        this.resolvePromise = null;

        this.viewRoot = null;
        this.urlView = null;

        this.visible = false;
        this.dimensionListener = true;
    }

    // @Override
    async onResize(){
        if(this.dimensionListener){
            let windowsDimension = PageManager.getWindowsDimension();
            let w = windowsDimension.width-(windowsDimension.width*this.viewRoot.margin.left/100)-(windowsDimension.width*this.viewRoot.margin.right/100);
            let h = windowsDimension.height-(windowsDimension.height*this.viewRoot.margin.top/100)-(windowsDimension.height*this.viewRoot.margin.bottom/100);
            if(this.viewRoot.maxWidth>0 && w > this.viewRoot.maxWidth)
                w = this.viewRoot.maxWidth;
            if(this.viewRoot.maxHeigth>0 && w > this.viewRoot.maxHeigth)
                h = this.viewRoot.maxHeigth;
            await this.viewRoot.onMeasure(w,h)
            this.setPosition(windowsDimension);
        }
    }

    enableDimensionListener(enable){
        this.dimensionListener = enable?true:false;
    }

    setContentView(view,model) {
        this.model = model;
        if (view instanceof View)
            this.viewRoot = view;
        else if(typeof view==='string')
            this.urlView = view;
        else
            throw `El contenido enviado [${view}] no es valido para el [Dialog]. Establesca solo una url con XML para el layout o una intancia de View`;
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup || this.viewRoot instanceof ScrollView) {
            return this.viewRoot.findViewById(idView);
        }
        else
            throw new Exception(`El contenidor principal para el Dialogo [${this.constructor.name}] no es heredado de ViewGroup`);
    }

    showBackground(show){
        this.bgVisble = show;
    }

    showBackgroundProgress(show){
        this.bgProgressVisble = show;
    }

    async onStart(){

    }

    isVisible(){
        return this.visible;
    }

    async show(){
        if(this.visible)
            throw new Exception(`El Dialog [${this.constructor.name}] ya se encuentra visible`);
        this.getContext().viewRoot.elemDom.style.filter = "blur(5px)";
        this.context.modals.push(this);
        var this_ = this;
        return new Promise((resolve,reject)=>{
            this_.resolvePromise = resolve;
            (async () => {
                // Creamos un fondo opaco para el dialogo
                let pageAnimation = null;
                if (this_.bgVisble === true) {
                    this_.elemBackground = document.createElement('div');

                    // Margenes por defector
                    this_.elemBackground.style.marginTop = '0px';
                    this_.elemBackground.style.marginLeft = '0px';
                    this_.elemBackground.style.marginBottom = '0px';
                    this_.elemBackground.style.marginRight = '0px';
                    // Padding por defecto
                    this_.elemBackground.style.paddingTop = '0px';
                    this_.elemBackground.style.paddingLeft = '0px';
                    this_.elemBackground.style.paddingBottom = '0px';
                    this_.elemBackground.style.paddingRight = '0px';
                    this_.elemBackground.style.position = "absolute";
                    this_.elemBackground.style.width = "100%";
                    this_.elemBackground.style.height = "100%";

                    this_.elemBackground.style.backgroundColor = "rgba(30, 30, 30, 0.7)";
                    document.body.appendChild(this_.elemBackground);
                }
                
                if(this_.bgProgressVisble){
                    // Cargando la vista
                    pageAnimation = new SpinnerAnimation();
                    pageAnimation.show();
                }
                

                // Verificamos si tiene contenido la pagina
                if(this_.viewRoot || this_.urlView)
                    ; // Contenido definido
                else{
                    reject(new Exception(`El dialogo [${this_.constructor.name}] no tiene contenido definido. Asigne uno con [setContentView]`));
                    if(pageAnimation)
                        pageAnimation.hide();
                    return;
                }
                if(this_.viewRoot === null){
                    let rootXml = await Resource.loadLayoutSync(this_.urlView);
                    this_.viewRoot = await LayoutInflater.inflate(this_,rootXml,this.model);
                }

                document.body.appendChild(this_.viewRoot.elemDom);
                await this.viewRoot.loadResources();
                await this.onResize();
                if(pageAnimation)
                    pageAnimation.hide();

                // Mostrando todos los elementos
                this_.viewRoot.showView();

                this_.onStart();
                this.visible = true;
            })();
        });
    }

    setPosition(windowsDimension){
        this.viewRoot.elemDom.style.left = (windowsDimension.width / 2 - this.viewRoot.getWidth() / 2) + 'px';
        this.viewRoot.elemDom.style.top = (windowsDimension.height / 2 - this.viewRoot.getHeight() / 2) + 'px';
    }

    async cancel(params){
        this.getContext().viewRoot.elemDom.style.filter = "none";
        let pos = this.context.modals.findIndex(el => el === this);
        if (pos >= 0)
            this.context.modals.splice(pos, 1);
        if(this.viewRoot && this.viewRoot.elemDom)
            this.viewRoot.elemDom.remove();
        if (this.bgVisble === true)
            this.elemBackground.parentNode.removeChild(this.elemBackground);
        if(this.resolvePromise)
            this.resolvePromise(params);
        this.visible = false;
    }

    getViewRoot(){
        return this.viewRoot;
    }

    getContext(){
        return this.context;
    }
};
// Class: src/ux/PopupWindow.js
class PopupWindow extends Context{
    constructor(context) {
        super();
        this.context = context;
        this.position = "top";
        this.view = null;
        this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
        this.viewRoot = null;
    }

    setPositionOnView(position) {
        this.position = position;
    }

    setView(view) {
        this.view = view;
    }

    getView(){
        return this.view;
    }

    setContentView(view) {
        if (view instanceof View)
            this.viewRoot = view;
        else if(typeof view==='string')
            this.urlView = view;
        else
            throw `El contenido enviado [${view}] no es valido para el [PopupWindow]. Establesca solo una url con XML para el layout o una intancia de View`;
    }

    getContentView(){
        return this.viewRoot;
    }

    async onReMesasure(){
        let windowsDimension = PageManager.getWindowsDimension();
        await this.viewRoot.loadResources();
        await this.viewRoot.onMeasure(
            windowsDimension.width-(windowsDimension.width*this.viewRoot.margin.left/100)-(windowsDimension.width*this.viewRoot.margin.right/100), 
            windowsDimension.height-(windowsDimension.height*this.viewRoot.margin.top/100)-(windowsDimension.height*this.viewRoot.margin.bottom/100));
    }

    async show(){     
        if(this.visible)   
            throw new Exception(`El PopupWindows ya se encuentra visible.`);
        // Verificamos si tiene contenido la pagina
        if(this.viewRoot || this.urlView)
            ; // Contenido definido
        else
            throw new Exception(`El PopupWindow [${this_.constructor.name}] no tiene contenido definido. Asigne uno con [setContentView]`);

        if(this.viewRoot === null)
            this.viewRoot = await LayoutInflater.inflate(this,this.urlView);

        document.body.appendChild(this.viewRoot.elemDom);
        // Dibujamos la vista
        await this.viewRoot.loadResources();
        await this.onReMesasure();

        // Mostrando todos los elementos
        this.viewRoot.showView();
        this.visible = true;

        let rectView = this.view.elemDom.getBoundingClientRect();

        for(let posItem of this.position.split('|')){
            switch(posItem){
                case 'left':
                    this.viewRoot.elemDom.style.left = (rectView.left) + 'px';
                    break;
                case 'right':
                    this.viewRoot.elemDom.style.left = ( rectView.left + this.view.getWidth() - this.viewRoot.getWidth()) + 'px';
                    break;
                case 'top':
                    this.viewRoot.elemDom.style.left = (rectView.left) + 'px';
                    this.viewRoot.elemDom.style.top = (rectView.top - this.viewRoot.getHeight()) + 'px';
                    break;
                case 'bottom':
                    this.viewRoot.elemDom.style.left = (rectView.left) + 'px';
                    this.viewRoot.elemDom.style.top = (rectView.top + this.view.getHeight()) + 'px';
                    break;
            }
        }
    }

    async hide(){
        if(this.viewRoot && this.viewRoot.elemDom)
            this.viewRoot.elemDom.remove();
        this.visible = false;
    }

    isVisible(){
        return this.visible;
    }
};
// Class: src/widget/Toast.js
class Toast{
    static LENGTH_SHORT = 1000;
    static LENGTH_LONG = 5000;
 
    static makeText(context, message, length){
        (() => {
            (async () => {
                var dialog = new Dialog(context);
                dialog.showBackground(false);
                dialog.showBackgroundProgress(false);
                let txtMessage = new TextView(context);
                await txtMessage.setBackground("lib/imgs/bg_toast.9.png");
                txtMessage.setText(message);
                txtMessage.setSingleLine(true);
                txtMessage.setTextColor('#EC9D52');
                dialog.setContentView(txtMessage);
                setTimeout(function(){
                    dialog.cancel();
                },length);
                await dialog.show();
            })();
        })(); 
    }
}
// Class: src/widget/AlertDialog.js
class AlertDialog{
    static async showFatalMessage(context,txtContent,txtOk){
        const dialog = new Dialog(context);
        let container = new LinearLayout(context);
        container.setBackground('lib/imgs/bg_alert_fatal.9.png');
        container.setOrientation('vertical');

        let txtMsg = new TextView(context);
        await txtMsg.setText(txtContent);
        txtMsg.setSingleLine(true);
        txtMsg.setLayoutGravity('center_horizontal');
        await container.addView(txtMsg);
        
        let btnOk = new Button(context);
        await btnOk.setText(txtOk);
        btnOk.setSingleLine(true);
        btnOk.setLayoutGravity('center_horizontal');
        btnOk.margin.top = 10;
        btnOk.setOnClickListener((view)=>{
            dialog.cancel();
        });
        await container.addView(btnOk);

        dialog.setContentView(container);

        await dialog.show();
    }
}