// Class: src/core/Context.js
class Context{
    getLayoutInflater() {
        return new LayoutInflater();
    }
};
// Class: src/core/Exception.js
class Exception extends Error{
    // message = null
    constructor(message){
        super(message);
        this.message = message;
    }

    toString(){
        return this.message;
    }
};
// Class: src/core/Resource.js
class Resource{
    static async loadScriptSync(url) {
        await new Promise(function (resolve, reject) {
            // Adding the script tag to the head as suggested before
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
    
            // Then bind the event to the callback function.
            // There are several events for cross browser compatibility.
            //script.onreadystatechange = callback;
            function callback() {
                resolve();
            }
    
            function callbackError(error) {
                reject(error);
            }
    
            script.onerror = callbackError;
            script.onload = callback;
            // Fire the loading
            head.appendChild(script);
        });
    };
    
    static async loadAllScriptsSync(urls) {
        if (Array.isArray(urls) === false)
            throw "Lista de urls vacio para [loadAllScripts]";
        for(let url of urls){
            await loadScriptSync(url);
        }
    };
    
    static async loadLayoutSync(urlXmlLayout){
        let rootXml = await new Promise(function(resolve,reject){
            var xmlhttp;
            if (window.XMLHttpRequest)
                xmlhttp = new XMLHttpRequest();
            else
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4) {
                    if (xmlhttp.status === 200 ||xmlhttp.status === 0) { // Habilitado para archivos en local host (||xmlhttp.status === 0)
                        resolve(xmlhttp.responseXML.documentElement);
                    } else {
                        reject(xmlhttp.statusText);
                    }
                }
            };
            xmlhttp.open("GET", urlXmlLayout, true);
            xmlhttp.send(null);
        });
        return rootXml;
    }

    static async loadImage(urlOrTextBase64){
        if(!urlOrTextBase64)
            throw "No se envió la imagen para la carga";
        if(typeof urlOrTextBase64 !== 'string')
            throw "El parámetro para cargar la imagen no es de tipo texto";
        let image = await new Promise(function(resolve,reject){
            let image = new Image();
            image.onload = function(){
                resolve(image);
            }
            if(Resource.isBase64Resource(urlOrTextBase64)){
                image.src = `data:image/png;base64,${urlOrTextBase64}`;
            }
            else
                image.src =urlOrTextBase64;
        });
        return image;
    }

    static isBase64Resource(urlOrTextBase64){
        return /data:image\/([a-zA-Z]*);base64,([^\"]*)/g.test(urlOrTextBase64);
    }

    static isImageNinePathResource(urlOrTextBase64){
        return /\.9\.(png|gif)/i.test(urlOrTextBase64);
    }

    static isImageResource(urlOrTextBase64){
        return /.(png|gif|jpg)/i.test(urlOrTextBase64);
    }

    static isColorResource(hexColorText){
        return /^#[0-9A-F]{6}$/i.test(hexColorText);
    }

    static async waitToLoadAllResources(){
        await new Promise(function(resolve){
            let callback = function(){
                resolve();
            };

            if (window.attachEvent){
                window.attachEvent('onload', callback);
            }
            else if (window.addEventListener){
                window.addEventListener('load', callback, false);
            }
            else{
                document.addEventListener('load', callback, false);
            }
        });
    }
}
// Class: src/core/PageManager.js
class PageManager{
    static async startAplicationSync(mainPageName) {
        // Eliminamos margenes y padding del contenedor principal (body,html)
        document.body.style.paddingBottom = '0px';
        document.body.style.paddingTop = '0px';
        document.body.style.paddingLeft = '0px';
        document.body.style.paddingRight = '0px';
        document.body.style.margin = '0px';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
        document.body.style.position = 'absolute';

        // Creamos el estilo del boton
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        //padding: 4px 20px;
        //sheet.innerHTML = '.AndButton {background:#ffae00; background: -webkit-linear-gradient(top, #ffae00, #d67600);background: -moz-linear-gradient(top, #ffae00, #d67600);background: -o-linear-gradient(top, #ffae00, #d67600);background: linear-gradient(top, #ffae00, #d67600);border:2px outset #dad9d8; font-family:Andika, Arial, sans-serif;font-size:1.1em;letter-spacing:0.05em;color:#fff;text-shadow: 0px 1px 10px #000;-webkit-border-radius: 15px;-moz-border-radius: 15px;border-radius: 15px;-webkit-box-shadow: rgba(0, 0, 0, .55) 0 1px 6px;-moz-box-shadow: rgba(0, 0, 0, .55) 0 1px 6px;box-shadow: rgba(0, 0, 0, .55) 0 1px 6px;}.AndButton:hover, .AndButton:focus {border:2px solid #dad9d8;}';
        sheet.innerHTML = `.AndButton {background-color: #2D8FC4;color:#fff;border-radius: 10px;}\n\
                           .AndButton:hover, .AndButton:focus {background-color: rgba(255,200,100,0.5);color:black;cursor: pointer;cursor: hand;}\n\
                           .AndButton:active {background-color: rgba(255,220,150,0.7);cursor: move;}`;

        document.body.appendChild(sheet);

        // Convertimos en no seleccinable a todos los elementos
        // no editores
        var sheet = document.createElement('style');
        sheet.type = "text/css";
        //padding: 4px 20px;
        sheet.innerHTML = `html,body,div,span,img{
                                                    -webkit-user-select: none;
                                                    -khtml-user-select: none;
                                                    -moz-user-select: none;
                                                    -o-user-select: none;
                                                    -ms-user-select: none;
                                                    user-select: none;
                                                }`;
        document.body.appendChild(sheet);

        var sheet = document.createElement('style');
        sheet.type = "text/css";
        sheet.innerHTML = `@keyframes rotate{from {rotate:360deg;} to {rotate:0deg;}}
                           @-moz-keyframes rotate-record {0%   {-moz-transform: rotate(360deg);}100% {-moz-transform: rotate(0deg);}}
                           .rotate {-webkit-animation:rotate-record .8s infinite linear;-moz-animation:rotate-record .8s infinite linear;}`;

        document.body.appendChild(sheet);

        // Iniciamos la actividad principal
        var intent = new Intent(null, mainPageName);
        await this.startPageSync(intent);
    }

    static async startPageSync(intent) {
        // Instanciamos la Pagina
        var page = null;
        try {
            page = eval(`new ${intent.pageName}()`);
        }
        catch (o) {
            throw new Exception("No existe la pagina [" + intent.pageName + "]");
        }
        page.className = intent.pageName;

        await this.loadPageSync(intent.context, page, intent);
    }
    // proProgress:{left:?,top:?,width,height,showBackground:true}
    static async loadPageSync(previusPage, page, intent) {
        page.previusPage = previusPage;
        // LLamamos el on create de la pagina
        page.onCreate(intent);
        let pageAnimation = new SpinnerAnimation();
        pageAnimation.show();

        if (previusPage !== null) {
            // VER QUE SE REALIZARA PARA ESTE CASO
            
            // if (previusPage.history === false)
            //     this.removeContext(previusPage);
            // previusPage.onDestroy();
        }
        // Verificamos si tiene contenido la pagina
        if(!page.viewRoot && !page.urlView)
            throw new Exception(`La pagina [${page.className}] no tiene contenido definido. Asigne un contenido con page.setContentView`);
        if(page.urlView){ // La pagina cargara los elementos a partir de una URL
            let rootXml = await Resource.loadLayoutSync(page.urlView);
            page.viewRoot = LayoutInflater.inflate(page,rootXml);
        }

        document.body.appendChild(page.viewRoot.createDomElement());
        // page.startLoaded(); // Iniciando carga

        var navigator = this.getWindowsDimension();
        await page.viewRoot.loadResources();
        await page.viewRoot.onMeasureSync(navigator.width,navigator.height);
        page.loadedFinized(); // Carga finalizada
        pageAnimation.hide();
        page.onStart(intent);
    }
    static removeContext(context) {
        var element = context.viewRoot.elemDom;
        element.parentNode.removeChild(element);
        context.onDestroy();
    }
    static finishPage(context) {
        this.removeContext(context);
    }
    static getWindowsDimension() {
        //        return {
        //                    width:document.body.clientWidth,
        //                    height:document.body.clientHeight
        //               };
        var dim = {
            width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
            height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
        };
        return dim;
    }
}
// Class: src/core/Intent.js
class Intent{
    // context
    // pageName
    constructor(context, pageName){
        this.extras = {};
        this.context= context;
        this.pageName = pageName;
    }

    putExtra(name, value) {
        this.extras[name] = value;
    }
    getExtra(name) {
        return this.extras[name];
    };
}
// Class: src/core/LayoutInflater.js
class LayoutInflater{
    // Atributos generales para los layouts
    static ATTR_LAYOUT_WIDTH = "layout_width";
    static ATTR_LAYOUT_HEIGHT= "layout_height";
    static ATTR_ID= "id";
    static ATTR_LAYOUT_GRAVITY= "layout_gravity";

    static ATTR_LAYOUT_MARGIN= "layout_margin";
    static ATTR_LAYOUT_MARGIN_TOP= "layout_marginTop";
    static ATTR_LAYOUT_MARGIN_LEFT= "layout_marginLeft";
    static ATTR_LAYOUT_MARGIN_RIGHT= "layout_marginRight";
    static ATTR_LAYOUT_MARGIN_BOTTOM= "layout_marginBottom";

    static ATTR_PADDING= "padding";
    static ATTR_PADDING_TOP= "paddingTop";
    static ATTR_PADDING_LEFT= "paddingLeft";
    static ATTR_PADDING_RIGHT= "paddingRight";
    static ATTR_PADDING_BOTTOM= "paddingBottom";

    static ATTR_ON_CLICK= "onClick";
    static ATTR_BACKGROUND= "background";
    static ATTR_ORIENTATION= "orientation";
    static ATTR_LAYOUT_WEIGHT= "layout_weight";

    // Atributos de RelativeLayout
    static ATTR_LAYOUT_ALIGNPARENTLEFT= "layout_alignParentLeft";// true;false
    static ATTR_LAYOUT_ALIGNPARENTTOP= "layout_alignParentTop";//true;false
    static ATTR_LAYOUT_ALIGNPARENTRIGHT= "layout_alignParentRight";//true;false
    static ATTR_LAYOUT_ALIGNPARENTBOTTOM= "layout_alignParentBottom";//true;false

    static ATTR_LAYOUT_CENTERHORIZONTAL= "layout_centerHorizontal";//true;false
    static ATTR_LAYOUT_CENTERVERTICAL= "layout_centerVertical";//true;false
    static ATTR_LAYOUT_CENTERINPARENT= "layout_centerInParent";//true;false

    static ATTR_LAYOUT_ABOVE= "layout_above";//id
    static ATTR_LAYOUT_BELOW= "layout_below";//id

    static ATTR_LAYOUT_TORIGHTOF= "layout_toRightOf";//id
    static ATTR_LAYOUT_TOLEFTOF= "layout_toLeftOf";//id

    static ATTR_MIN_WIDTH= "minWidth";
    static ATTR_MIN_HEIGHT= "minHeight";

    // TextView
    static ATTR_LAYOUT_TEXT= "text";
    static ATTR_DRAWABLE_LEFT= "drawableLeft";
    static ATTR_DRAWABLE_TOP= "drawableTop";
    static ATTR_DRAWABLE_BOTTOM= "drawableBottom";
    static ATTR_DRAWABLE_RIGHT= "drawableRight";

    // ImageVIew
    static ATTR_SRC= "src";
    static ATTR_SCALE_TYPE= "scaleType";
    static FIT_XY= "fitXY";
    static FIT_START= "fitStart";
    static FIT_CENTER= "fitCenter";
    //CENTER = "center"

    // LinearLayout
    static HORIZONTAL= "horizontal";
    static VERTICAL= "vertical";

    // vista
    static ATTR_VISIBILITY= "visibility";

    // Valores que pueden tomar los atributos
    static MATCH_PARENT= "match_parent";
    static WRAP_CONTENT= "wrap_content";
    static LEFT= "left";
    static RIGHT= "right";
    static BOTTOM= "bottom";
    static CENTER_HORIZONTAL= "center_horizontal";
    static CENTER_VERTICAL= "center_vertical";
    static CENTER= "center";
    static TOP= "top";

    static VISIBLE= "visible";
    static INVISIBLE= "invisible";
    static GONE= "gone";

    /**
     * Instancia la vista y realizar el parseo a travez del la raiz del documento XML pasado como parametro
     * @param {*} context  EL contexto de la pagina
     * @param {*} firstElement El primer elemento de tipo XML para crear la vista
     */
    static parse(context, firstElement) {
        var view = null;
        try {
            var view = eval("new " + firstElement.tagName + "(context)");
        }
        catch (o) {
            console.log(o);
            throw new Exception("No existe la vista [" + firstElement.tagName + "]");
        }
        view.parse(firstElement);
        return view;
    }

    static inflate(context,xmlRoot) {
        var view = this.parse(context, xmlRoot);
        return view;
    }
}
// Class: src/view/background/BaseBackground.js
class BaseBackground{
    async load(){}
    async paint(){}
}
// Class: src/view/background/ColorBackground.js
class ColorBackground extends BaseBackground{
    constructor(domElement,color){
        super(domElement,color);
        this.color= color;
        this.domElement = domElement;
    }
    async load(){
        this.domElement.style.background = this.color;
    }
    async paint(){}
}
// Class: src/view/background/EmplyBackground.js
class EmplyBackground extends BaseBackground{
    constructor(domElement){
        super(domElement);
        this.domElement = domElement;
    }
    async load(){
        this.domElement.style.background='none';
    }
    async paint(){}
}
// Class: src/view/background/ImageBackground.js
class ImageBackground extends BaseBackground{
    constructor(domElement,urlOrBase64Image){
        super(domElement,urlOrBase64Image);
        this.domElement = domElement;
        this.urlOrBase64Image = urlOrBase64Image;
    }
    async load(){
        if(Resource.isImageResource(this.urlOrBase64Image))
            this.domElement.style.background = `url('${this.urlOrBase64Image}')`;
        else
            this.domElement.style.background = `data:image/png;base64,${urlOrBase64Image}`;
    }
    async paint(){}
}
// Class: src/view/background/NinepathBackground.js
class NinepathBackground extends BaseBackground{
    constructor(domElement,imageNinePathBase64){
        super(domElement);
        // Stores the HTMLDivElement that's using the 9patch image
        this.domElement = domElement;
        // Padding
        this.padding = null;
        // Stores the pieces used to generate the horizontal layout
        this.horizontalPieces = null;
        // Stores the pieces used to generate the vertical layout
        this.verticalPieces = null;
        this.imageNinePathBase64 = imageNinePathBase64;
        // Stores the 9patch image
        this.bgImage = null;
    }

    getPieces(data, staticColor, repeatColor){
        let tempDS, tempPosition, tempWidth, tempColor, tempType;
        let tempArray = new Array();

        tempColor = data[4] + ',' + data[5] + ',' + data[6] + ',' + data[7];
        tempDS = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
        tempPosition = 1;

        for (var i = 4, n = data.length - 4; i < n; i += 4) {
            tempColor = data[i] + ',' + data[i + 1] + ',' + data[i + 2] + ',' + data[i + 3];
            tempType = (tempColor === staticColor ? 's' : (tempColor === repeatColor ? 'r' : 'd'));
            if (tempDS !== tempType) {
                // box changed colors
                tempWidth = (i / 4) - tempPosition;
                tempArray.push(new Array(tempDS, tempPosition, tempWidth));

                tempDS = tempType;
                tempPosition = i / 4;
                tempWidth = 1;
            }
        }
        
        // push end
        tempWidth = (i / 4) - tempPosition;
        tempArray.push(new Array(tempDS, tempPosition, tempWidth));

        return tempArray;
    }

    getPadBorder(dataPad, width, height){
        var staticRight = dataPad[0] + ',' + dataPad[1] + ',' + dataPad[2] + ',' + dataPad[3];
        var pad = { top: 0, bottom: 0 };
    
        // Padding para la parte superior
        for (var i = 0; i < dataPad.length; i += 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.top++;
        }
        // padding inferior
        for (var i = dataPad.length - 4; i >= 0; i -= 4) {
            var tempColor = dataPad[i] + ',' + dataPad[i + 1] + ',' + dataPad[i + 2] + ',' + dataPad[i + 3];
            if (tempColor !== staticRight)
                break;
            pad.bottom++;
        }
        return pad;
    }

    draw(){
        var dCtx, dCanvas, dWidth, dHeight;

        if (this.horizontalPieces === null)
            return;
    
        dWidth = this.domElement.clientWidth;
        dHeight = this.domElement.clientHeight;
    
        if (dWidth === 0 || dHeight === 0)
            return;
    
        dCanvas = document.createElement('canvas');
        dCtx = dCanvas.getContext('2d');
    
        dCanvas.width = dWidth;
        dCanvas.height = dHeight;
    
        var fillWidth, fillHeight;
        // Determine the width for the static and dynamic pieces
        var tempStaticWidth = 0;
        var tempDynamicCount = 0;
    
        for (var i = 0, n = this.horizontalPieces.length; i < n; i++) {
            if (this.horizontalPieces[i][0] === 's')
                tempStaticWidth += this.horizontalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillWidth = (dWidth - tempStaticWidth) / tempDynamicCount;
    
        // Determine the height for the static and dynamic pieces
        var tempStaticHeight = 0;
        tempDynamicCount = 0;
        for (var i = 0, n = this.verticalPieces.length; i < n; i++) {
            if (this.verticalPieces[i][0] === 's')
                tempStaticHeight += this.verticalPieces[i][2];
            else
                tempDynamicCount++;
        }
    
        fillHeight = (dHeight - tempStaticHeight) / tempDynamicCount;
    
        // Loop through each of the vertical/horizontal pieces and draw on
        // the canvas
        for (var i = 0, m = this.verticalPieces.length; i < m; i++) {
            for (var j = 0, n = this.horizontalPieces.length; j < n; j++) {
                var tempFillWidth, tempFillHeight;
    
                tempFillWidth = (this.horizontalPieces[j][0] === 'd') ?
                    fillWidth : this.horizontalPieces[j][2];
                tempFillHeight = (this.verticalPieces[i][0] === 'd') ?
                    fillHeight : this.verticalPieces[i][2];
    
                // Stretching :
                if (this.verticalPieces[i][0] !== 'r') {
                    // Stretching is the same function for the static squares
                    // the only difference is the widths/heights are the same.
                    if (tempFillWidth >= 0 && tempFillHeight >= 0) {
                        dCtx.drawImage(
                            this.bgImage,
                            this.horizontalPieces[j][1], this.verticalPieces[i][1],
                            this.horizontalPieces[j][2], this.verticalPieces[i][2],
                            0, 0,
                            tempFillWidth, tempFillHeight);
                    }
                    else
                        break;
                }
                else {
                    var tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.horizontalPieces[j][2];
                    tempCanvas.height = this.verticalPieces[i][2];
    
                    var tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(
                        this.bgImage,
                        this.horizontalPieces[j][1], this.verticalPieces[i][1],
                        this.horizontalPieces[j][2], this.verticalPieces[i][2],
                        0, 0,
                        this.horizontalPieces[j][2], this.verticalPieces[i][2]);
    
                    var tempPattern = dCtx.createPattern(tempCanvas, 'repeat');
                    dCtx.fillStyle = tempPattern;
                    dCtx.fillRect(
                        0, 0,
                        tempFillWidth, tempFillHeight);
                }
    
                // Shift to next x position
                dCtx.translate(tempFillWidth, 0);
            }
    
            // shift back to 0 x and down to the next line
            dCtx.translate(-dWidth, (this.verticalPieces[i][0] === 's' ? this.verticalPieces[i][2] : fillHeight));
        }
    
        // store the canvas as the div's background
        var url = dCanvas.toDataURL("image/png");
        var tempIMG = new Image();
    
        var _this = this;
        tempIMG.onload = ()=>{
            this.domElement.style.background = `url(${url}) no-repeat`;
        };
        tempIMG.src = url;
    }

    // @Override
    async load(){
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // Cargamos la imagen 
        this.bgImage = await Resource.loadImage(this.imageNinePathBase64);
        this.domElement.style.background = 'none';
        this.domElement.style.backgroundRepeat = "no-repeat";
        
        // this.elemDom.style.backgroundRepeat = "no-repeat";
        // this.elemDom.style.backgroundPosition = "-1000px -1000px";
        // this.elemDom.style.backgroundImage = "url('" + background + "')";





        // var this_ = this;
        // this.ninePatch = new NinePatch(this.elemDom, function () {
        //     this_.padding.left = this_.ninePatch.padding.left;
        //     this_.padding.top = this_.ninePatch.padding.top;
        //     this_.padding.right = this_.ninePatch.padding.right;
        //     this_.padding.bottom = this_.ninePatch.padding.bottom;
        // });
    }
    
    // @Override
    async paint(){
        // Create a temporary canvas to get the 9Patch index data.
        var tempCtx, tempCanvas;
        tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.bgImage.width;
        tempCanvas.height = this.bgImage.height;
        tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(this.bgImage, 0, 0);

        // Obteniendo el padding lateral derecho
        var dataPad = tempCtx.getImageData(this.bgImage.width - 1, 0, 1, this.bgImage.height).data;
        var padRight = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);
        this.padding.top = padRight.top;
        this.padding.bottom = padRight.bottom;
        dataPad = tempCtx.getImageData(0, this.bgImage.height - 1, this.bgImage.width, 1).data;
        var padBottom = this.getPadBorder(dataPad, this.bgImage.width, this.bgImage.height);

        this.padding.left = padBottom.top;
        this.padding.right = padBottom.bottom;

        // Loop over each  horizontal pixel and get piece
        var data = tempCtx.getImageData(0, 0, this.bgImage.width, 1).data;

        // Use the upper-left corner to get staticColor, use the upper-right corner
        // to get the repeatColor.
        var tempLength = data.length - 4;
        var staticColor = data[0] + ',' + data[1] + ',' + data[2] + ',' + data[3];
        var repeatColor = data[tempLength] + ',' + data[tempLength + 1] + ',' +
            data[tempLength + 2] + ',' + data[tempLength + 3];
        this.horizontalPieces = this.getPieces(data, staticColor, repeatColor);

        // Loop over each  horizontal pixel and get piece
        data = tempCtx.getImageData(0, 0, 1, this.bgImage.height).data;
        this.verticalPieces = this.getPieces(data, staticColor, repeatColor);

        // use this.horizontalPieces and this.verticalPieces to generate image
        this.draw();
    }
}
// Class: src/view/View.js
class View {
    static INVISIBLE = "INVISIBLE";
    static VISIBLE = "VISIBLE";
    static GONE = "GONE";

    constructor(context) {
        if (!context)
            throw new Exception("El contexto no esta en los parametros o es nulo");
        this.context = context;
        this.visibility = View.VISIBLE;
        this.margin = { top: 0, left: 0, right: 0, bottom: 0 };
        this.padding = { top: 0, left: 0, right: 0, bottom: 0 };
        // this.elemDom = this.createDomElement();
        this.parentView = null;
        this.name = "View";
        this.maxWidth = 0;
        this.maxHeigth = 0;
        this.minHeigth = 0;
        this.minHeigth = 0;
        this.width = LayoutInflater.WRAP_CONTENT;
        this.height = LayoutInflater.WRAP_CONTENT;
        this.id = null;
        this.background = null;
        this.onClick = null;
        this.tooltip = null;
        this.layoutGravity = (LayoutInflater.LEFT + '|' + LayoutInflater.TOP);
    }

    setVisibility(v) {
        this.visibility = v;
    }
    setToolTip(text) {
        this.tooltip = text;
    }
    setMinWidth(w) {
        this.minWidth = w;
    }
    getContext() {
        return this.context;
    }
    setMinHeight(h) {
        this.minHeigth = h;
    }
    createDomElement() {
        var elem = document.createElement(this.getTypeElement());
        // Margenes por defector
        elem.style.marginTop = '0px';
        elem.style.marginLeft = '0px';
        elem.style.marginBottom = '0px';
        elem.style.marginRight = '0px';

        // Padding por defecto
        elem.style.paddingTop = '0px';
        elem.style.paddingLeft = '0px';
        elem.style.paddingBottom = '0px';
        elem.style.paddingRight = '0px';

        elem.style.position = 'absolute';
        this.elemDom = elem;
        return elem;
    }
    getTypeElement() {
        return 'div';
    }
    setId(id) {
        this.id = id;
    }
    clone() {
        var copy = Object.assign({}, this);
        copy.elemDom = this.elemDom.cloneNode(true);
    }
    // checkMinSize: function () {
    //     var sw = false;
    //     if (this.getWidth() <= this.minWidth) {
    //         this.elemDom.style.width = this.minWidth + 'px';
    //         sw = true;
    //     }
    //     if (this.getHeight() <= this.minHeigth) {
    //         this.elemDom.style.height = this.minHeigth + 'px';
    //         sw = true;
    //     }
    //     if (sw === true)
    //         this.invalidate();
    // },
    getWidth() {
        return this.width;
        //elemDom.clientWidth;
    }
    getHeight() {
        return this.height;
    }
    setMargin(margin) {
        if (!margin) return;
        var mg = parseInt(margin);
        this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = mg;
    }
    setMarginTop(margin) {
        if (!margin) return;
        this.margin.top = parseInt(margin);
    }
    setMarginLeft(margin) {
        if (!margin) return;
        this.margin.left = parseInt(margin);
    }
    setMarginRight(margin) {
        if (!margin) return;
        this.margin.right = parseInt(margin);
    }
    setMarginBottom(margin) {
        if (!margin) return;
        this.margin.bottom = parseInt(margin);
    }
    getBackground() {
        return this.background;
    }
    setBackground(background) {
        this.background = background;
    }
    setWidth(width) {
        this.width = width;
    }
    setHeight(height){
        this.height = height;
    }
    setLayoutGravity(gravity) {
        this.layoutGravity = gravity;
    }
    setOnClickListener(onCLick) {
        if (onCLick === null){
            this.onClick = null;
            return;
        }

        if (typeof onCLick === 'string') {
            // Buscamos el nombre de metodo en el contexto
            var encontrado = false;
            for (var obj in this.context) {
                // Falta verificar si el objeto es una funcion
                if (typeof this.context[obj] === 'function') {
                    if (obj === onCLick) {
                        this.onClick = this.context[onCLick];
                        encontrado = true;
                        break;
                    }
                }
            }
            if (encontrado === false)
                throw new Exception(`No se pudo encontrar la funcion [${onCLick}] dentro del contexto [${this.context.className}]`);
        }else if (typeof onCLick === 'function') {
            this.onClick = onCLick;
        }
    }
    setMP(dr, ic, txt, tc) {
        var popupError = new PopupWindow(this.getContext());
        var message = new TextView(popupError);
        message.setText(txt);
        if (ic !== null)
            message.setDrawableLeft(ic);
        message.setBackground(dr);
        message.setSingleLine(true);
        message.setTextColor(tc);

        popupError.setView(this);
        popupError.setContentView(message);
        popupError.show(function () {
            setTimeout(function () {
                popupError.cancel();
            }, 3000);
        });
    }
    showAlertMsg(msg) {
        this.setMP("res/drawable/util/bg_alerta.9.png", "res/drawable/util/ic_alert.png", msg, "#653400");
    }
    showConfirmMsg(msg) {
        this.setMP("res/drawable/util/bg_confirm.9.png", "res/drawable/util/ic_confirm.png", msg, "#346700");
    }
    showErrorMsg(msg) {
        this.setMP("res/drawable/util/bg_error.9.png", "res/drawable/util/ic_error.png", msg, "#A90400");
    }
    showInfoMsg(msg) {
        this.setMP("res/drawable/util/bg_info.9.png", "res/drawable/util/ic_info.png", msg, "#4C95E7");
    }
    parse(nodeXml) {
        // VISIBILITY DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_VISIBILITY) !== null) 
            this.visibility = nodeXml.getAttribute(LayoutInflater.ATTR_VISIBILITY);

        // PADDING DEL VIEW
        var padding = nodeXml.getAttribute(LayoutInflater.ATTR_PADDING);
        if (padding !== null) {
            var pad = parseInt(padding);
            this.padding.top = this.padding.left = this.padding.right = this.padding.bottom = pad;
        }
        // MARGEN DEL COMPONENTE
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN)!=null)
            this.margin.top = this.margin.left = this.margin.right = this.margin.bottom = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_BOTTOM)!=null)
            this.margin.bottom = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_BOTTOM));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_LEFT)!=null)
            this.margin.left = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_LEFT));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_RIGHT)!=null)
            this.margin.right = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_RIGHT));
        if(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_TOP)!=null)
            this.margin.top = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_MARGIN_TOP));

        // ID DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_ID) !== null)
            this.id = nodeXml.getAttribute(LayoutInflater.ATTR_ID);

        // LAYOUT GRAVITY DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY) !== null)
            this.layoutGravity = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY);
        // WIDTH DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WIDTH) !== null)
            this.width = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WIDTH);
        // HEIGHT DEL VIEW
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_HEIGHT) !== null)
            this.height = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_HEIGHT);
        this.tooltip = nodeXml.getAttribute('tooltip');

        // BACKGROUDN DEL VIEW
        this.background = nodeXml.getAttribute(LayoutInflater.ATTR_BACKGROUND);
        this.onClick = nodeXml.getAttribute(LayoutInflater.ATTR_ON_CLICK);

        if (nodeXml.getAttribute(LayoutInflater.ATTR_MIN_HEIGHT) !== null)
            this.minHeigth = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_MIN_HEIGHT))||10;

        if (nodeXml.getAttribute(LayoutInflater.ATTR_MIN_WIDTH) !== null)
            this.minWidth = parseInt(nodeXml.getAttribute(LayoutInflater.ATTR_MIN_WIDTH))||10;
    }

    async loadResources() {
        if(!this.elemDom) // Verificamos que el elemento este agregado a la vista y que exista
            return;
        // OnClick
        if(this.onClick)
            this.elemDom.onclick=()=>{
                this.onClick(this);
            };
        if(this.background){
            // Se verifica que tipo de fondo
            if(this.background instanceof BaseBackground)
                this.backgroundPainter = this.background;
            else if(Resource.isImageNinePathResource(this.background)){ // Imagen de fondo de nine path
                // let imageInBase64 = Resource.loa
                this.backgroundPainter = new NinepathBackground(this.elemDom,this.background);
            } 
            else if(Resource.isImageResource(this.background) || Resource.isBase64Resource(this.background))
                this.backgroundPainter = new ImageBackground(this.elemDom,this.background);
            else if(Resource.isColorResource(this.background))
                this.backgroundPainter = new ColorBackground(this.elemDom,this.background);
            else
                throw new Exception(`No se pudo identificar el tipo de fondo [${this.background}]`);
        }else
            this.backgroundPainter = new EmplyBackground(this.elemDom);
            
        await this.backgroundPainter.load();

        // Tooltip de Vista
        this.elemDom.setAttribute("title", this.tooltip);
        // Visibilidad
        switch (this.visibility) {
            case View.INVISIBLE:
                this.elemDom.style.visibility = 'hidden';
                break;
            case View.GONE:
                this.elemDom.style.visibility = 'hidden';
                break;
            default:
                this.elemDom.style.visibility = 'block';
                break;
        }
    }

    async repaintSync() {
        await this.backgroundPainter.paint();
    }
    
    // this.parentView.elemDom.appendChild(this.elemDom);
    async onMeasureSync(maxWidth, maxHeigth) {
        if(!this.elemDom) return; // No realizada nada si no fué agregado a la vista


        // ************  ANCHO DE PANTALLA  ************
        switch (this.width) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.width = (maxWidth - this.margin.left - this.margin.right) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.width = 'auto';
                break;
            default:
                var width = parseInt(this.width);
                width = Math.max(width,this.maxWidth);
                this.elemDom.style.width = width + 'px';
                break;
        }

        switch (this.height) {
            case LayoutInflater.MATCH_PARENT:
                this.elemDom.style.height = (maxHeigth - this.margin.top - this.margin.bottom) + 'px';
                break;
            case LayoutInflater.WRAP_CONTENT:
                this.elemDom.style.height = 'auto';
                break;
            default:
                var height = parseInt(this.height);
                height = Math.max(height,this.maxHeigth);
                this.elemDom.style.height = height + 'px';
                break;
        }

        await this.backgroundPainter.paint();
    }
}
// Class: src/layout/ViewGroup.js
class ViewGroup extends View{
    constructor(context){
        super(context);
        this.viewsChilds = new Array();
        this.name = "ViewGroup";
        //this.elemDom.style.overflow = 'hidden';
    }
    // @Override
    parse(nodeXml) {
        super.parse(nodeXml);
        //console.log("Nro hijos de "+nodeXml.tagName+" = "+nodeXml.children.length);
        for (let index = 0; index < nodeXml.children.length; index++){
            let nodeChild = nodeXml.children[index];
            let child = this.parseViewChild(nodeChild);
            child.parentView = this;
            this.viewsChilds.push(child);
        }
    }
    parseViewChild(nodeXml) {
        let child = LayoutInflater.inflate(this.context, nodeXml);
        return child;
    }
    findViewById(idView) {
        if (idView === null && idView === undefined)
            return null;
        for (let i = 0; i < this.viewsChilds.length; i++) {
            let view = this.viewsChilds[i];
            if (view.id === idView)
                return view;
            if (view instanceof ViewGroup) {
                var viewTemp = view.findViewById(idView);
                if (viewTemp !== null)
                    return viewTemp;
            }
        }
        return null;
    }
    findViewChildById(idView) {
        if (idView === null && idView === undefined)
            return null;
        for (let i = 0; i < this.viewsChilds.length; i++) {
            let view = this.viewsChilds[i];
            if (view.id === idView)
                return view;
        }
        return null;
    }
    async addViewSync(viewChild) {
        if (viewChild === null || viewChild === undefined)
            throw new Exception("El view que desea agregar es nulo o no esta definido");
        if(!viewChild instanceof View)
            throw new Exception("El objeto a agregar no es una instancia de View");
        viewChild.parentView = this;
        this.elemDom.appendChild(viewChild.createDomElement());
        this.viewsChilds.push(viewChild);
    }
    getViewVisibles() {
        // agrupamos los GONE's y los INVISIBLE's
        let vistos = new Array();
        for (let index = 0; index < this.viewsChilds.length; index++) {
            let view = this.viewsChilds[index];
            if (view.visibility === View.VISIBLE)
                vistos.push(view);
        }
        return vistos;
    }
    getChildCount() {
        return this.viewsChilds.length;
    }
    getChildAt(i) {
        return this.viewsChilds[i];
    }
    //@Override
    createDomElement() {
        super.createDomElement();
        for(let view of this.viewsChilds)
            this.elemDom.appendChild(view.createDomElement());
        return this.elemDom;
    }
    
    //@Override
    async loadResources(){
        await super.loadResources();
        for(let view of this.viewsChilds)
            await view.loadResources();
    }
    
    //@Override
    async onMeasureSync(maxWidth, maxHeight){
        await super.onMeasureSync(maxWidth, maxHeight);
        for(let view of this.viewsChilds)
            await view.onMeasureSync(maxWidth, maxHeight);
    }
}
// Class: src/layout/LinearLayout.js
class LinearLayout extends ViewGroup {
    constructor(context) {
        super(context);
        this.orientation = LayoutInflater.HORIZONTAL;
        this.name = "LinearLayout";
    }
    //Override
    getTypeElement() {
        return "LinearLayout";
    }
    //Override
    parse(nodeXml) {
        super.parse(nodeXml);
        if (nodeXml.getAttribute(LayoutInflater.ATTR_ORIENTATION) === LayoutInflater.VERTICAL)
            this.orientation = LayoutInflater.VERTICAL;
    }
    //Override
    parseViewChild(nodeXml) {
        let view = super.parseViewChild(nodeXml);
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY) !== null)
            view.layoutGravity = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_GRAVITY);
        else
            view.layoutGravity = null;
        if (nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WEIGHT) !== null){
            let weight = nodeXml.getAttribute(LayoutInflater.ATTR_LAYOUT_WEIGHT);
            var num = parseFloat(weight);
            if (isNaN(num))
                throw new Exception(
                    "El valor del atributo [" + LayoutInflater.ATTR_LAYOUT_WEIGHT +"] del view [" + view.name + "] no es un numero [" +weight + "]");

            if (num > 0)
                throw new Exception(
                    "El valor del atributo [" + LayoutInflater.ATTR_LAYOUT_WEIGHT + "] del view [" + view.name + "] no es un numero valido [" +weight + "]");
            view.layoutWeight = num;
        }
        return view;
    }
    //@Override
    async onMeasureSync(maxWidth, maxHeight){
        await super.onMeasureSync(maxWidth, maxHeight);
        let visibles = this.getViewVisibles();
        if(visibles.length === 0)
            return;
        if (this.orientation === LayoutInflater.VERTICAL)
            await this.onMeasureVertical(visibles, this.elemDom.clientWidth - this.padding.left - this.padding.right, this.elemDom.clientHeight - this.padding.top - this.padding.bottom);
        else
            await this.onMeasureHorizontal(visibles, this.elemDom.clientWidth - this.padding.left - this.padding.right, this.elemDom.clientHeight - this.padding.top - this.padding.bottom);
    }
    async onMeasureVertical(visibles, maxWidth, maxHeight) {
        var mayHeight = 0;
        var mayWidth = 0;

        var sumHeigthWrap = 0;
        var arrayWeigh = new Array();

        //Establenciendo dimensión de los componentes
        for(let view of visibles){
            if (view.layoutWeight)
            arrayWeigh.push(view);
            else{
                await view.onMeasureSync(maxWidth,maxHeight);
                sumHeigthWrap = sumHeigthWrap + view.margin.top + this.elemDom.clientHeight + view.margin.bottom;
            }
        }
        let altoWeigth = maxHeight - sumHeigthWrap;
        for(let view of arrayWeigh){
            await view.onMeasureSync(maxWidth,altoWeigth*view.layoutWeight);
        }

        // Dibujando las vistas
        var posTop = this.padding.top;
        for(let view of visibles){
            // Posición horizontal
            var gravitys = null;
            if (view.layoutGravity === null)
                gravitys = [LayoutInflater.LEFT];
            else
                gravitys = view.layoutGravity.split("|");
            for (let j = 0; j < gravitys.length; j++) {
                switch (gravitys[j]) {
                    case LayoutInflater.LEFT:
                        view.elemDom.style.left = (this.padding.left + view.margin.left) + 'px';
                        break;
                    case LayoutInflater.RIGHT:
                        view.elemDom.style.left = (ancho - view.elemDom.clientWidth - view.margin.right - this.padding.right) + 'px';
                        break;
                    case LayoutInflater.CENTER_HORIZONTAL:
                        view.elemDom.style.left = (ancho / 2 - view.elemDom.clientWidth / 2) + 'px';
                        break;
                }
            }
            // Posición vertical
            view.elemDom.style.top = (posTop + view.margin.top) + 'px';
            posTop = posTop + view.margin.top + view.elemDom.clientHeight + view.margin.bottom;

            let sum = parseInt(view.elemDom.style.top) + view.elemDom.clientHeight + this.padding.bottom + view.margin.bottom;
            if (sum > mayHeight)
                mayHeight = sum;

            sum = parseInt(view.elemDom.style.left) + view.elemDom.clientWidth + this.padding.right + view.margin.right;
            if (sum > mayWidth)
                mayWidth = sum;
            // Ajustando contenido
            switch (this.height) {
                case LayoutInflater.MATCH_PARENT:
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    if (mayHeight < this.minHeigth)
                        mayHeight = this.minHeigth;
                    this.elemDom.style.height = (mayHeight) + 'px';
                    await this.repaintSync();
                    break;
                default:
                    break;
            }
            switch (this.width) {
                case LayoutInflater.MATCH_PARENT:
                    break;
                case LayoutInflater.WRAP_CONTENT:
                    if (mayWidth < this.minWidth)
                        mayWidth = this.minWidth;
                    this.elemDom.style.width = (mayWidth) + 'px';
                    await this.repaintSync();
                    break;
                default: break;
            }
        }
    }

    onMeasureHorizontal(visibles, maxWidth, maxHeight, loadListener) {
        var this_ = this;
        var ancho = maxWidth;
        var alto = maxHeight;

        var mayHeight = 0;
        var mayWidth = 0;

        var sumWidthWrap = 0;
        var arrayWeigh = new Array();

        var index = -1;
        var view = null;
        // Para los que no tienen WEIGHT
        var loadWrapCompleted = function () {
            var loadAllCompleted = function () {
                var posLeft = this_.padding.left;
                for (var index = 0; index < visibles.length; index++) {
                    var view = visibles[index];
                    var gravitys = null;
                    if (view.layoutGravity === null)
                        gravitys = [LayoutInflater.TOP];
                    else
                        gravitys = view.layoutGravity.split("|");

                    for (var j = 0; j < gravitys.length; j++) {
                        switch (gravitys[j]) {
                            case LayoutInflater.TOP:
                                view.elemDom.style.top = (this_.padding.top + view.margin.top) + 'px';
                                break;
                            case LayoutInflater.BOTTOM:
                                view.elemDom.style.top = (alto - view.getHeight() - view.margin.bottom - this_.padding.bottom) + 'px';
                                break;
                            case LayoutInflater.CENTER_HORIZONTAL:
                                view.elemDom.style.top = (alto / 2 - view.getHeight() / 2) + 'px';
                                break;
                        }
                    }

                    view.elemDom.style.left = (posLeft + view.margin.left) + 'px';
                    posLeft = posLeft + view.margin.left + view.getWidth() + view.margin.right;

                    var sum = parseInt(view.elemDom.style.top) + view.getHeight() + this_.padding.bottom + view.margin.bottom;
                    if (sum > mayHeight)
                        mayHeight = sum;

                    sum = parseInt(view.elemDom.style.left) + view.getWidth() + this_.padding.right + view.margin.right;
                    if (sum > mayWidth)
                        mayWidth = sum;
                }

                // Ajustando contenido
                switch (this_.height) {
                    case LayoutInflater.MATCH_PARENT:
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        if (mayHeight < this_.minHeigth)
                            mayHeight = this_.minHeigth;
                        this_.elemDom.style.height = (mayHeight) + 'px';
                        this_.invalidate();
                        break;
                    default:
                        break;
                }
                switch (this_.width) {
                    case LayoutInflater.MATCH_PARENT:
                        break;
                    case LayoutInflater.WRAP_CONTENT:
                        if (mayWidth < this_.minWidth)
                            mayWidth = this_.minWidth;
                        this_.elemDom.style.width = (mayWidth) + 'px';
                        this_.invalidate();
                        break;
                    default: break;
                }
                if (loadListener !== undefined)
                    loadListener();
            };

            if (arrayWeigh.length === 1) {
                view = arrayWeigh[0];
                view.onMeasure(ancho - sumWidthWrap, alto, loadAllCompleted);
            }
            else if (arrayWeigh.length > 0) {
                index = 0;
                var anchoTotal = ancho - sumWidthWrap;
                var viewWeighListener = function () {
                    index++;
                    if (index < arrayWeigh.length) {
                        view = visibles[index];
                        view.onMeasure(ancho, alto, viewWeighListener);
                    }
                    else
                        loadAllCompleted();
                };
                var view = arrayWeigh[index];
                // obtenemos el porsentage que le corresponde
                var num = parseFloat(view.layoutWeight);
                if (isNaN(num))
                    throw new Exception(
                        "El valor del atributo [" + LayoutInflater.ATTR_LAYOUT_WEIGHT +
                        "] del view [" + view.name + "] no es un numero [" +
                        view.layoutWeight + "]");

                if (num > 0)
                    throw new Exception(
                        "El valor del atributo [" + LayoutInflater.ATTR_LAYOUT_WEIGHT +
                        "] del view [" + view.name + "] no es un numero valido [" +
                        view.layoutWeight + "]");

                view.onMeasure(
                    anchoTotal * num,
                    alto,
                    viewWeighListener);
            }
            else
                loadAllCompleted();
        };
        var viewWrapListener = function () {
            if (view.layoutWeight)
                arrayWeigh.push(view);
            else
                sumWidthWrap = sumWidthWrap + view.margin.left + view.getWidth() + view.margin.right;
            index++;
            if (index < visibles.length) {
                view = visibles[index];
                if (view.layoutWeight) // No se realiza nada con los que tienen weight
                    viewWrapListener();
                else { // Se obtiene el tamaño para el que no tiene weigch
                    view.onMeasure(
                        ancho,
                        alto,
                        viewWrapListener);
                }
            }
            else // Se finaliza la busqueda de los weigch
                loadWrapCompleted();
        };
        index = 0;
        view = visibles[index];
        if (view.layoutWeight)
            viewWrapListener();
        else {
            view.onMeasure(ancho, alto, viewWrapListener);
        }
    }
    setOrientation(orientation) {
        this.orientation = orientation;
    }
}
// Class: src/page/Page.js
class Page extends Context{
    // viewRoot: null,
    // viewListener: null,
    // urlView: null,
    // history: true,
    // fullScreem: false,
    // previusPage: null,
    // REQUEST_OK: 121,
    // REQUEST_CANCELED: 123,
    // resultCode: this.REQUEST_CANCELED,
    // resultData: null,
    // requestCode: -1,
    // loaded: false,

    constructor(){
        super();
        this.className = null;
    }

    findViewById(idView) {
        if (this.viewRoot !== null)
            if (this.viewRoot.id === idView)
                return this.viewRoot;
        if (this.viewRoot instanceof ViewGroup) {
            return this.viewRoot.findViewById(idView);
        }
        else
            throw new Exception("El contenidor principal para la pagina no es heredado de ViewGroup");
    }

    setContentView(objView) {
        if (objView instanceof View)
            this.viewRoot = objView;
        else if(typeof objView==='string')
            this.urlView = objView;
        else{
            throw "La vista debe ser una instancia de View o una url de un archivo XML"
        }
    }

    startLoaded(){
        this.viewRoot.elemDom.style.visibility = 'hidden';
        this.viewRoot.elemDom.style.opacity = 0;
    }
    loadedFinized(){
        this.viewRoot.elemDom.style.transition = "opacity 5s ease-in-out";
        this.viewRoot.elemDom.style.opacity = 1;
        this.viewRoot.elemDom.style.visibility = 'visible';
    }
    onCreate() { }
    onStart() { }
    onDestroy() { }
    onPause() { }
    onResume() { }

    setNoHistory(history) {
        this.history = !history;
    }
    startPage(intent) {
        if (intent === undefined || intent === null)
            throw new Exception("El intent es nulo o no esta definido");
        PageManager.startPage(intent);
    }
    setTitle(title) {
        document.title = title;
    }
    finish() {
        PageManager.finishPage(this);
        if (this.previusPage !== null) {
            if (this.requestCode > 0)
                this.previusPage.onPageResult(this.requestCode, this.resultCode, this.resultData);
        }
    }
    startPageForResult(intent, requestCode) {
        this.requestCode = requestCode;
        this.startPage(intent);
    }
    onPageResult(requestCode, resultCode, intent) { }
}
// Class: src/page/animation/SpinnerAnimation.js
class SpinnerAnimation {
    constructor(propProgress){
        if(propProgress)
            this.propProgress = propProgress;
        else{
            this.propProgress = {
                left: (PageManager.getWindowsDimension().width / 2 - 150 / 2),
                top: (PageManager.getWindowsDimension().height / 2 - 150 / 2),
                width: 150, 
                height: 150, 
                showBackground: true
            };
        }
        this.elemLoader = null;
        this.elemImgLoader= null;
    }

    show(){
        // Creamos el loader para la pagina
        if(this.propProgress.showBackground===true){
            this.elemLoader = document.createElement('div');
            this.elemLoader.style.margin = '0px';
            this.elemLoader.style.width = '100%';
            this.elemLoader.style.height = '100%';
            this.elemLoader.style.position = 'absolute';
            this.elemLoader.style.backgroundColor = "rgba(1, 11,20, 0.5)";
        }

        this.elemImgLoader = document.createElement('div');
        this.elemImgLoader.style.width = this.propProgress.width + 'px';
        this.elemImgLoader.style.height = this.propProgress.height + 'px';
        this.elemImgLoader.style.position = 'absolute';
        this.elemImgLoader.style.background = '#05112B';
        this.elemImgLoader.style.top = this.propProgress.top + 'px';
        this.elemImgLoader.style.left = this.propProgress.left + 'px';

        var min = Math.min(this.propProgress.width, this.propProgress.height);
        // propProgress.width = min;
        // propProgress.height = min;

        var imgLoader = document.createElement('canvas');
        var radiusBack = this.propProgress.width / 8;

        imgLoader.setAttribute("width", this.propProgress.width - radiusBack * 2);
        imgLoader.setAttribute("height", this.propProgress.height - radiusBack * 2);

        imgLoader.style.position = 'absolute';
        imgLoader.style.top = radiusBack + 'px';
        imgLoader.style.left = radiusBack + 'px';
        var ctx = imgLoader.getContext("2d");

        // Pintando spinner
        var lines = 13;
        var radius = imgLoader.width / 10;
        var rotation = radius;
        ctx.save();

        this.elemImgLoader.style.borderRadius = (radiusBack) + 'px';

        ctx.translate(imgLoader.width / 2, imgLoader.height / 2);
        ctx.rotate(Math.PI * 2 * rotation);
        for (var i = 0; i < lines; i++) {
            ctx.beginPath();
            ctx.rotate(Math.PI * 2 / lines);
            ctx.fillStyle = "rgba(250,254,255," + (1 - i / lines) + ")";
            ctx.arc(imgLoader.width / 2 - radius, 0, radius, 0, 2 * Math.PI, false);
            ctx.fill();
            radius = radius - radius / (lines - 1);
            if (radius < 1)
                break;
        }
        ctx.restore();

        if (this.propProgress.showBackground === true)
            document.body.appendChild(this.elemLoader);
        imgLoader.style.left = (this.elemImgLoader.clientWidth / 2 + radiusBack) + "px";
        this.elemImgLoader.appendChild(imgLoader);
        document.body.appendChild(this.elemImgLoader);
        imgLoader.className = "rotate";
    }

    hide(){
        if (this.propProgress.showBackground === true)
            this.elemLoader.parentNode.removeChild(this.elemLoader);
        //document.body.removeChild(elemLoader);
        this.elemImgLoader.parentNode.removeChild(this.elemImgLoader);
    }
}